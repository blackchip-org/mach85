[{"address":41866,"text":"copy stack pointer"},{"address":41867,"text":"+1 pass return address"},{"address":41868,"text":"+2 pass return address"},{"address":41869,"text":"+3 pass calling routine return address"},{"address":41870,"text":"+4 pass calling routine return address"},{"address":41871,"text":"get the token byte from the stack"},{"address":41874,"text":"is it the FOR token"},{"address":41876,"text":"if not FOR token just exit\nit was the FOR token"},{"address":41878,"text":"get FOR/NEXT variable pointer high byte"},{"address":41880,"text":"branch if not null"},{"address":41882,"text":"get FOR variable pointer low byte"},{"address":41885,"text":"save FOR/NEXT variable pointer low byte"},{"address":41887,"text":"get FOR variable pointer high byte"},{"address":41890,"text":"save FOR/NEXT variable pointer high byte"},{"address":41892,"text":"compare variable pointer with stacked variable pointer\nhigh byte"},{"address":41895,"text":"branch if no match"},{"address":41897,"text":"get FOR/NEXT variable pointer low byte"},{"address":41899,"text":"compare variable pointer with stacked variable pointer\nlow byte"},{"address":41902,"text":"exit if match found"},{"address":41904,"text":"copy index"},{"address":41905,"text":"clear carry for add"},{"address":41906,"text":"add FOR stack use size"},{"address":41908,"text":"copy back to index"},{"address":41909,"text":"loop if not at start of stack"},{"address":41912,"text":"check available memory, do out of memory error if no room"},{"address":41915,"text":"set end of arrays low byte"},{"address":41917,"text":"set end of arrays high byte\nopen up a space in the memory, don't set the array end"},{"address":41919,"text":"set carry for subtract"},{"address":41920,"text":"get block end low byte"},{"address":41922,"text":"subtract block start low byte"},{"address":41924,"text":"save MOD(block length/$100) byte"},{"address":41926,"text":"copy MOD(block length/$100) byte to Y"},{"address":41927,"text":"get block end high byte"},{"address":41929,"text":"subtract block start high byte"},{"address":41931,"text":"copy block length high byte to X"},{"address":41932,"text":"+1 to allow for count=0 exit"},{"address":41933,"text":"copy block length low byte to A"},{"address":41934,"text":"branch if length low byte=0\nblock is (X-1)*256+Y bytes, do the Y bytes first"},{"address":41936,"text":"get block end low byte"},{"address":41938,"text":"set carry for subtract"},{"address":41939,"text":"subtract MOD(block length/$100) byte"},{"address":41941,"text":"save corrected old block end low byte"},{"address":41943,"text":"branch if no underflow"},{"address":41945,"text":"else decrement block end high byte"},{"address":41947,"text":"set carry for subtract"},{"address":41948,"text":"get destination end low byte"},{"address":41950,"text":"subtract MOD(block length/$100) byte"},{"address":41952,"text":"save modified new block end low byte"},{"address":41954,"text":"branch if no underflow"},{"address":41956,"text":"else decrement block end high byte"},{"address":41958,"text":"branch always"},{"address":41960,"text":"get byte from source"},{"address":41962,"text":"copy byte to destination"},{"address":41964,"text":"decrement index"},{"address":41965,"text":"loop until Y=0\nnow do Y=0 indexed byte"},{"address":41967,"text":"get byte from source"},{"address":41969,"text":"save byte to destination"},{"address":41971,"text":"decrement source pointer high byte"},{"address":41973,"text":"decrement destination pointer high byte"},{"address":41975,"text":"decrement block count"},{"address":41976,"text":"loop until count = $0"},{"address":41979,"text":"*2"},{"address":41980,"text":"need at least $3E bytes free"},{"address":41982,"text":"if overflow go do out of memory error then warm start"},{"address":41984,"text":"save result in temp byte"},{"address":41986,"text":"copy stack"},{"address":41987,"text":"compare new limit with stack"},{"address":41989,"text":"if stack \u003c limit do out of memory error then warm start"},{"address":41992,"text":"compare with bottom of string space high byte"},{"address":41994,"text":"if less then exit (is ok)"},{"address":41996,"text":"skip next test if greater (tested \u003c)\nhigh byte was =, now do low byte"},{"address":41998,"text":"compare with bottom of string space low byte"},{"address":42000,"text":"if less then exit (is ok)\naddress is \u003e string storage ptr (oops!)"},{"address":42002,"text":"push address low byte"},{"address":42003,"text":"set index to save $57 to $60 inclusive"},{"address":42005,"text":"copy address high byte (to push on stack)\nsave misc numeric work area"},{"address":42006,"text":"push byte"},{"address":42007,"text":"get byte from $57 to $60"},{"address":42009,"text":"decrement index"},{"address":42010,"text":"loop until all done"},{"address":42012,"text":"do garbage collection routine\nrestore misc numeric work area"},{"address":42015,"text":"set index to restore bytes"},{"address":42017,"text":"pop byte"},{"address":42018,"text":"save byte to $57 to $60"},{"address":42020,"text":"increment index"},{"address":42021,"text":"loop while -ve"},{"address":42023,"text":"pop address high byte"},{"address":42024,"text":"copy back to Y"},{"address":42025,"text":"pop address low byte"},{"address":42026,"text":"compare with bottom of string space high byte"},{"address":42028,"text":"if less then exit (is ok)"},{"address":42030,"text":"if greater do out of memory error then warm start\nhigh byte was =, now do low byte"},{"address":42032,"text":"compare with bottom of string space low byte"},{"address":42034,"text":"if \u003e= do out of memory error then warm start\nok exit, carry clear"},{"address":42037,"text":"error code $10, out of memory error\ndo error #X then warm start"},{"address":42039,"text":"do error message"},{"address":42042,"text":"copy error number"},{"address":42043,"text":"*2"},{"address":42044,"text":"copy to index"},{"address":42045,"text":"get error message pointer low byte"},{"address":42048,"text":"save it"},{"address":42050,"text":"get error message pointer high byte"},{"address":42053,"text":"save it"},{"address":42055,"text":"close input and output channels"},{"address":42058,"text":"clear A"},{"address":42060,"text":"clear current I/O channel, flag default"},{"address":42062,"text":"print CR/LF"},{"address":42065,"text":"print \"?\""},{"address":42068,"text":"clear index"},{"address":42070,"text":"get byte from message"},{"address":42072,"text":"save status"},{"address":42073,"text":"mask 0xxx xxxx, clear b7"},{"address":42075,"text":"output character"},{"address":42078,"text":"increment index"},{"address":42079,"text":"restore status"},{"address":42080,"text":"loop if character was not end marker"},{"address":42082,"text":"flush BASIC stack and clear continue pointer"},{"address":42085,"text":"set \" ERROR\" pointer low byte"},{"address":42087,"text":"set \" ERROR\" pointer high byte"},{"address":42089,"text":"print null terminated string"},{"address":42092,"text":"get current line number high byte"},{"address":42094,"text":"increment it"},{"address":42095,"text":"branch if was in immediate mode"},{"address":42097,"text":"do \" IN \" line number message"},{"address":42100,"text":"set \"READY.\" pointer low byte"},{"address":42102,"text":"set \"READY.\" pointer high byte"},{"address":42104,"text":"print null terminated string"},{"address":42107,"text":"set for control messages only"},{"address":42109,"text":"control kernal messages"},{"address":42112,"text":"do BASIC warm start"},{"address":42115,"text":"call for BASIC input"},{"address":42118,"text":"save BASIC execute pointer low byte"},{"address":42120,"text":"save BASIC execute pointer high byte"},{"address":42122,"text":"increment and scan memory"},{"address":42125,"text":"copy byte to set flags"},{"address":42126,"text":"loop if no input\ngot to interpret the input line now ...."},{"address":42128,"text":"current line high byte to -1, indicates immediate mode"},{"address":42130,"text":"set current line number high byte"},{"address":42132,"text":"if numeric character go handle new BASIC line\nno line number .. immediate mode"},{"address":42134,"text":"crunch keywords into BASIC tokens"},{"address":42137,"text":"go scan and interpret code"},{"address":42140,"text":"get fixed-point number into temporary integer"},{"address":42143,"text":"crunch keywords into BASIC tokens"},{"address":42146,"text":"save index pointer to end of crunched line"},{"address":42148,"text":"search BASIC for temporary integer line number"},{"address":42151,"text":"if not found skip the line delete\nline # already exists so delete it"},{"address":42153,"text":"set index to next line pointer high byte"},{"address":42155,"text":"get next line pointer high byte"},{"address":42157,"text":"save it"},{"address":42159,"text":"get start of variables low byte"},{"address":42161,"text":"save it"},{"address":42163,"text":"get found line pointer high byte"},{"address":42165,"text":"save it"},{"address":42167,"text":"get found line pointer low byte"},{"address":42169,"text":"decrement index"},{"address":42170,"text":"subtract next line pointer low byte"},{"address":42172,"text":"clear carry for add"},{"address":42173,"text":"add start of variables low byte"},{"address":42175,"text":"set start of variables low byte"},{"address":42177,"text":"save destination pointer low byte"},{"address":42179,"text":"get start of variables high byte"},{"address":42181,"text":"-1 + carry"},{"address":42183,"text":"set start of variables high byte"},{"address":42185,"text":"subtract found line pointer high byte"},{"address":42187,"text":"copy to block count"},{"address":42188,"text":"set carry for subtract"},{"address":42189,"text":"get found line pointer low byte"},{"address":42191,"text":"subtract start of variables low byte"},{"address":42193,"text":"copy to bytes in first block count"},{"address":42194,"text":"branch if no underflow"},{"address":42196,"text":"increment block count, correct for = 0 loop exit"},{"address":42197,"text":"decrement destination high byte"},{"address":42199,"text":"clear carry for add"},{"address":42200,"text":"add source pointer low byte"},{"address":42202,"text":"branch if no overflow"},{"address":42204,"text":"else decrement source pointer high byte"},{"address":42206,"text":"clear carry\nclose up memory to delete old line"},{"address":42207,"text":"get byte from source"},{"address":42209,"text":"copy to destination"},{"address":42211,"text":"increment index"},{"address":42212,"text":"while \u003c\u003e 0 do this block"},{"address":42214,"text":"increment source pointer high byte"},{"address":42216,"text":"increment destination pointer high byte"},{"address":42218,"text":"decrement block count"},{"address":42219,"text":"loop until all done\ngot new line in buffer and no existing same #"},{"address":42221,"text":"reset execution to start, clear variables, flush stack\nand return"},{"address":42224,"text":"rebuild BASIC line chaining"},{"address":42227,"text":"get first byte from buffer"},{"address":42230,"text":"if no line go do BASIC warm start\nelse insert line into memory"},{"address":42232,"text":"clear carry for add"},{"address":42233,"text":"get start of variables low byte"},{"address":42235,"text":"save as source end pointer low byte"},{"address":42237,"text":"add index pointer to end of crunched line"},{"address":42239,"text":"save as destination end pointer low byte"},{"address":42241,"text":"get start of variables high byte"},{"address":42243,"text":"save as source end pointer high byte"},{"address":42245,"text":"branch if no carry to high byte"},{"address":42247,"text":"else increment high byte"},{"address":42248,"text":"save as destination end pointer high byte"},{"address":42250,"text":"open up space in memory\nmost of what remains to do is copy the crunched line into the space opened up in memory,\nhowever, before the crunched line comes the next line pointer and the line number. the\nline number is retrieved from the temporary integer and stored in memory, this\noverwrites the bottom two bytes on the stack. next the line is copied and the next line\npointer is filled with whatever was in two bytes above the line number in the stack.\nthis is ok because the line pointer gets fixed in the line chain re-build."},{"address":42253,"text":"get line number low byte"},{"address":42255,"text":"get line number high byte"},{"address":42257,"text":"save line number low byte before crunched line"},{"address":42260,"text":"save line number high byte before crunched line"},{"address":42263,"text":"get end of arrays low byte"},{"address":42265,"text":"get end of arrays high byte"},{"address":42267,"text":"set start of variables low byte"},{"address":42269,"text":"set start of variables high byte"},{"address":42271,"text":"get index to end of crunched line"},{"address":42273,"text":"-1"},{"address":42274,"text":"get byte from crunched line"},{"address":42277,"text":"save byte to memory"},{"address":42279,"text":"decrement index"},{"address":42280,"text":"loop while more to do\nreset execution, clear variables, flush stack, rebuild BASIC chain and do warm start"},{"address":42282,"text":"reset execution to start, clear variables and flush stack"},{"address":42285,"text":"rebuild BASIC line chaining"},{"address":42288,"text":"go do BASIC warm start"},{"address":42291,"text":"get start of memory low byte"},{"address":42293,"text":"get start of memory high byte"},{"address":42295,"text":"set line start pointer low byte"},{"address":42297,"text":"set line start pointer high byte"},{"address":42299,"text":"clear carry for add"},{"address":42300,"text":"set index to pointer to next line high byte"},{"address":42302,"text":"get pointer to next line high byte"},{"address":42304,"text":"exit if null, [EOT]"},{"address":42306,"text":"point to first code byte of line\nthere is always 1 byte + [EOL] as null entries are deleted"},{"address":42308,"text":"next code byte"},{"address":42309,"text":"get byte"},{"address":42311,"text":"loop if not [EOL]"},{"address":42313,"text":"point to byte past [EOL], start of next line"},{"address":42314,"text":"copy it"},{"address":42315,"text":"add line start pointer low byte"},{"address":42317,"text":"copy to X"},{"address":42318,"text":"clear index, point to this line's next line pointer"},{"address":42320,"text":"set next line pointer low byte"},{"address":42322,"text":"get line start pointer high byte"},{"address":42324,"text":"add any overflow"},{"address":42326,"text":"increment index to high byte"},{"address":42327,"text":"set next line pointer high byte"},{"address":42329,"text":"set line start pointer low byte"},{"address":42331,"text":"set line start pointer high byte"},{"address":42333,"text":"go do next line, branch always"},{"address":42336,"text":"set channel $00, keyboard"},{"address":42338,"text":"input character from channel with error check"},{"address":42341,"text":"compare with [CR]"},{"address":42343,"text":"if [CR] set XY to $200 - 1, print [CR] and exit\ncharacter was not [CR]"},{"address":42345,"text":"save character to buffer"},{"address":42348,"text":"increment buffer index"},{"address":42349,"text":"compare with max+1"},{"address":42351,"text":"branch if \u003c max+1"},{"address":42353,"text":"error $17, string too long error"},{"address":42355,"text":"do error #X then warm start"},{"address":42358,"text":"set XY to $200 - 1 and print [CR]"},{"address":42361,"text":"do crunch BASIC tokens"},{"address":42364,"text":"get BASIC execute pointer low byte"},{"address":42366,"text":"set save index"},{"address":42368,"text":"clear open quote/DATA flag"},{"address":42370,"text":"get a byte from the input buffer"},{"address":42373,"text":"if b7 clear go do crunching"},{"address":42375,"text":"compare with the token for PI, this toke is input\ndirectly from the keyboard as the PI character"},{"address":42377,"text":"if PI save byte then continue crunching\nthis is the bit of code that stops you being able to enter\nsome keywords as just single shifted characters. If this\ndropped through you would be able to enter GOTO as just\n[SHIFT]G"},{"address":42379,"text":"increment read index"},{"address":42380,"text":"loop if more to do, branch always"},{"address":42382,"text":"compare with [SPACE]"},{"address":42384,"text":"if [SPACE] save byte then continue crunching"},{"address":42386,"text":"save buffer byte as search character"},{"address":42388,"text":"compare with quote character"},{"address":42390,"text":"if quote go copy quoted string"},{"address":42392,"text":"get open quote/DATA token flag"},{"address":42394,"text":"branch if b6 of Oquote set, was DATA\ngo save byte then continue crunching"},{"address":42396,"text":"compare with \"?\" character"},{"address":42398,"text":"if not \"?\" continue crunching"},{"address":42400,"text":"else the keyword token is $99, PRINT"},{"address":42402,"text":"go save byte then continue crunching, branch always"},{"address":42404,"text":"compare with \"0\""},{"address":42406,"text":"branch if \u003c, continue crunching"},{"address":42408,"text":"compare with \"\u003c\""},{"address":42410,"text":"if \u003c, 0123456789:; go save byte then continue crunching\ngets here with next character not numeric, \";\" or \":\""},{"address":42412,"text":"copy save index"},{"address":42414,"text":"clear table pointer"},{"address":42416,"text":"clear word index"},{"address":42418,"text":"adjust for pre increment loop"},{"address":42419,"text":"save BASIC execute pointer low byte, buffer index"},{"address":42421,"text":"adjust for pre increment loop"},{"address":42422,"text":"next table byte"},{"address":42423,"text":"next buffer byte"},{"address":42424,"text":"get byte from input buffer"},{"address":42427,"text":"set carry for subtract"},{"address":42428,"text":"subtract table byte"},{"address":42431,"text":"go compare next if match"},{"address":42433,"text":"was it end marker match ?"},{"address":42435,"text":"branch if not, not found keyword\nactually this works even if the input buffer byte is the\nend marker, i.e. a shifted character. As you can't enter\nany keywords as a single shifted character, see above,\nyou can enter keywords in shorthand by shifting any\ncharacter after the first. so RETURN can be entered as\nR[SHIFT]E, RE[SHIFT]T, RET[SHIFT]U or RETU[SHIFT]R.\nRETUR[SHIFT]N however will not work because the [SHIFT]N\nwill match the RETURN end marker so the routine will try\nto match the next character.\nelse found keyword"},{"address":42437,"text":"OR with word index, +$80 in A makes token"},{"address":42439,"text":"restore save index\nsave byte then continue crunching"},{"address":42441,"text":"increment buffer read index"},{"address":42442,"text":"increment save index"},{"address":42443,"text":"save byte to output"},{"address":42446,"text":"get byte from output, set flags"},{"address":42449,"text":"branch if was null [EOL]\nA holds the token here"},{"address":42451,"text":"set carry for subtract"},{"address":42452,"text":"subtract \":\""},{"address":42454,"text":"branch if it was (is now $00)\nA now holds token-':'"},{"address":42456,"text":"compare with the token for DATA-':'"},{"address":42458,"text":"if not DATA go try REM\ntoken was : or DATA"},{"address":42460,"text":"save the token-$3A"},{"address":42462,"text":"set carry for subtract"},{"address":42463,"text":"subtract the token for REM-':'"},{"address":42465,"text":"if wasn't REM crunch next bit of line"},{"address":42467,"text":"else was REM so set search for [EOL]\nloop for \"...\" etc."},{"address":42469,"text":"get byte from input buffer"},{"address":42472,"text":"if null [EOL] save byte then continue crunching"},{"address":42474,"text":"compare with stored character"},{"address":42476,"text":"if match save byte then continue crunching"},{"address":42478,"text":"increment save index"},{"address":42479,"text":"save byte to output"},{"address":42482,"text":"increment buffer index"},{"address":42483,"text":"loop while \u003c\u003e 0, should never reach 0\nnot found keyword this go"},{"address":42485,"text":"restore BASIC execute pointer low byte"},{"address":42487,"text":"increment word index (next word)\nnow find end of this word in the table"},{"address":42489,"text":"increment table index"},{"address":42490,"text":"get table byte"},{"address":42493,"text":"loop if not end of word yet"},{"address":42495,"text":"get byte from keyword table"},{"address":42498,"text":"go test next word if not zero byte, end of table\nreached end of table with no match"},{"address":42500,"text":"restore byte from input buffer"},{"address":42503,"text":"branch always, all unmatched bytes in the buffer are\n$00 to $7F, go save byte in output and continue crunching\nreached [EOL]"},{"address":42505,"text":"save [EOL]"},{"address":42508,"text":"decrement BASIC execute pointer high byte"},{"address":42510,"text":"point to start of buffer-1"},{"address":42512,"text":"set BASIC execute pointer low byte"},{"address":42515,"text":"get start of memory low byte"},{"address":42517,"text":"get start of memory high byte"},{"address":42519,"text":"set index to next line pointer high byte"},{"address":42521,"text":"save low byte as current"},{"address":42523,"text":"save high byte as current"},{"address":42525,"text":"get next line pointer high byte from address"},{"address":42527,"text":"pointer was zero so done, exit"},{"address":42529,"text":"increment index ..."},{"address":42530,"text":"... to line # high byte"},{"address":42531,"text":"get temporary integer high byte"},{"address":42533,"text":"compare with line # high byte"},{"address":42535,"text":"exit if temp \u003c this line, target line passed"},{"address":42537,"text":"go check low byte if ="},{"address":42539,"text":"else decrement index"},{"address":42540,"text":"branch always"},{"address":42542,"text":"get temporary integer low byte"},{"address":42544,"text":"decrement index to line # low byte"},{"address":42545,"text":"compare with line # low byte"},{"address":42547,"text":"exit if temp \u003c this line, target line passed"},{"address":42549,"text":"exit if temp = (found line#)\nnot quite there yet"},{"address":42551,"text":"decrement index to next line pointer high byte"},{"address":42552,"text":"get next line pointer high byte"},{"address":42554,"text":"copy to X"},{"address":42555,"text":"decrement index to next line pointer low byte"},{"address":42556,"text":"get next line pointer low byte"},{"address":42558,"text":"go search for line # in temporary integer\nfrom AX, carry always set"},{"address":42560,"text":"clear found flag"},{"address":42562,"text":"exit if following byte to allow syntax error"},{"address":42564,"text":"clear A"},{"address":42566,"text":"clear index"},{"address":42567,"text":"clear pointer to next line low byte"},{"address":42569,"text":"increment index"},{"address":42570,"text":"clear pointer to next line high byte, erase program"},{"address":42572,"text":"get start of memory low byte"},{"address":42574,"text":"clear carry for add"},{"address":42575,"text":"add null program length"},{"address":42577,"text":"set start of variables low byte"},{"address":42579,"text":"get start of memory high byte"},{"address":42581,"text":"add carry"},{"address":42583,"text":"set start of variables high byte"},{"address":42585,"text":"set BASIC execute pointer to start of memory - 1"},{"address":42588,"text":"set Zb for CLR entry"},{"address":42590,"text":"exit if following byte to allow syntax error"},{"address":42592,"text":"close all channels and files"},{"address":42595,"text":"get end of memory low byte"},{"address":42597,"text":"get end of memory high byte"},{"address":42599,"text":"set bottom of string space low byte, clear strings"},{"address":42601,"text":"set bottom of string space high byte"},{"address":42603,"text":"get start of variables low byte"},{"address":42605,"text":"get start of variables high byte"},{"address":42607,"text":"set end of variables low byte, clear variables"},{"address":42609,"text":"set end of variables high byte"},{"address":42611,"text":"set end of arrays low byte, clear arrays"},{"address":42613,"text":"set end of arrays high byte"},{"address":42615,"text":"perform RESTORE"},{"address":42618,"text":"get the descriptor stack start"},{"address":42620,"text":"set the descriptor stack pointer"},{"address":42622,"text":"pull the return address low byte"},{"address":42623,"text":"copy it"},{"address":42624,"text":"pull the return address high byte"},{"address":42625,"text":"set the cleared stack pointer"},{"address":42627,"text":"set the stack"},{"address":42628,"text":"push the return address high byte"},{"address":42629,"text":"restore the return address low byte"},{"address":42630,"text":"push the return address low byte"},{"address":42631,"text":"clear A"},{"address":42633,"text":"clear the continue pointer high byte"},{"address":42635,"text":"clear the subscript/FNX flag"},{"address":42638,"text":"clear carry for add"},{"address":42639,"text":"get start of memory low byte"},{"address":42641,"text":"add -1 low byte"},{"address":42643,"text":"set BASIC execute pointer low byte"},{"address":42645,"text":"get start of memory high byte"},{"address":42647,"text":"add -1 high byte"},{"address":42649,"text":"save BASIC execute pointer high byte"},{"address":42652,"text":"branch if next character not token (LIST n...)"},{"address":42654,"text":"branch if next character [NULL] (LIST)"},{"address":42656,"text":"compare with token for -"},{"address":42658,"text":"exit if not - (LIST -m)\nLIST [[n][-m]]\nthis bit sets the n , if present, as the start and end"},{"address":42660,"text":"get fixed-point number into temporary integer"},{"address":42663,"text":"search BASIC for temporary integer line number"},{"address":42666,"text":"scan memory"},{"address":42669,"text":"branch if no more chrs\nthis bit checks the - is present"},{"address":42671,"text":"compare with token for -"},{"address":42673,"text":"return if not \"-\" (will be SN error)\nLIST [n]-m\nthe - was there so set m as the end value"},{"address":42675,"text":"increment and scan memory"},{"address":42678,"text":"get fixed-point number into temporary integer"},{"address":42681,"text":"exit if not ok"},{"address":42683,"text":"dump return address low byte, exit via warm start"},{"address":42684,"text":"dump return address high byte"},{"address":42685,"text":"get temporary integer low byte"},{"address":42687,"text":"OR temporary integer high byte"},{"address":42689,"text":"branch if start set"},{"address":42691,"text":"set for -1"},{"address":42693,"text":"set temporary integer low byte"},{"address":42695,"text":"set temporary integer high byte"},{"address":42697,"text":"set index for line"},{"address":42699,"text":"clear open quote flag"},{"address":42701,"text":"get next line pointer high byte"},{"address":42703,"text":"if null all done so exit"},{"address":42705,"text":"do CRTL-C check vector"},{"address":42708,"text":"print CR/LF"},{"address":42711,"text":"increment index for line"},{"address":42712,"text":"get line number low byte"},{"address":42714,"text":"copy to X"},{"address":42715,"text":"increment index"},{"address":42716,"text":"get line number high byte"},{"address":42718,"text":"compare with temporary integer high byte"},{"address":42720,"text":"branch if no high byte match"},{"address":42722,"text":"compare with temporary integer low byte"},{"address":42724,"text":"branch if = last line to do, \u003c will pass next branch\nelse"},{"address":42726,"text":"if greater all done so exit"},{"address":42728,"text":"save index for line"},{"address":42730,"text":"print XA as unsigned integer"},{"address":42733,"text":"space is the next character"},{"address":42735,"text":"get index for line"},{"address":42737,"text":"mask top out bit of character"},{"address":42739,"text":"go print the character"},{"address":42742,"text":"was it \" character"},{"address":42744,"text":"if not skip the quote handle\nwe are either entering or leaving a pair of quotes"},{"address":42746,"text":"get open quote flag"},{"address":42748,"text":"toggle it"},{"address":42750,"text":"save it back"},{"address":42752,"text":"increment index"},{"address":42753,"text":"line too long so just bail out and do a warm start"},{"address":42755,"text":"get next byte"},{"address":42757,"text":"if not [EOL] (go print character)\nwas [EOL]"},{"address":42759,"text":"else clear index"},{"address":42760,"text":"get next line pointer low byte"},{"address":42762,"text":"copy to X"},{"address":42763,"text":"increment index"},{"address":42764,"text":"get next line pointer high byte"},{"address":42766,"text":"set pointer to line low byte"},{"address":42768,"text":"set pointer to line high byte"},{"address":42770,"text":"go do next line if not [EOT]\nelse ..."},{"address":42772,"text":"do warm start"},{"address":42775,"text":"do uncrunch BASIC tokens"},{"address":42778,"text":"just go print it if not token byte\nelse was token byte so uncrunch it"},{"address":42780,"text":"compare with the token for PI. in this case the token\nis the same as the PI character so it just needs printing"},{"address":42782,"text":"just print it if so"},{"address":42784,"text":"test the open quote flag"},{"address":42786,"text":"just go print character if open quote set"},{"address":42788,"text":"else set carry for subtract"},{"address":42789,"text":"reduce token range to 1 to whatever"},{"address":42791,"text":"copy token # to X"},{"address":42792,"text":"save index for line"},{"address":42794,"text":"start from -1, adjust for pre increment"},{"address":42796,"text":"decrement token #"},{"address":42797,"text":"if now found go do printing"},{"address":42799,"text":"else increment index"},{"address":42800,"text":"get byte from keyword table"},{"address":42803,"text":"loop until keyword end marker"},{"address":42805,"text":"go test if this is required keyword, branch always\nfound keyword, it's the next one"},{"address":42807,"text":"increment keyword table index"},{"address":42808,"text":"get byte from table"},{"address":42811,"text":"go restore index, mask byte and print if\nbyte was end marker"},{"address":42813,"text":"else go print the character"},{"address":42816,"text":"go get next character, branch always"},{"address":42818,"text":"set FNX"},{"address":42820,"text":"set subscript/FNX flag"},{"address":42822,"text":"perform LET"},{"address":42825,"text":"search the stack for FOR or GOSUB activity"},{"address":42828,"text":"branch if FOR, this variable, not found\nFOR, this variable, was found so first we dump the old one"},{"address":42830,"text":"copy index"},{"address":42831,"text":"add FOR structure size-2"},{"address":42833,"text":"copy to index"},{"address":42834,"text":"set stack (dump FOR structure (-2 bytes))"},{"address":42835,"text":"pull return address"},{"address":42836,"text":"pull return address"},{"address":42837,"text":"we need 18d bytes !"},{"address":42839,"text":"check room on stack for 2*A bytes"},{"address":42842,"text":"scan for next BASIC statement ([:] or [EOL])"},{"address":42845,"text":"clear carry for add"},{"address":42846,"text":"copy index to A"},{"address":42847,"text":"add BASIC execute pointer low byte"},{"address":42849,"text":"push onto stack"},{"address":42850,"text":"get BASIC execute pointer high byte"},{"address":42852,"text":"add carry"},{"address":42854,"text":"push onto stack"},{"address":42855,"text":"get current line number high byte"},{"address":42857,"text":"push onto stack"},{"address":42858,"text":"get current line number low byte"},{"address":42860,"text":"push onto stack"},{"address":42861,"text":"set \"TO\" token"},{"address":42863,"text":"scan for CHR$(A), else do syntax error then warm start"},{"address":42866,"text":"check if source is numeric, else do type mismatch"},{"address":42869,"text":"evaluate expression and check is numeric, else do\ntype mismatch"},{"address":42872,"text":"get FAC1 sign (b7)"},{"address":42874,"text":"set all non sign bits"},{"address":42876,"text":"and FAC1 mantissa 1"},{"address":42878,"text":"save FAC1 mantissa 1"},{"address":42880,"text":"set return address low byte"},{"address":42882,"text":"set return address high byte"},{"address":42884,"text":"save return address low byte"},{"address":42886,"text":"save return address high byte"},{"address":42888,"text":"round FAC1 and put on stack, returns to next instruction"},{"address":42891,"text":"set 1 pointer low address, default step size"},{"address":42893,"text":"set 1 pointer high address"},{"address":42895,"text":"unpack memory (AY) into FAC1"},{"address":42898,"text":"scan memory"},{"address":42901,"text":"compare with STEP token"},{"address":42903,"text":"if not \"STEP\" continue\nwas step so ...."},{"address":42905,"text":"increment and scan memory"},{"address":42908,"text":"evaluate expression and check is numeric, else do\ntype mismatch"},{"address":42911,"text":"get FAC1 sign, return A = $FF -ve, A = $01 +ve"},{"address":42914,"text":"push sign, round FAC1 and put on stack"},{"address":42917,"text":"get FOR/NEXT variable pointer high byte"},{"address":42919,"text":"push on stack"},{"address":42920,"text":"get FOR/NEXT variable pointer low byte"},{"address":42922,"text":"push on stack"},{"address":42923,"text":"get FOR token"},{"address":42925,"text":"push on stack"},{"address":42926,"text":"do CRTL-C check vector"},{"address":42929,"text":"get the BASIC execute pointer low byte"},{"address":42931,"text":"get the BASIC execute pointer high byte"},{"address":42933,"text":"compare the high byte with $02xx"},{"address":42935,"text":"unused byte"},{"address":42936,"text":"if immediate mode skip the continue pointer save"},{"address":42938,"text":"save the continue pointer low byte"},{"address":42940,"text":"save the continue pointer high byte"},{"address":42942,"text":"clear the index"},{"address":42944,"text":"get a BASIC byte"},{"address":42946,"text":"if not [EOL] go test for \":\""},{"address":42948,"text":"else set the index"},{"address":42950,"text":"get next line pointer high byte"},{"address":42952,"text":"clear carry for no \"BREAK\" message"},{"address":42953,"text":"branch if not end of program"},{"address":42955,"text":"else go to immediate mode,was immediate or [EOT] marker"},{"address":42958,"text":"increment index"},{"address":42959,"text":"get line number low byte"},{"address":42961,"text":"save current line number low byte"},{"address":42963,"text":"increment index"},{"address":42964,"text":"get line # high byte"},{"address":42966,"text":"save current line number high byte"},{"address":42968,"text":"A now = 4"},{"address":42969,"text":"add BASIC execute pointer low byte, now points to code"},{"address":42971,"text":"save BASIC execute pointer low byte"},{"address":42973,"text":"branch if no overflow"},{"address":42975,"text":"else increment BASIC execute pointer high byte"},{"address":42977,"text":"do start new BASIC code"},{"address":42980,"text":"increment and scan memory"},{"address":42983,"text":"go interpret BASIC code from BASIC execute pointer"},{"address":42986,"text":"loop"},{"address":42989,"text":"if the first byte is null just exit"},{"address":42991,"text":"normalise the token"},{"address":42993,"text":"if wasn't token go do LET"},{"address":42995,"text":"compare with token for TAB(-$80"},{"address":42997,"text":"branch if \u003e= TAB("},{"address":42999,"text":"*2 bytes per vector"},{"address":43000,"text":"copy to index"},{"address":43001,"text":"get vector high byte"},{"address":43004,"text":"push on stack"},{"address":43005,"text":"get vector low byte"},{"address":43008,"text":"push on stack"},{"address":43009,"text":"increment and scan memory and return. the return in\nthis case calls the command code, the return from\nthat will eventually return to the interpreter inner\nloop above"},{"address":43012,"text":"perform LET\nwas not [EOL]"},{"address":43015,"text":"comapre with \":\""},{"address":43017,"text":"if \":\" go execute new code\nelse ..."},{"address":43019,"text":"do syntax error then warm start\ntoken was \u003e= TAB("},{"address":43022,"text":"compare with the token for GO"},{"address":43024,"text":"if not \"GO\" do syntax error then warm start\nelse was \"GO\""},{"address":43026,"text":"increment and scan memory"},{"address":43029,"text":"set \"TO\" token"},{"address":43031,"text":"scan for CHR$(A), else do syntax error then warm start"},{"address":43034,"text":"perform GOTO"},{"address":43037,"text":"set carry for subtract"},{"address":43038,"text":"get start of memory low byte"},{"address":43040,"text":"-1"},{"address":43042,"text":"get start of memory high byte"},{"address":43044,"text":"branch if no rollunder"},{"address":43046,"text":"else decrement high byte"},{"address":43047,"text":"set DATA pointer low byte"},{"address":43049,"text":"set DATA pointer high byte"},{"address":43052,"text":"scan stop key"},{"address":43055,"text":"if carry set do BREAK instead of just END"},{"address":43057,"text":"clear carry"},{"address":43058,"text":"return if wasn't CTRL-C"},{"address":43060,"text":"get BASIC execute pointer low byte"},{"address":43062,"text":"get BASIC execute pointer high byte"},{"address":43064,"text":"get current line number high byte"},{"address":43066,"text":"increment it"},{"address":43067,"text":"branch if was immediate mode"},{"address":43069,"text":"save continue pointer low byte"},{"address":43071,"text":"save continue pointer high byte"},{"address":43073,"text":"get current line number low byte"},{"address":43075,"text":"get current line number high byte"},{"address":43077,"text":"save break line number low byte"},{"address":43079,"text":"save break line number high byte"},{"address":43081,"text":"dump return address low byte"},{"address":43082,"text":"dump return address high byte"},{"address":43083,"text":"set [CR][LF]\"BREAK\" pointer low byte"},{"address":43085,"text":"set [CR][LF]\"BREAK\" pointer high byte"},{"address":43087,"text":"if was program end skip the print string"},{"address":43089,"text":"print string and do warm start"},{"address":43092,"text":"do warm start"},{"address":43095,"text":"exit if following byte to allow syntax error"},{"address":43097,"text":"error code $1A, can't continue error"},{"address":43099,"text":"get continue pointer high byte"},{"address":43101,"text":"go do continue if we can"},{"address":43103,"text":"else do error #X then warm start\nwe can continue so ..."},{"address":43106,"text":"get continue pointer low byte"},{"address":43108,"text":"save BASIC execute pointer low byte"},{"address":43110,"text":"save BASIC execute pointer high byte"},{"address":43112,"text":"get break line low byte"},{"address":43114,"text":"get break line high byte"},{"address":43116,"text":"set current line number low byte"},{"address":43118,"text":"set current line number high byte"},{"address":43121,"text":"save status"},{"address":43122,"text":"no control or kernal messages"},{"address":43124,"text":"control kernal messages"},{"address":43127,"text":"restore status"},{"address":43128,"text":"branch if RUN n"},{"address":43130,"text":"reset execution to start, clear variables, flush stack\nand return"},{"address":43133,"text":"go do \"CLEAR\""},{"address":43136,"text":"get n and do GOTO n"},{"address":43139,"text":"need 6 bytes for GOSUB"},{"address":43141,"text":"check room on stack for 2*A bytes"},{"address":43144,"text":"get BASIC execute pointer high byte"},{"address":43146,"text":"save it"},{"address":43147,"text":"get BASIC execute pointer low byte"},{"address":43149,"text":"save it"},{"address":43150,"text":"get current line number high byte"},{"address":43152,"text":"save it"},{"address":43153,"text":"get current line number low byte"},{"address":43155,"text":"save it"},{"address":43156,"text":"token for GOSUB"},{"address":43158,"text":"save it"},{"address":43159,"text":"scan memory"},{"address":43162,"text":"perform GOTO"},{"address":43165,"text":"go do interpreter inner loop"},{"address":43168,"text":"get fixed-point number into temporary integer"},{"address":43171,"text":"scan for next BASIC line"},{"address":43174,"text":"set carry for subtract"},{"address":43175,"text":"get current line number low byte"},{"address":43177,"text":"subtract temporary integer low byte"},{"address":43179,"text":"get current line number high byte"},{"address":43181,"text":"subtract temporary integer high byte"},{"address":43183,"text":"if current line number \u003e= temporary integer, go search\nfrom the start of memory"},{"address":43185,"text":"else copy line index to A"},{"address":43186,"text":"set carry (+1)"},{"address":43187,"text":"add BASIC execute pointer low byte"},{"address":43189,"text":"get BASIC execute pointer high byte"},{"address":43191,"text":"branch if no overflow to high byte"},{"address":43193,"text":"increment high byte"},{"address":43194,"text":"branch always (can never be carry)"},{"address":43196,"text":"get start of memory low byte"},{"address":43198,"text":"get start of memory high byte"},{"address":43200,"text":"search Basic for temp integer line number from AX"},{"address":43203,"text":"if carry clear go do unsdefined statement error\ncarry all ready set for subtract"},{"address":43205,"text":"get pointer low byte"},{"address":43207,"text":"-1"},{"address":43209,"text":"save BASIC execute pointer low byte"},{"address":43211,"text":"get pointer high byte"},{"address":43213,"text":"subtract carry"},{"address":43215,"text":"save BASIC execute pointer high byte"},{"address":43218,"text":"exit if following token to allow syntax error"},{"address":43220,"text":"set byte so no match possible"},{"address":43222,"text":"save FOR/NEXT variable pointer high byte"},{"address":43224,"text":"search the stack for FOR or GOSUB activity,\nget token off stack"},{"address":43227,"text":"correct the stack"},{"address":43228,"text":"compare with GOSUB token"},{"address":43230,"text":"if matching GOSUB go continue RETURN"},{"address":43232,"text":"else error code $04, return without gosub error"},{"address":43235,"text":"error code $11, undefined statement error"},{"address":43237,"text":"do error #X then warm start"},{"address":43240,"text":"do syntax error then warm start\nwas matching GOSUB token"},{"address":43243,"text":"dump token byte"},{"address":43244,"text":"pull return line low byte"},{"address":43245,"text":"save current line number low byte"},{"address":43247,"text":"pull return line high byte"},{"address":43248,"text":"save current line number high byte"},{"address":43250,"text":"pull return address low byte"},{"address":43251,"text":"save BASIC execute pointer low byte"},{"address":43253,"text":"pull return address high byte"},{"address":43254,"text":"save BASIC execute pointer high byte"},{"address":43256,"text":"scan for next BASIC statement ([:] or [EOL])"},{"address":43259,"text":"copy index to A"},{"address":43260,"text":"clear carry for add"},{"address":43261,"text":"add BASIC execute pointer low byte"},{"address":43263,"text":"save BASIC execute pointer low byte"},{"address":43265,"text":"skip increment if no carry"},{"address":43267,"text":"else increment BASIC execute pointer high byte"},{"address":43270,"text":"set look for character = \":\""},{"address":43273,"text":"set alternate search character = [EOL]"},{"address":43275,"text":"store alternate search character"},{"address":43277,"text":"set search character = [EOL]"},{"address":43279,"text":"save the search character"},{"address":43281,"text":"get search character"},{"address":43283,"text":"get alternate search character"},{"address":43285,"text":"make search character = alternate search character"},{"address":43287,"text":"make alternate search character = search character"},{"address":43289,"text":"get BASIC byte"},{"address":43291,"text":"exit if null [EOL]"},{"address":43293,"text":"compare with search character"},{"address":43295,"text":"exit if found"},{"address":43297,"text":"else increment index"},{"address":43298,"text":"compare current character with open quote"},{"address":43300,"text":"if found go swap search character for alternate search\ncharacter"},{"address":43302,"text":"loop for next character, branch always"},{"address":43304,"text":"evaluate expression"},{"address":43307,"text":"scan memory"},{"address":43310,"text":"compare with \"GOTO\" token"},{"address":43312,"text":"if it was  the token for GOTO go do IF ... GOTO\nwasn't IF ... GOTO so must be IF ... THEN"},{"address":43314,"text":"set \"THEN\" token"},{"address":43316,"text":"scan for CHR$(A), else do syntax error then warm start"},{"address":43319,"text":"get FAC1 exponent"},{"address":43321,"text":"if result was non zero continue execution\nelse REM rest of line"},{"address":43323,"text":"scan for next BASIC line"},{"address":43326,"text":"add Y to the BASIC execute pointer and return, branch\nalways\nresult was non zero so do rest of line"},{"address":43328,"text":"scan memory"},{"address":43331,"text":"branch if not numeric character, is variable or keyword"},{"address":43333,"text":"else perform GOTO n\nis variable or keyword"},{"address":43336,"text":"interpret BASIC code from BASIC execute pointer"},{"address":43339,"text":"get byte parameter"},{"address":43342,"text":"push next character"},{"address":43343,"text":"compare with GOSUB token"},{"address":43345,"text":"if GOSUB go see if it should be executed"},{"address":43347,"text":"compare with GOTO token"},{"address":43349,"text":"if not GOTO do syntax error then warm start\nnext character was GOTO or GOSUB, see if it should be executed"},{"address":43351,"text":"decrement the byte value"},{"address":43353,"text":"if not zero go see if another line number exists"},{"address":43355,"text":"pull keyword token"},{"address":43356,"text":"go execute it"},{"address":43359,"text":"increment and scan memory"},{"address":43362,"text":"get fixed-point number into temporary integer\nskip this n"},{"address":43365,"text":"compare next character with \",\""},{"address":43367,"text":"loop if \",\""},{"address":43369,"text":"else pull keyword token, ran out of options"},{"address":43371,"text":"clear X"},{"address":43373,"text":"clear temporary integer low byte"},{"address":43375,"text":"clear temporary integer high byte"},{"address":43377,"text":"return if carry set, end of scan, character was not 0-9"},{"address":43379,"text":"subtract $30, $2F+carry, from byte"},{"address":43381,"text":"store #"},{"address":43383,"text":"get temporary integer high byte"},{"address":43385,"text":"save it for now"},{"address":43387,"text":"compare with $19"},{"address":43389,"text":"branch if \u003e= this makes the maximum line number 63999\nbecause the next bit does $1900 * $0A = $FA00 = 64000\ndecimal. the branch target is really the SYNTAX error\nat $A8E8 but that is too far so an intermediate\ncompare and branch to that location is used. the problem\nwith this is that line number that gives a partial result\nfrom $8900 to $89FF, 35072x to 35327x, will pass the new\ntarget compare and will try to execute the remainder of\nthe ON n GOTO/GOSUB. a solution to this is to copy the\nbyte in A before the branch to X and then branch to\n$A955 skipping the second compare"},{"address":43391,"text":"get temporary integer low byte"},{"address":43393,"text":"*2 low byte"},{"address":43394,"text":"*2 high byte"},{"address":43396,"text":"*2 low byte"},{"address":43397,"text":"*2 high byte (*4)"},{"address":43399,"text":"+ low byte (*5)"},{"address":43401,"text":"save it"},{"address":43403,"text":"get high byte temp"},{"address":43405,"text":"+ high byte (*5)"},{"address":43407,"text":"save it"},{"address":43409,"text":"*2 low byte (*10d)"},{"address":43411,"text":"*2 high byte (*10d)"},{"address":43413,"text":"get low byte"},{"address":43415,"text":"add #"},{"address":43417,"text":"save low byte"},{"address":43419,"text":"branch if no overflow to high byte"},{"address":43421,"text":"else increment high byte"},{"address":43423,"text":"increment and scan memory"},{"address":43426,"text":"loop for next character"},{"address":43429,"text":"get variable address"},{"address":43432,"text":"save variable address low byte"},{"address":43434,"text":"save variable address high byte"},{"address":43436,"text":"$B2 is \"=\" token"},{"address":43438,"text":"scan for CHR$(A), else do syntax error then warm start"},{"address":43441,"text":"get data type flag, $80 = integer, $00 = float"},{"address":43443,"text":"push data type flag"},{"address":43444,"text":"get data type flag, $FF = string, $00 = numeric"},{"address":43446,"text":"push data type flag"},{"address":43447,"text":"evaluate expression"},{"address":43450,"text":"pop data type flag"},{"address":43451,"text":"string bit into carry"},{"address":43452,"text":"do type match check"},{"address":43455,"text":"branch if string"},{"address":43457,"text":"pop integer/float data type flag\nassign value to numeric variable"},{"address":43458,"text":"branch if float\nexpression is numeric integer"},{"address":43460,"text":"round FAC1"},{"address":43463,"text":"evaluate integer expression, no sign check"},{"address":43466,"text":"clear index"},{"address":43468,"text":"get FAC1 mantissa 3"},{"address":43470,"text":"save as integer variable low byte"},{"address":43472,"text":"increment index"},{"address":43473,"text":"get FAC1 mantissa 4"},{"address":43475,"text":"save as integer variable high byte"},{"address":43478,"text":"pack FAC1 into variable pointer and return\nassign value to numeric variable"},{"address":43481,"text":"dump integer/float data type flag"},{"address":43482,"text":"get variable pointer high byte"},{"address":43484,"text":"was it TI$ pointer"},{"address":43486,"text":"branch if not\nelse it's TI$ = \u003cexpr$\u003e"},{"address":43488,"text":"pop string off descriptor stack, or from top of string\nspace returns with A = length, X = pointer low byte,\nY = pointer high byte"},{"address":43491,"text":"compare length with 6"},{"address":43493,"text":"if length not 6 do illegal quantity error then warm start"},{"address":43495,"text":"clear index"},{"address":43497,"text":"clear FAC1 exponent"},{"address":43499,"text":"clear FAC1 sign (b7)"},{"address":43501,"text":"save index"},{"address":43503,"text":"check and evaluate numeric digit"},{"address":43506,"text":"multiply FAC1 by 10"},{"address":43509,"text":"increment index"},{"address":43511,"text":"restore index"},{"address":43513,"text":"check and evaluate numeric digit"},{"address":43516,"text":"round and copy FAC1 to FAC2"},{"address":43519,"text":"copy FAC1 exponent"},{"address":43520,"text":"branch if FAC1 zero"},{"address":43522,"text":"increment index, * 2"},{"address":43523,"text":"copy back to A"},{"address":43524,"text":"FAC1 = (FAC1 + (FAC2 * 2)) * 2 = FAC1 * 6"},{"address":43527,"text":"get index"},{"address":43529,"text":"increment index"},{"address":43530,"text":"compare index with 6"},{"address":43532,"text":"loop if not 6"},{"address":43534,"text":"multiply FAC1 by 10"},{"address":43537,"text":"convert FAC1 floating to fixed"},{"address":43540,"text":"get FAC1 mantissa 3"},{"address":43542,"text":"get FAC1 mantissa 2"},{"address":43544,"text":"get FAC1 mantissa 4"},{"address":43546,"text":"set real time clock and return"},{"address":43549,"text":"get byte from string"},{"address":43551,"text":"clear Cb if numeric. this call should be to $84\nas the code from $80 first comapres the byte with\n[SPACE] and does a BASIC increment and get if it is"},{"address":43554,"text":"branch if numeric"},{"address":43556,"text":"do illegal quantity error then warm start"},{"address":43559,"text":"subtract $2F + carry to convert ASCII to binary"},{"address":43561,"text":"evaluate new ASCII digit and return"},{"address":43564,"text":"index to string pointer high byte"},{"address":43566,"text":"get string pointer high byte"},{"address":43568,"text":"compare with bottom of string space high byte"},{"address":43570,"text":"branch if string pointer high byte is less than bottom\nof string space high byte"},{"address":43572,"text":"branch if string pointer high byte is greater than\nbottom of string space high byte\nelse high bytes were equal"},{"address":43574,"text":"decrement index to string pointer low byte"},{"address":43575,"text":"get string pointer low byte"},{"address":43577,"text":"compare with bottom of string space low byte"},{"address":43579,"text":"branch if string pointer low byte is less than bottom\nof string space low byte"},{"address":43581,"text":"get descriptor pointer high byte"},{"address":43583,"text":"compare with start of variables high byte"},{"address":43585,"text":"branch if less, is on string stack"},{"address":43587,"text":"if greater make space and copy string\nelse high bytes were equal"},{"address":43589,"text":"get descriptor pointer low byte"},{"address":43591,"text":"compare with start of variables low byte"},{"address":43593,"text":"if greater or equal make space and copy string"},{"address":43595,"text":"get descriptor pointer low byte"},{"address":43597,"text":"get descriptor pointer high byte"},{"address":43599,"text":"go copy descriptor to variable"},{"address":43602,"text":"clear index"},{"address":43604,"text":"get string length"},{"address":43606,"text":"copy descriptor pointer and make string space A bytes long"},{"address":43609,"text":"copy old descriptor pointer low byte"},{"address":43611,"text":"copy old descriptor pointer high byte"},{"address":43613,"text":"save old descriptor pointer low byte"},{"address":43615,"text":"save old descriptor pointer high byte"},{"address":43617,"text":"copy string from descriptor to utility pointer"},{"address":43620,"text":"get descriptor pointer low byte"},{"address":43622,"text":"get descriptor pointer high byte"},{"address":43624,"text":"save descriptor pointer low byte"},{"address":43626,"text":"save descriptor pointer high byte"},{"address":43628,"text":"clean descriptor stack, YA = pointer"},{"address":43631,"text":"clear index"},{"address":43633,"text":"get string length from new descriptor"},{"address":43635,"text":"copy string length to variable"},{"address":43637,"text":"increment index"},{"address":43638,"text":"get string pointer low byte from new descriptor"},{"address":43640,"text":"copy string pointer low byte to variable"},{"address":43642,"text":"increment index"},{"address":43643,"text":"get string pointer high byte from new descriptor"},{"address":43645,"text":"copy string pointer high byte to variable"},{"address":43648,"text":"perform CMD"},{"address":43651,"text":"close input and output channels and return"},{"address":43654,"text":"get byte parameter"},{"address":43657,"text":"branch if following byte is \":\" or [EOT]"},{"address":43659,"text":"set \",\""},{"address":43661,"text":"scan for CHR$(A), else do syntax error then warm start"},{"address":43664,"text":"save status"},{"address":43665,"text":"set current I/O channel"},{"address":43667,"text":"open channel for output with error check"},{"address":43670,"text":"restore status"},{"address":43671,"text":"perform PRINT"},{"address":43674,"text":"print string from utility pointer"},{"address":43677,"text":"scan memory"},{"address":43680,"text":"if nothing following just print CR/LF"},{"address":43682,"text":"exit if nothing following, end of PRINT branch"},{"address":43684,"text":"compare with token for TAB("},{"address":43686,"text":"if TAB( go handle it"},{"address":43688,"text":"compare with token for SPC("},{"address":43690,"text":"flag SPC("},{"address":43691,"text":"if SPC( go handle it"},{"address":43693,"text":"compare with \",\""},{"address":43695,"text":"if \",\" go skip to the next TAB position"},{"address":43697,"text":"compare with \";\""},{"address":43699,"text":"if \";\" go continue the print loop"},{"address":43701,"text":"evaluate expression"},{"address":43704,"text":"test data type flag, $FF = string, $00 = numeric"},{"address":43706,"text":"if string go print string, scan memory and continue PRINT"},{"address":43708,"text":"convert FAC1 to ASCII string result in (AY)"},{"address":43711,"text":"print \" terminated string to utility pointer"},{"address":43714,"text":"print string from utility pointer"},{"address":43717,"text":"print [SPACE] or [CURSOR RIGHT]"},{"address":43720,"text":"go scan memory and continue PRINT, branch always"},{"address":43722,"text":"clear A"},{"address":43724,"text":"clear first byte of input buffer"},{"address":43727,"text":"$0200 - 1 low byte"},{"address":43729,"text":"$0200 - 1 high byte"},{"address":43731,"text":"get current I/O channel"},{"address":43733,"text":"exit if not default channel"},{"address":43735,"text":"set [CR]"},{"address":43737,"text":"print the character"},{"address":43740,"text":"test current I/O channel"},{"address":43742,"text":"if ?? toggle A, EOR #$FF and return"},{"address":43744,"text":"set [LF]"},{"address":43746,"text":"print the character\ntoggle A"},{"address":43749,"text":"invert A"},{"address":43752,"text":"set Cb for read cursor position"},{"address":43753,"text":"read/set X,Y cursor position"},{"address":43756,"text":"copy cursor Y"},{"address":43757,"text":"set carry for subtract"},{"address":43758,"text":"subtract one TAB length"},{"address":43760,"text":"loop if result was +ve"},{"address":43762,"text":"complement it"},{"address":43764,"text":"+1, twos complement"},{"address":43766,"text":"always print A spaces, result is never $00"},{"address":43768,"text":"save TAB( or SPC( status"},{"address":43769,"text":"set Cb for read cursor position"},{"address":43770,"text":"read/set X,Y cursor position"},{"address":43773,"text":"save current cursor position"},{"address":43775,"text":"scan and get byte parameter"},{"address":43778,"text":"compare with \")\""},{"address":43780,"text":"if not \")\" do syntax error"},{"address":43782,"text":"restore TAB( or SPC( status"},{"address":43783,"text":"branch if was SPC(\nelse was TAB("},{"address":43785,"text":"copy TAB() byte to A"},{"address":43786,"text":"subtract current cursor position"},{"address":43788,"text":"go loop for next if already past requited position"},{"address":43790,"text":"copy [SPACE] count to X"},{"address":43791,"text":"increment count"},{"address":43792,"text":"decrement count"},{"address":43793,"text":"branch if count was not zero\nwas \";\" or [SPACES] printed"},{"address":43795,"text":"increment and scan memory"},{"address":43798,"text":"continue print loop"},{"address":43801,"text":"print [SPACE] or [CURSOR RIGHT]"},{"address":43804,"text":"loop, branch always"},{"address":43806,"text":"print \" terminated string to utility pointer"},{"address":43809,"text":"pop string off descriptor stack, or from top of string\nspace returns with A = length, X = pointer low byte,\nY = pointer high byte"},{"address":43812,"text":"copy length"},{"address":43813,"text":"clear index"},{"address":43815,"text":"increment length, for pre decrement loop"},{"address":43816,"text":"decrement length"},{"address":43817,"text":"exit if done"},{"address":43819,"text":"get byte from string"},{"address":43821,"text":"print the character"},{"address":43824,"text":"increment index"},{"address":43825,"text":"compare byte with [CR]"},{"address":43827,"text":"loop if not [CR]"},{"address":43829,"text":"toggle A, EOR #$FF. what is the point of this ??"},{"address":43832,"text":"loop"},{"address":43835,"text":"get current I/O channel"},{"address":43837,"text":"if default channel go output [CURSOR RIGHT]"},{"address":43839,"text":"else output [SPACE]"},{"address":43842,"text":"set [CURSOR RIGHT]"},{"address":43845,"text":"set \"?\""},{"address":43847,"text":"output character to channel with error check"},{"address":43850,"text":"set the flags on A"},{"address":43853,"text":"get INPUT mode flag, $00 = INPUT, $40 = GET, $98 = READ"},{"address":43855,"text":"branch if INPUT"},{"address":43857,"text":"branch if READ\nelse was GET"},{"address":43859,"text":"set current line high byte to -1, indicate immediate mode"},{"address":43861,"text":"branch always"},{"address":43863,"text":"get current DATA line number low byte"},{"address":43865,"text":"get current DATA line number high byte"},{"address":43867,"text":"set current line number low byte"},{"address":43869,"text":"set current line number high byte"},{"address":43871,"text":"do syntax error then warm start\nwas INPUT"},{"address":43874,"text":"get current I/O channel"},{"address":43876,"text":"branch if default channel"},{"address":43878,"text":"else error $18, file data error"},{"address":43880,"text":"do error #X then warm start"},{"address":43883,"text":"set \"?REDO FROM START\" pointer low byte"},{"address":43885,"text":"set \"?REDO FROM START\" pointer high byte"},{"address":43887,"text":"print null terminated string"},{"address":43890,"text":"get continue pointer low byte"},{"address":43892,"text":"get continue pointer high byte"},{"address":43894,"text":"save BASIC execute pointer low byte"},{"address":43896,"text":"save BASIC execute pointer high byte"},{"address":43899,"text":"check not Direct, back here if ok"},{"address":43902,"text":"compare with \"#\""},{"address":43904,"text":"branch if not GET#"},{"address":43906,"text":"increment and scan memory"},{"address":43909,"text":"get byte parameter"},{"address":43912,"text":"set \",\""},{"address":43914,"text":"scan for CHR$(A), else do syntax error then warm start"},{"address":43917,"text":"set current I/O channel"},{"address":43919,"text":"open channel for input with error check"},{"address":43922,"text":"set pointer low byte"},{"address":43924,"text":"set pointer high byte"},{"address":43926,"text":"clear A"},{"address":43928,"text":"ensure null terminator"},{"address":43931,"text":"input mode = GET"},{"address":43933,"text":"perform the GET part of READ"},{"address":43936,"text":"get current I/O channel"},{"address":43938,"text":"if not default channel go do channel close and return"},{"address":43941,"text":"get byte parameter"},{"address":43944,"text":"set \",\""},{"address":43946,"text":"scan for CHR$(A), else do syntax error then warm start"},{"address":43949,"text":"set current I/O channel"},{"address":43951,"text":"open channel for input with error check"},{"address":43954,"text":"perform INPUT with no prompt string"},{"address":43957,"text":"get current I/O channel"},{"address":43959,"text":"close input and output channels"},{"address":43962,"text":"clear X"},{"address":43964,"text":"clear current I/O channel, flag default"},{"address":43967,"text":"compare next byte with open quote"},{"address":43969,"text":"if no prompt string just do INPUT"},{"address":43971,"text":"print \"...\" string"},{"address":43974,"text":"load A with \";\""},{"address":43976,"text":"scan for CHR$(A), else do syntax error then warm start"},{"address":43979,"text":"print string from utility pointer\ndone with prompt, now get data"},{"address":43982,"text":"check not Direct, back here if ok"},{"address":43985,"text":"set \",\""},{"address":43987,"text":"save to start of buffer - 1"},{"address":43990,"text":"print \"? \" and get BASIC input"},{"address":43993,"text":"get current I/O channel"},{"address":43995,"text":"branch if default I/O channel"},{"address":43997,"text":"read I/O status word"},{"address":44000,"text":"mask no DSR/timeout"},{"address":44002,"text":"branch if not error"},{"address":44004,"text":"close input and output channels"},{"address":44007,"text":"perform DATA"},{"address":44010,"text":"get first byte in input buffer"},{"address":44013,"text":"branch if not null\nelse .."},{"address":44015,"text":"get current I/O channel"},{"address":44017,"text":"if not default channel go get BASIC input"},{"address":44019,"text":"scan for next BASIC statement ([:] or [EOL])"},{"address":44022,"text":"add Y to the BASIC execute pointer and return"},{"address":44025,"text":"get current I/O channel"},{"address":44027,"text":"skip \"?\" prompt if not default channel"},{"address":44029,"text":"print \"?\""},{"address":44032,"text":"print [SPACE] or [CURSOR RIGHT]"},{"address":44035,"text":"call for BASIC input and return"},{"address":44038,"text":"get DATA pointer low byte"},{"address":44040,"text":"get DATA pointer high byte"},{"address":44042,"text":"set input mode = READ"},{"address":44045,"text":"set input mode = INPUT"},{"address":44047,"text":"set input mode flag, $00 = INPUT, $40 = GET, $98 = READ"},{"address":44049,"text":"save READ pointer low byte"},{"address":44051,"text":"save READ pointer high byte\nREAD, GET or INPUT next variable from list"},{"address":44053,"text":"get variable address"},{"address":44056,"text":"save address low byte"},{"address":44058,"text":"save address high byte"},{"address":44060,"text":"get BASIC execute pointer low byte"},{"address":44062,"text":"get BASIC execute pointer high byte"},{"address":44064,"text":"save BASIC execute pointer low byte"},{"address":44066,"text":"save BASIC execute pointer high byte"},{"address":44068,"text":"get READ pointer low byte"},{"address":44070,"text":"get READ pointer high byte"},{"address":44072,"text":"save as BASIC execute pointer low byte"},{"address":44074,"text":"save as BASIC execute pointer high byte"},{"address":44076,"text":"scan memory"},{"address":44079,"text":"branch if not null\npointer was to null entry"},{"address":44081,"text":"test input mode flag, $00 = INPUT, $40 = GET, $98 = READ"},{"address":44083,"text":"branch if not GET\nelse was GET"},{"address":44085,"text":"get character from input device with error check"},{"address":44088,"text":"save to buffer"},{"address":44091,"text":"set pointer low byte"},{"address":44093,"text":"set pointer high byte"},{"address":44095,"text":"go interpret single character"},{"address":44097,"text":"branch if READ\nelse was INPUT"},{"address":44099,"text":"get current I/O channel"},{"address":44101,"text":"skip \"?\" prompt if not default channel"},{"address":44103,"text":"print \"?\""},{"address":44106,"text":"print \"? \" and get BASIC input"},{"address":44109,"text":"save BASIC execute pointer low byte"},{"address":44111,"text":"save BASIC execute pointer high byte"},{"address":44113,"text":"increment and scan memory, execute pointer now points to\nstart of next data or null terminator"},{"address":44116,"text":"test data type flag, $FF = string, $00 = numeric"},{"address":44118,"text":"branch if numeric\ntype is string"},{"address":44120,"text":"test INPUT mode flag, $00 = INPUT, $40 = GET, $98 = READ"},{"address":44122,"text":"branch if not GET\nelse do string GET"},{"address":44124,"text":"clear X ??"},{"address":44125,"text":"save BASIC execute pointer low byte"},{"address":44127,"text":"clear A"},{"address":44129,"text":"clear search character"},{"address":44131,"text":"branch always\nis string INPUT or string READ"},{"address":44133,"text":"save search character"},{"address":44135,"text":"compare with \""},{"address":44137,"text":"branch if quote\nstring is not in quotes so \":\", \",\" or $00 are the\ntermination characters"},{"address":44139,"text":"set \":\""},{"address":44141,"text":"set search character"},{"address":44143,"text":"set \",\""},{"address":44145,"text":"clear carry for add"},{"address":44146,"text":"set scan quotes flag"},{"address":44148,"text":"get BASIC execute pointer low byte"},{"address":44150,"text":"get BASIC execute pointer high byte"},{"address":44152,"text":"add to pointer low byte. this add increments the pointer\nif the mode is INPUT or READ and the data is a \"...\"\nstring"},{"address":44154,"text":"branch if no rollover"},{"address":44156,"text":"else increment pointer high byte"},{"address":44157,"text":"print string to utility pointer"},{"address":44160,"text":"restore BASIC execute pointer from temp"},{"address":44163,"text":"perform string LET"},{"address":44166,"text":"continue processing command\nGET, INPUT or READ is numeric"},{"address":44169,"text":"get FAC1 from string"},{"address":44172,"text":"get data type flag, $80 = integer, $00 = float"},{"address":44174,"text":"assign value to numeric variable"},{"address":44177,"text":"scan memory"},{"address":44180,"text":"branch if \":\" or [EOL]"},{"address":44182,"text":"comparte with \",\""},{"address":44184,"text":"branch if \",\""},{"address":44186,"text":"else go do bad input routine\nstring terminated with \":\", \",\" or $00"},{"address":44189,"text":"get BASIC execute pointer low byte"},{"address":44191,"text":"get BASIC execute pointer high byte"},{"address":44193,"text":"save READ pointer low byte"},{"address":44195,"text":"save READ pointer high byte"},{"address":44197,"text":"get saved BASIC execute pointer low byte"},{"address":44199,"text":"get saved BASIC execute pointer high byte"},{"address":44201,"text":"restore BASIC execute pointer low byte"},{"address":44203,"text":"restore BASIC execute pointer high byte"},{"address":44205,"text":"scan memory"},{"address":44208,"text":"branch if \":\" or [EOL]"},{"address":44210,"text":"scan for \",\", else do syntax error then warm start"},{"address":44213,"text":"go READ or INPUT next variable from list\nwas READ"},{"address":44216,"text":"scan for next BASIC statement ([:] or [EOL])"},{"address":44219,"text":"increment index to next byte"},{"address":44220,"text":"copy byte to X"},{"address":44221,"text":"branch if \":\""},{"address":44223,"text":"else set error $0D, out of data error"},{"address":44225,"text":"increment index to next line pointer high byte"},{"address":44226,"text":"get next line pointer high byte"},{"address":44228,"text":"branch if program end, eventually does error X"},{"address":44230,"text":"increment index"},{"address":44231,"text":"get next line # low byte"},{"address":44233,"text":"save current DATA line low byte"},{"address":44235,"text":"increment index"},{"address":44236,"text":"get next line # high byte"},{"address":44238,"text":"increment index"},{"address":44239,"text":"save current DATA line high byte"},{"address":44241,"text":"add Y to the BASIC execute pointer"},{"address":44244,"text":"scan memory"},{"address":44247,"text":"copy the byte"},{"address":44248,"text":"compare it with token for DATA"},{"address":44250,"text":"loop if not DATA"},{"address":44252,"text":"continue evaluating READ"},{"address":44255,"text":"get READ pointer low byte"},{"address":44257,"text":"get READ pointer high byte"},{"address":44259,"text":"get INPUT mode flag, $00 = INPUT, $40 = GET, $98 = READ"},{"address":44261,"text":"branch if INPUT or GET"},{"address":44263,"text":"else set data pointer and exit"},{"address":44266,"text":"clear index"},{"address":44268,"text":"get READ byte"},{"address":44270,"text":"exit if [EOL]"},{"address":44272,"text":"get current I/O channel"},{"address":44274,"text":"exit if not default channel"},{"address":44276,"text":"set \"?EXTRA IGNORED\" pointer low byte"},{"address":44278,"text":"set \"?EXTRA IGNORED\" pointer high byte"},{"address":44280,"text":"print null terminated string"},{"address":44318,"text":"branch if NEXT variable"},{"address":44320,"text":"else clear Y"},{"address":44322,"text":"branch always\nNEXT variable"},{"address":44324,"text":"get variable address"},{"address":44327,"text":"save FOR/NEXT variable pointer low byte"},{"address":44329,"text":"save FOR/NEXT variable pointer high byte\n(high byte cleared if no variable defined)"},{"address":44331,"text":"search the stack for FOR or GOSUB activity"},{"address":44334,"text":"branch if FOR, this variable, found"},{"address":44336,"text":"else set error $0A, next without for error"},{"address":44338,"text":"do error #X then warm start\nfound this FOR variable"},{"address":44341,"text":"update stack pointer"},{"address":44342,"text":"copy stack pointer"},{"address":44343,"text":"clear carry for add"},{"address":44344,"text":"point to STEP value"},{"address":44346,"text":"save it"},{"address":44347,"text":"point to TO value"},{"address":44349,"text":"save pointer to TO variable for compare"},{"address":44351,"text":"restore pointer to STEP value"},{"address":44352,"text":"point to stack page"},{"address":44354,"text":"unpack memory (AY) into FAC1"},{"address":44357,"text":"get stack pointer back"},{"address":44358,"text":"get step sign"},{"address":44361,"text":"save FAC1 sign (b7)"},{"address":44363,"text":"get FOR/NEXT variable pointer low byte"},{"address":44365,"text":"get FOR/NEXT variable pointer high byte"},{"address":44367,"text":"add FOR variable to FAC1"},{"address":44370,"text":"pack FAC1 into FOR variable"},{"address":44373,"text":"point to stack page"},{"address":44375,"text":"compare FAC1 with TO value"},{"address":44378,"text":"get stack pointer back"},{"address":44379,"text":"set carry for subtract"},{"address":44380,"text":"subtract step sign"},{"address":44383,"text":"branch if =, loop complete\nloop back and do it all again"},{"address":44385,"text":"get FOR line low byte"},{"address":44388,"text":"save current line number low byte"},{"address":44390,"text":"get FOR line high byte"},{"address":44393,"text":"save current line number high byte"},{"address":44395,"text":"get BASIC execute pointer low byte"},{"address":44398,"text":"save BASIC execute pointer low byte"},{"address":44400,"text":"get BASIC execute pointer high byte"},{"address":44403,"text":"save BASIC execute pointer high byte"},{"address":44405,"text":"go do interpreter inner loop\nNEXT loop comlete"},{"address":44408,"text":"stack copy to A"},{"address":44409,"text":"add $12, $11 + carry, to dump FOR structure"},{"address":44411,"text":"copy back to index"},{"address":44412,"text":"copy to stack pointer"},{"address":44413,"text":"scan memory"},{"address":44416,"text":"compare with \",\""},{"address":44418,"text":"if not \",\" go do interpreter inner loop\nwas \",\" so another NEXT variable to do"},{"address":44420,"text":"increment and scan memory"},{"address":44423,"text":"do NEXT variable"},{"address":44426,"text":"evaluate expression\ncheck if source and destination are numeric"},{"address":44431,"text":"destination is string\ntype match check, set C for string, clear C for numeric"},{"address":44432,"text":"test data type flag, $FF = string, $00 = numeric"},{"address":44434,"text":"branch if string"},{"address":44436,"text":"if destiantion is numeric do type missmatch error"},{"address":44439,"text":"exit if destination is string\ndo type missmatch error"},{"address":44441,"text":"error code $16, type missmatch error"},{"address":44443,"text":"do error #X then warm start"},{"address":44446,"text":"get BASIC execute pointer low byte"},{"address":44448,"text":"skip next if not zero"},{"address":44450,"text":"else decrement BASIC execute pointer high byte"},{"address":44452,"text":"decrement BASIC execute pointer low byte"},{"address":44454,"text":"set null precedence, flag done"},{"address":44457,"text":"push compare evaluation byte if branch to here"},{"address":44458,"text":"copy precedence byte"},{"address":44459,"text":"push precedence byte"},{"address":44460,"text":"2 bytes"},{"address":44462,"text":"check room on stack for A*2 bytes"},{"address":44465,"text":"get value from line"},{"address":44468,"text":"clear A"},{"address":44470,"text":"clear comparrison evaluation flag"},{"address":44472,"text":"scan memory"},{"address":44475,"text":"set carry for subtract"},{"address":44476,"text":"subtract the token for \"\u003e\""},{"address":44478,"text":"branch if \u003c \"\u003e\""},{"address":44480,"text":"compare with \"\u003e\" to +3"},{"address":44482,"text":"branch if \u003e= 3\nwas token for \"\u003e\" \"=\" or \"\u003c\""},{"address":44484,"text":"compare with token for ="},{"address":44486,"text":"*2, b0 = carry (=1 if token was = or \u003c)"},{"address":44487,"text":"toggle b0"},{"address":44489,"text":"EOR with comparrison evaluation flag"},{"address":44491,"text":"compare with comparrison evaluation flag"},{"address":44493,"text":"if \u003c saved flag do syntax error then warm start"},{"address":44495,"text":"save new comparrison evaluation flag"},{"address":44497,"text":"increment and scan memory"},{"address":44500,"text":"go do next character"},{"address":44503,"text":"get comparrison evaluation flag"},{"address":44505,"text":"branch if compare function"},{"address":44507,"text":"go do functions\nelse was \u003c TK_GT so is operator or lower"},{"address":44509,"text":"add # of operators (+, -, *, /, ^, AND or OR)"},{"address":44511,"text":"branch if \u003c + operator\ncarry was set so token was +, -, *, /, ^, AND or OR"},{"address":44513,"text":"add data type flag, $FF = string, $00 = numeric"},{"address":44515,"text":"branch if not string or not + token\nwill only be $00 if type is string and token was +"},{"address":44517,"text":"add strings, string 1 is in the descriptor, string 2\nis in line, and return"},{"address":44520,"text":"-1 (corrects for carry add)"},{"address":44522,"text":"save it"},{"address":44524,"text":"*2"},{"address":44525,"text":"*3"},{"address":44527,"text":"copy to index"},{"address":44528,"text":"pull previous precedence"},{"address":44529,"text":"compare with precedence byte"},{"address":44532,"text":"branch if A \u003e="},{"address":44534,"text":"check if source is numeric, else do type mismatch"},{"address":44537,"text":"save precedence"},{"address":44538,"text":"get vector, execute function then continue evaluation"},{"address":44541,"text":"restore precedence"},{"address":44542,"text":"get precedence stacked flag"},{"address":44544,"text":"branch if stacked values"},{"address":44546,"text":"copy precedence, set flags"},{"address":44547,"text":"exit if done"},{"address":44549,"text":"else pop FAC2 and return, branch always"},{"address":44551,"text":"clear data type flag, $FF = string, $00 = numeric"},{"address":44553,"text":"copy compare function flag"},{"address":44554,"text":"\u003c\u003c1, shift data type flag into b0, 1 = string, 0 = num"},{"address":44555,"text":"get BASIC execute pointer low byte"},{"address":44557,"text":"branch if no underflow"},{"address":44559,"text":"else decrement BASIC execute pointer high byte"},{"address":44561,"text":"decrement BASIC execute pointer low byte"},{"address":44565,"text":"save new comparrison evaluation flag"},{"address":44567,"text":"branch always"},{"address":44569,"text":"compare with stacked function precedence"},{"address":44572,"text":"if A \u003e=, pop FAC2 and return"},{"address":44574,"text":"else go stack this one and continue, branch always"},{"address":44576,"text":"get function vector high byte"},{"address":44579,"text":"onto stack"},{"address":44580,"text":"get function vector low byte"},{"address":44583,"text":"onto stack\nnow push sign, round FAC1 and put on stack"},{"address":44584,"text":"function will return here, then the next RTS will call\nthe function"},{"address":44587,"text":"get comparrison evaluation flag"},{"address":44589,"text":"continue evaluating expression"},{"address":44592,"text":"do syntax error then warm start"},{"address":44595,"text":"get FAC1 sign (b7)"},{"address":44597,"text":"get precedence byte"},{"address":44600,"text":"copy sign"},{"address":44601,"text":"get return address low byte"},{"address":44602,"text":"save it"},{"address":44604,"text":"increment it as return-1 is pushed\nnote, no check is made on the high byte so if the calling\nroutine ever assembles to a page edge then this all goes\nhorribly wrong!"},{"address":44606,"text":"get return address high byte"},{"address":44607,"text":"save it"},{"address":44609,"text":"restore sign"},{"address":44610,"text":"push sign"},{"address":44611,"text":"round FAC1"},{"address":44614,"text":"get FAC1 mantissa 4"},{"address":44616,"text":"save it"},{"address":44617,"text":"get FAC1 mantissa 3"},{"address":44619,"text":"save it"},{"address":44620,"text":"get FAC1 mantissa 2"},{"address":44622,"text":"save it"},{"address":44623,"text":"get FAC1 mantissa 1"},{"address":44625,"text":"save it"},{"address":44626,"text":"get FAC1 exponent"},{"address":44628,"text":"save it"},{"address":44629,"text":"return, sort of"},{"address":44632,"text":"flag function"},{"address":44634,"text":"pull precedence byte"},{"address":44635,"text":"exit if done"},{"address":44637,"text":"compare previous precedence with $64"},{"address":44639,"text":"branch if was $64 (\u003c function)"},{"address":44641,"text":"check if source is numeric, else do type mismatch"},{"address":44644,"text":"save precedence stacked flag\npop FAC2 and return"},{"address":44646,"text":"pop byte"},{"address":44647,"text":"shift out comparison evaluation lowest bit"},{"address":44648,"text":"save the comparison evaluation flag"},{"address":44650,"text":"pop exponent"},{"address":44651,"text":"save FAC2 exponent"},{"address":44653,"text":"pop mantissa 1"},{"address":44654,"text":"save FAC2 mantissa 1"},{"address":44656,"text":"pop mantissa 2"},{"address":44657,"text":"save FAC2 mantissa 2"},{"address":44659,"text":"pop mantissa 3"},{"address":44660,"text":"save FAC2 mantissa 3"},{"address":44662,"text":"pop mantissa 4"},{"address":44663,"text":"save FAC2 mantissa 4"},{"address":44665,"text":"pop sign"},{"address":44666,"text":"save FAC2 sign (b7)"},{"address":44668,"text":"EOR FAC1 sign (b7)"},{"address":44670,"text":"save sign compare (FAC1 EOR FAC2)"},{"address":44672,"text":"get FAC1 exponent"},{"address":44675,"text":"get arithmetic element"},{"address":44678,"text":"clear byte"},{"address":44680,"text":"clear data type flag, $FF = string, $00 = numeric"},{"address":44682,"text":"increment and scan memory"},{"address":44685,"text":"branch if not numeric character\nelse numeric string found (e.g. 123)"},{"address":44687,"text":"get FAC1 from string and return\nget value from line .. continued\nwasn't a number so ..."},{"address":44690,"text":"check byte, return Cb = 0 if\u003c\"A\" or \u003e\"Z\""},{"address":44693,"text":"branch if not variable name"},{"address":44695,"text":"variable name set-up and return"},{"address":44698,"text":"compare with token for PI"},{"address":44700,"text":"branch if not PI"},{"address":44702,"text":"get PI pointer low byte"},{"address":44704,"text":"get PI pointer high byte"},{"address":44706,"text":"unpack memory (AY) into FAC1"},{"address":44709,"text":"increment and scan memory and return"},{"address":44717,"text":"compare with \".\""},{"address":44719,"text":"if so get FAC1 from string and return, e.g. was .123\nwasn't .123 so ..."},{"address":44721,"text":"compare with token for -"},{"address":44723,"text":"branch if - token, do set-up for functions\nwasn't -123 so ..."},{"address":44725,"text":"compare with token for +"},{"address":44727,"text":"branch if + token, +1 = 1 so ignore leading +\nit wasn't any sort of number so ..."},{"address":44729,"text":"compare with \""},{"address":44731,"text":"branch if not open quote\nwas open quote so get the enclosed string"},{"address":44733,"text":"get BASIC execute pointer low byte"},{"address":44735,"text":"get BASIC execute pointer high byte"},{"address":44737,"text":"add carry to low byte"},{"address":44739,"text":"branch if no overflow"},{"address":44741,"text":"increment high byte"},{"address":44742,"text":"print \" terminated string to utility pointer"},{"address":44745,"text":"restore BASIC execute pointer from temp and return\nget value from line .. continued\nwasn't a string so ..."},{"address":44748,"text":"compare with token for NOT"},{"address":44750,"text":"branch if not token for NOT\nwas NOT token"},{"address":44752,"text":"offset to NOT function"},{"address":44754,"text":"do set-up for function then execute, branch always\ndo = compare"},{"address":44756,"text":"evaluate integer expression, no sign check"},{"address":44759,"text":"get FAC1 mantissa 4"},{"address":44761,"text":"invert it"},{"address":44763,"text":"copy it"},{"address":44764,"text":"get FAC1 mantissa 3"},{"address":44766,"text":"invert it"},{"address":44768,"text":"convert fixed integer AY to float FAC1 and return\nget value from line .. continued\nwasn't a string or NOT so ..."},{"address":44771,"text":"compare with token for FN"},{"address":44773,"text":"branch if not token for FN"},{"address":44775,"text":"else go evaluate FNx\nget value from line .. continued\nwasn't a string, NOT or FN so ..."},{"address":44778,"text":"compare with token for SGN"},{"address":44780,"text":"if less than SGN token evaluate expression in parentheses\nelse was a function token"},{"address":44782,"text":"go set up function references, branch always\nget value from line .. continued\nif here it can only be something in brackets so ....\nevaluate expression within parentheses"},{"address":44785,"text":"scan for \"(\", else do syntax error then warm start"},{"address":44788,"text":"evaluate expression\nall the 'scan for' routines return the character after the sought character\nscan for \")\", else do syntax error then warm start"},{"address":44791,"text":"load A with \")\""},{"address":44794,"text":"load A with \"(\""},{"address":44797,"text":"load A with \",\"\nscan for CHR$(A), else do syntax error then warm start"},{"address":44799,"text":"clear index"},{"address":44801,"text":"compare with BASIC byte"},{"address":44803,"text":"if not expected byte do syntax error then warm start"},{"address":44805,"text":"else increment and scan memory and return\nsyntax error then warm start"},{"address":44808,"text":"error code $0B, syntax error"},{"address":44810,"text":"do error #X then warm start"},{"address":44813,"text":"set offset from base to \u003e operator"},{"address":44815,"text":"dump return address low byte"},{"address":44816,"text":"dump return address high byte"},{"address":44817,"text":"execute function then continue evaluation"},{"address":44820,"text":"set carry for subtract"},{"address":44821,"text":"get variable address low byte"},{"address":44823,"text":"subtract $A000 low byte"},{"address":44825,"text":"get variable address high byte"},{"address":44827,"text":"subtract $A000 high byte"},{"address":44829,"text":"exit if address \u003c $A000"},{"address":44831,"text":"get end of BASIC marker low byte"},{"address":44833,"text":"subtract variable address low byte"},{"address":44835,"text":"get end of BASIC marker high byte"},{"address":44837,"text":"subtract variable address high byte"},{"address":44840,"text":"get variable address"},{"address":44843,"text":"save variable pointer low byte"},{"address":44845,"text":"save variable pointer high byte"},{"address":44847,"text":"get current variable name first character"},{"address":44849,"text":"get current variable name second character"},{"address":44851,"text":"get data type flag, $FF = string, $00 = numeric"},{"address":44853,"text":"branch if numeric\nvariable is string"},{"address":44855,"text":"else clear A"},{"address":44857,"text":"clear FAC1 rounding byte"},{"address":44859,"text":"check address range"},{"address":44862,"text":"exit if not in BASIC ROM"},{"address":44864,"text":"compare variable name first character with \"T\""},{"address":44866,"text":"exit if not \"T\""},{"address":44868,"text":"compare variable name second character with \"I$\""},{"address":44870,"text":"exit if not \"I$\"\nvariable name was \"TI$\""},{"address":44872,"text":"read real time clock into FAC1 mantissa, 0HML"},{"address":44875,"text":"clear exponent count adjust"},{"address":44877,"text":"Y = $FF"},{"address":44878,"text":"set output string index, -1 to allow for pre increment"},{"address":44880,"text":"HH:MM:SS is six digits"},{"address":44882,"text":"set number of characters before the decimal point"},{"address":44886,"text":"convert jiffy count to string"},{"address":44889,"text":"exit via STR$() code tail"},{"address":44893,"text":"test data type flag, $80 = integer, $00 = float"},{"address":44895,"text":"branch if float"},{"address":44897,"text":"clear index"},{"address":44899,"text":"get integer variable low byte"},{"address":44901,"text":"copy to X"},{"address":44902,"text":"increment index"},{"address":44903,"text":"get integer variable high byte"},{"address":44905,"text":"copy to Y"},{"address":44906,"text":"copy loa byte to A"},{"address":44907,"text":"convert fixed integer AY to float FAC1 and return\nvariable name set-up, variable is float"},{"address":44910,"text":"check address range"},{"address":44913,"text":"if not in BASIC ROM get pointer and unpack into FAC1"},{"address":44915,"text":"compare variable name first character with \"T\""},{"address":44917,"text":"branch if not \"T\""},{"address":44919,"text":"compare variable name second character with \"I\""},{"address":44921,"text":"branch if not \"I\"\nvariable name was \"TI\""},{"address":44923,"text":"read real time clock into FAC1 mantissa, 0HML"},{"address":44926,"text":"clear A"},{"address":44927,"text":"set exponent to 32 bit value"},{"address":44929,"text":"set exponent = X and normalise FAC1"},{"address":44932,"text":"read real time clock"},{"address":44935,"text":"save jiffy clock mid byte as  FAC1 mantissa 3"},{"address":44937,"text":"save jiffy clock high byte as  FAC1 mantissa 2"},{"address":44939,"text":"save jiffy clock low byte as  FAC1 mantissa 4"},{"address":44941,"text":"clear Y"},{"address":44943,"text":"clear FAC1 mantissa 1"},{"address":44946,"text":"compare variable name first character with \"S\""},{"address":44948,"text":"if not \"S\" go do normal floating variable"},{"address":44950,"text":"compare variable name second character with \""},{"address":44952,"text":"if not \"T\" go do normal floating variable\nvariable name was \"ST\""},{"address":44954,"text":"read I/O status word"},{"address":44957,"text":"save A as integer byte and return\nvariable is float"},{"address":44960,"text":"get variable pointer low byte"},{"address":44962,"text":"get variable pointer high byte"},{"address":44964,"text":"unpack memory (AY) into FAC1"},{"address":44967,"text":"*2 (2 bytes per function address)"},{"address":44968,"text":"save function offset"},{"address":44969,"text":"copy function offset"},{"address":44970,"text":"increment and scan memory"},{"address":44973,"text":"compare function offset to CHR$ token offset+1"},{"address":44975,"text":"branch if \u003c LEFT$ (can not be =)\nget value from line .. continued\nwas LEFT$, RIGHT$ or MID$ so.."},{"address":44977,"text":"scan for \"(\", else do syntax error then warm start"},{"address":44980,"text":"evaluate, should be string, expression"},{"address":44983,"text":"scan for \",\", else do syntax error then warm start"},{"address":44986,"text":"check if source is string, else do type mismatch"},{"address":44989,"text":"restore function offset"},{"address":44990,"text":"copy it"},{"address":44991,"text":"get descriptor pointer high byte"},{"address":44993,"text":"push string pointer high byte"},{"address":44994,"text":"get descriptor pointer low byte"},{"address":44996,"text":"push string pointer low byte"},{"address":44997,"text":"restore function offset"},{"address":44998,"text":"save function offset"},{"address":44999,"text":"get byte parameter"},{"address":45002,"text":"restore function offset"},{"address":45003,"text":"copy function offset"},{"address":45004,"text":"copy byte parameter to A"},{"address":45005,"text":"push byte parameter"},{"address":45006,"text":"go call function\nget value from line .. continued\nwas SGN() to CHR$() so.."},{"address":45009,"text":"evaluate expression within parentheses"},{"address":45012,"text":"restore function offset"},{"address":45013,"text":"copy to index"},{"address":45014,"text":"get function jump vector low byte"},{"address":45017,"text":"save functions jump vector low byte"},{"address":45019,"text":"get function jump vector high byte"},{"address":45022,"text":"save functions jump vector high byte"},{"address":45024,"text":"do function call"},{"address":45027,"text":"check if source is numeric and RTS, else do type mismatch\nstring functions avoid this by dumping the return address"},{"address":45030,"text":"set Y for OR"},{"address":45033,"text":"clear Y for AND"},{"address":45035,"text":"set AND/OR invert value"},{"address":45037,"text":"evaluate integer expression, no sign check"},{"address":45040,"text":"get FAC1 mantissa 3"},{"address":45042,"text":"EOR low byte"},{"address":45044,"text":"save it"},{"address":45046,"text":"get FAC1 mantissa 4"},{"address":45048,"text":"EOR high byte"},{"address":45050,"text":"save it"},{"address":45052,"text":"copy FAC2 to FAC1, get 2nd value in expression"},{"address":45055,"text":"evaluate integer expression, no sign check"},{"address":45058,"text":"get FAC1 mantissa 4"},{"address":45060,"text":"EOR high byte"},{"address":45062,"text":"AND with expression 1 high byte"},{"address":45064,"text":"EOR result high byte"},{"address":45066,"text":"save in Y"},{"address":45067,"text":"get FAC1 mantissa 3"},{"address":45069,"text":"EOR low byte"},{"address":45071,"text":"AND with expression 1 low byte"},{"address":45073,"text":"EOR result low byte"},{"address":45075,"text":"convert fixed integer AY to float FAC1 and return"},{"address":45078,"text":"type match check, set C for string"},{"address":45081,"text":"branch if string\ndo numeric \u003c compare"},{"address":45083,"text":"get FAC2 sign (b7)"},{"address":45085,"text":"set all non sign bits"},{"address":45087,"text":"and FAC2 mantissa 1 (AND in sign bit)"},{"address":45089,"text":"save FAC2 mantissa 1"},{"address":45091,"text":"set pointer low byte to FAC2"},{"address":45093,"text":"set pointer high byte to FAC2"},{"address":45095,"text":"compare FAC1 with (AY)"},{"address":45098,"text":"copy the result"},{"address":45099,"text":"go evaluate result\ndo string \u003c compare"},{"address":45102,"text":"clear byte"},{"address":45104,"text":"clear data type flag, $FF = string, $00 = numeric"},{"address":45106,"text":"clear \u003c bit in comparrison evaluation flag"},{"address":45108,"text":"pop string off descriptor stack, or from top of string\nspace returns with A = length, X = pointer low byte,\nY = pointer high byte"},{"address":45111,"text":"save length"},{"address":45113,"text":"save string pointer low byte"},{"address":45115,"text":"save string pointer high byte"},{"address":45117,"text":"get descriptor pointer low byte"},{"address":45119,"text":"get descriptor pointer high byte"},{"address":45121,"text":"pop (YA) descriptor off stack or from top of string space\nreturns with A = length, X = pointer low byte,\nY = pointer high byte"},{"address":45124,"text":"save string pointer low byte"},{"address":45126,"text":"save string pointer high byte"},{"address":45128,"text":"copy length"},{"address":45129,"text":"set carry for subtract"},{"address":45130,"text":"subtract string 1 length"},{"address":45132,"text":"branch if str 1 length = string 2 length"},{"address":45134,"text":"set str 1 length \u003e string 2 length"},{"address":45136,"text":"branch if so"},{"address":45138,"text":"get string 1 length"},{"address":45140,"text":"set str 1 length \u003c string 2 length"},{"address":45142,"text":"save length compare"},{"address":45144,"text":"set index"},{"address":45146,"text":"adjust for loop"},{"address":45147,"text":"increment index"},{"address":45148,"text":"decrement count"},{"address":45149,"text":"branch if still bytes to do"},{"address":45151,"text":"get length compare back"},{"address":45153,"text":"branch if str 1 \u003c str 2"},{"address":45155,"text":"flag str 1 \u003c= str 2"},{"address":45156,"text":"go evaluate result"},{"address":45158,"text":"get string 2 byte"},{"address":45160,"text":"compare with string 1 byte"},{"address":45162,"text":"loop if bytes ="},{"address":45164,"text":"set str 1 \u003c string 2"},{"address":45166,"text":"branch if so"},{"address":45168,"text":"set str 1 \u003e string 2"},{"address":45170,"text":"x = 0, 1 or 2"},{"address":45171,"text":"copy to A"},{"address":45172,"text":"* 2 (1, 2 or 4)"},{"address":45173,"text":"AND with the comparison evaluation flag"},{"address":45175,"text":"branch if 0 (compare is false)"},{"address":45177,"text":"else set result true"},{"address":45179,"text":"save A as integer byte and return"},{"address":45182,"text":"scan for \",\", else do syntax error then warm start"},{"address":45185,"text":"copy \"DIM\" flag to X"},{"address":45186,"text":"search for variable"},{"address":45189,"text":"scan memory"},{"address":45192,"text":"scan for \",\" and loop if not null"},{"address":45195,"text":"set DIM flag = $00"},{"address":45197,"text":"scan memory, 1st character"},{"address":45200,"text":"save DIM flag"},{"address":45202,"text":"save 1st character"},{"address":45204,"text":"scan memory"},{"address":45207,"text":"check byte, return Cb = 0 if\u003c\"A\" or \u003e\"Z\""},{"address":45210,"text":"branch if ok"},{"address":45212,"text":"else syntax error then warm start\nwas variable name so ..."},{"address":45215,"text":"clear 2nd character temp"},{"address":45217,"text":"clear data type flag, $FF = string, $00 = numeric"},{"address":45219,"text":"clear data type flag, $80 = integer, $00 = float"},{"address":45221,"text":"increment and scan memory, 2nd character"},{"address":45224,"text":"if character = \"0\"-\"9\" (ok) go save 2nd character\n2nd character wasn't \"0\" to \"9\" so ..."},{"address":45226,"text":"check byte, return Cb = 0 if\u003c\"A\" or \u003e\"Z\""},{"address":45229,"text":"branch if \u003c\"A\" or \u003e\"Z\" (go check if string)"},{"address":45231,"text":"copy 2nd character\nignore further (valid) characters in the variable name"},{"address":45232,"text":"increment and scan memory, 3rd character"},{"address":45235,"text":"loop if character = \"0\"-\"9\" (ignore)"},{"address":45237,"text":"check byte, return Cb = 0 if\u003c\"A\" or \u003e\"Z\""},{"address":45240,"text":"loop if character = \"A\"-\"Z\" (ignore)\ncheck if string variable"},{"address":45242,"text":"compare with \"$\""},{"address":45244,"text":"branch if not string\ntype is string"},{"address":45246,"text":"set data type = string"},{"address":45248,"text":"set data type flag, $FF = string, $00 = numeric"},{"address":45250,"text":"branch always"},{"address":45252,"text":"compare with \"%\""},{"address":45254,"text":"branch if not integer"},{"address":45256,"text":"get subscript/FNX flag"},{"address":45258,"text":"if ?? do syntax error then warm start"},{"address":45260,"text":"set integer type"},{"address":45262,"text":"set data type = integer"},{"address":45264,"text":"OR current variable name first byte"},{"address":45266,"text":"save current variable name first byte"},{"address":45268,"text":"get 2nd character back"},{"address":45269,"text":"set top bit, indicate string or integer variable"},{"address":45271,"text":"copy back to 2nd character temp"},{"address":45272,"text":"increment and scan memory"},{"address":45275,"text":"save 2nd character"},{"address":45277,"text":"set carry for subtract"},{"address":45278,"text":"or with subscript/FNX flag - or FN name"},{"address":45280,"text":"subtract \"(\""},{"address":45282,"text":"branch if not \"(\""},{"address":45284,"text":"go find, or make, array\neither find or create variable\nvariable name wasn't xx(.... so look for plain variable"},{"address":45287,"text":"clear A"},{"address":45289,"text":"clear subscript/FNX flag"},{"address":45291,"text":"get start of variables low byte"},{"address":45293,"text":"get start of variables high byte"},{"address":45295,"text":"save search address high byte"},{"address":45297,"text":"save search address low byte"},{"address":45299,"text":"compare with end of variables high byte"},{"address":45301,"text":"skip next compare if \u003c\u003e\nhigh addresses were = so compare low addresses"},{"address":45303,"text":"compare low address with end of variables low byte"},{"address":45305,"text":"if not found go make new variable"},{"address":45307,"text":"get 1st character of variable to find"},{"address":45309,"text":"compare with variable name 1st character"},{"address":45311,"text":"branch if no match\n1st characters match so compare 2nd character"},{"address":45313,"text":"get 2nd character of variable to find"},{"address":45315,"text":"index to point to variable name 2nd character"},{"address":45316,"text":"compare with variable name 2nd character"},{"address":45318,"text":"branch if match (found variable)"},{"address":45320,"text":"else decrement index (now = $00)"},{"address":45321,"text":"clear carry for add"},{"address":45322,"text":"get search address low byte"},{"address":45324,"text":"+7, offset to next variable name"},{"address":45326,"text":"loop if no overflow to high byte"},{"address":45328,"text":"else increment high byte"},{"address":45329,"text":"loop always, RAM doesn't extend to $FFFF\ncheck byte, return Cb = 0 if\u003c\"A\" or \u003e\"Z\""},{"address":45331,"text":"compare with \"A\""},{"address":45333,"text":"exit if less\ncarry is set"},{"address":45335,"text":"subtract \"Z\"+1"},{"address":45337,"text":"set carry"},{"address":45338,"text":"subtract $A5 (restore byte)\ncarry clear if byte \u003e $5A"},{"address":45341,"text":"pop return address low byte"},{"address":45342,"text":"push return address low byte"},{"address":45343,"text":"compare with expected calling routine return low byte"},{"address":45345,"text":"if not get variable go create new variable\nthis will only drop through if the call was from $AF28 and is only called\nfrom there if it is searching for a variable from the right hand side of a LET a=b\nstatement, it prevents the creation of variables not assigned a value.\nvalue returned by this is either numeric zero, exponent byte is $00, or null string,\ndescriptor length byte is $00. in fact a pointer to any $00 byte would have done.\nelse return dummy null value"},{"address":45347,"text":"set result pointer low byte"},{"address":45349,"text":"set result pointer high byte"},{"address":45352,"text":"get variable name first character"},{"address":45354,"text":"get variable name second character"},{"address":45356,"text":"compare first character with \"T\""},{"address":45358,"text":"branch if not \"T\""},{"address":45360,"text":"compare second character with \"I$\""},{"address":45362,"text":"if \"I$\" return null value"},{"address":45364,"text":"compare second character with \"I\""},{"address":45366,"text":"branch if not \"I\"\nif name is \"TI\" do syntax error"},{"address":45368,"text":"do syntax error then warm start"},{"address":45371,"text":"compare first character with \"S\""},{"address":45373,"text":"branch if not \"S\""},{"address":45375,"text":"compare second character with \"T\""},{"address":45377,"text":"if name is \"ST\" do syntax error"},{"address":45379,"text":"get end of variables low byte"},{"address":45381,"text":"get end of variables high byte"},{"address":45383,"text":"save old block start low byte"},{"address":45385,"text":"save old block start high byte"},{"address":45387,"text":"get end of arrays low byte"},{"address":45389,"text":"get end of arrays high byte"},{"address":45391,"text":"save old block end low byte"},{"address":45393,"text":"save old block end high byte"},{"address":45395,"text":"clear carry for add"},{"address":45396,"text":"+7, space for one variable"},{"address":45398,"text":"branch if no overflow to high byte"},{"address":45400,"text":"else increment high byte"},{"address":45401,"text":"set new block end low byte"},{"address":45403,"text":"set new block end high byte"},{"address":45405,"text":"open up space in memory"},{"address":45408,"text":"get new start low byte"},{"address":45410,"text":"get new start high byte (-$100)"},{"address":45412,"text":"correct high byte"},{"address":45413,"text":"set end of variables low byte"},{"address":45415,"text":"set end of variables high byte"},{"address":45417,"text":"clear index"},{"address":45419,"text":"get variable name 1st character"},{"address":45421,"text":"save variable name 1st character"},{"address":45423,"text":"increment index"},{"address":45424,"text":"get variable name 2nd character"},{"address":45426,"text":"save variable name 2nd character"},{"address":45428,"text":"clear A"},{"address":45430,"text":"increment index"},{"address":45431,"text":"initialise variable byte"},{"address":45433,"text":"increment index"},{"address":45434,"text":"initialise variable byte"},{"address":45436,"text":"increment index"},{"address":45437,"text":"initialise variable byte"},{"address":45439,"text":"increment index"},{"address":45440,"text":"initialise variable byte"},{"address":45442,"text":"increment index"},{"address":45443,"text":"initialise variable byte\nfound a match for variable"},{"address":45445,"text":"get variable address low byte"},{"address":45447,"text":"clear carry for add"},{"address":45448,"text":"+2, offset past variable name bytes"},{"address":45450,"text":"get variable address high byte"},{"address":45452,"text":"branch if no overflow from add"},{"address":45454,"text":"else increment high byte"},{"address":45455,"text":"save current variable pointer low byte"},{"address":45457,"text":"save current variable pointer high byte"},{"address":45460,"text":"get # of dimensions (1, 2 or 3)"},{"address":45462,"text":"*2 (also clears the carry !)"},{"address":45463,"text":"+5 (result is 7, 9 or 11 here)"},{"address":45465,"text":"add array start pointer low byte"},{"address":45467,"text":"get array pointer high byte"},{"address":45469,"text":"branch if no overflow"},{"address":45471,"text":"else increment high byte"},{"address":45472,"text":"save array data pointer low byte"},{"address":45474,"text":"save array data pointer high byte"},{"address":45482,"text":"evaluate integer expression, no sign check"},{"address":45485,"text":"get result low byte"},{"address":45487,"text":"get result high byte"},{"address":45490,"text":"increment and scan memory"},{"address":45493,"text":"evaluate expression\nevaluate integer expression, sign check"},{"address":45496,"text":"check if source is numeric, else do type mismatch"},{"address":45499,"text":"get FAC1 sign (b7)"},{"address":45501,"text":"do illegal quantity error if -ve\nevaluate integer expression, no sign check"},{"address":45503,"text":"get FAC1 exponent"},{"address":45505,"text":"compare with exponent = 2^16 (n\u003e2^15)"},{"address":45507,"text":"if n\u003c2^16 go convert FAC1 floating to fixed and return"},{"address":45509,"text":"set pointer low byte to -32768"},{"address":45511,"text":"set pointer high byte to -32768"},{"address":45513,"text":"compare FAC1 with (AY)"},{"address":45516,"text":"if \u003c\u003e do illegal quantity error then warm start"},{"address":45518,"text":"convert FAC1 floating to fixed and return"},{"address":45521,"text":"get DIM flag"},{"address":45523,"text":"OR with data type flag"},{"address":45525,"text":"push it"},{"address":45526,"text":"get data type flag, $FF = string, $00 = numeric"},{"address":45528,"text":"push it"},{"address":45529,"text":"clear dimensions count\nnow get the array dimension(s) and stack it (them) before the data type and DIM flag"},{"address":45531,"text":"copy dimensions count"},{"address":45532,"text":"save it"},{"address":45533,"text":"get array name 2nd byte"},{"address":45535,"text":"save it"},{"address":45536,"text":"get array name 1st byte"},{"address":45538,"text":"save it"},{"address":45539,"text":"evaluate integer expression"},{"address":45542,"text":"pull array name 1st byte"},{"address":45543,"text":"restore array name 1st byte"},{"address":45545,"text":"pull array name 2nd byte"},{"address":45546,"text":"restore array name 2nd byte"},{"address":45548,"text":"pull dimensions count"},{"address":45549,"text":"restore it"},{"address":45550,"text":"copy stack pointer"},{"address":45551,"text":"get DIM flag"},{"address":45554,"text":"push it"},{"address":45555,"text":"get data type flag"},{"address":45558,"text":"push it"},{"address":45559,"text":"get this dimension size high byte"},{"address":45561,"text":"stack before flag bytes"},{"address":45564,"text":"get this dimension size low byte"},{"address":45566,"text":"stack before flag bytes"},{"address":45569,"text":"increment dimensions count"},{"address":45570,"text":"scan memory"},{"address":45573,"text":"compare with \",\""},{"address":45575,"text":"if found go do next dimension"},{"address":45577,"text":"store dimensions count"},{"address":45579,"text":"scan for \")\", else do syntax error then warm start"},{"address":45582,"text":"pull data type flag"},{"address":45583,"text":"restore data type flag, $FF = string, $00 = numeric"},{"address":45585,"text":"pull data type flag"},{"address":45586,"text":"restore data type flag, $80 = integer, $00 = float"},{"address":45588,"text":"mask dim flag"},{"address":45590,"text":"restore DIM flag"},{"address":45592,"text":"set end of variables low byte\n(array memory start low byte)"},{"address":45594,"text":"set end of variables high byte\n(array memory start high byte)\nnow check to see if we are at the end of array memory, we would be if there were\nno arrays."},{"address":45596,"text":"save as array start pointer low byte"},{"address":45598,"text":"save as array start pointer high byte"},{"address":45600,"text":"compare with end of arrays high byte"},{"address":45602,"text":"branch if not reached array memory end"},{"address":45604,"text":"else compare with end of arrays low byte"},{"address":45606,"text":"go build array if not found\nsearch for array"},{"address":45608,"text":"clear index"},{"address":45610,"text":"get array name first byte"},{"address":45612,"text":"increment index to second name byte"},{"address":45613,"text":"compare with this array name first byte"},{"address":45615,"text":"branch if no match"},{"address":45617,"text":"else get this array name second byte"},{"address":45619,"text":"compare with array name second byte"},{"address":45621,"text":"array found so branch\nno match"},{"address":45623,"text":"increment index"},{"address":45624,"text":"get array size low byte"},{"address":45626,"text":"clear carry for add"},{"address":45627,"text":"add array start pointer low byte"},{"address":45629,"text":"copy low byte to X"},{"address":45630,"text":"increment index"},{"address":45631,"text":"get array size high byte"},{"address":45633,"text":"add array memory pointer high byte"},{"address":45635,"text":"if no overflow go check next array"},{"address":45637,"text":"error $12, bad subscript error"},{"address":45640,"text":"error $0E, illegal quantity error"},{"address":45642,"text":"do error #X then warm start"},{"address":45645,"text":"set error $13, double dimension error"},{"address":45647,"text":"get DIM flag"},{"address":45649,"text":"if we are trying to dimension it do error #X then warm\nstart\nfound the array and we're not dimensioning it so we must find an element in it"},{"address":45651,"text":"set-up array pointer to first element in array"},{"address":45654,"text":"get dimensions count"},{"address":45656,"text":"set index to array's # of dimensions"},{"address":45658,"text":"compare with no of dimensions"},{"address":45660,"text":"if wrong do bad subscript error"},{"address":45662,"text":"found array so go get element\narray not found, so build it"},{"address":45665,"text":"set-up array pointer to first element in array"},{"address":45668,"text":"check available memory, do out of memory error if no room"},{"address":45671,"text":"clear Y"},{"address":45673,"text":"clear array data size high byte"},{"address":45675,"text":"set default element size"},{"address":45677,"text":"get variable name 1st byte"},{"address":45679,"text":"save array name 1st byte"},{"address":45681,"text":"branch if not string or floating point array"},{"address":45683,"text":"decrement element size, $04"},{"address":45684,"text":"increment index"},{"address":45685,"text":"get variable name 2nd byte"},{"address":45687,"text":"save array name 2nd byte"},{"address":45689,"text":"branch if not integer or string"},{"address":45691,"text":"decrement element size, $03"},{"address":45692,"text":"decrement element size, $02"},{"address":45693,"text":"save element size"},{"address":45695,"text":"get dimensions count"},{"address":45697,"text":"increment index .."},{"address":45698,"text":".. to array  .."},{"address":45699,"text":".. dimension count"},{"address":45700,"text":"save array dimension count"},{"address":45702,"text":"set default dimension size low byte"},{"address":45704,"text":"set default dimension size high byte"},{"address":45706,"text":"test DIM flag"},{"address":45708,"text":"branch if default to be used"},{"address":45710,"text":"pull dimension size low byte"},{"address":45711,"text":"clear carry for add"},{"address":45712,"text":"add 1, allow for zeroeth element"},{"address":45714,"text":"copy low byte to X"},{"address":45715,"text":"pull dimension size high byte"},{"address":45716,"text":"add carry to high byte"},{"address":45718,"text":"incement index to dimension size high byte"},{"address":45719,"text":"save dimension size high byte"},{"address":45721,"text":"incement index to dimension size low byte"},{"address":45722,"text":"copy dimension size low byte"},{"address":45723,"text":"save dimension size low byte"},{"address":45725,"text":"compute array size"},{"address":45728,"text":"save result low byte"},{"address":45730,"text":"save result high byte"},{"address":45732,"text":"restore index"},{"address":45734,"text":"decrement dimensions count"},{"address":45736,"text":"loop if not all done"},{"address":45738,"text":"add array data pointer high byte"},{"address":45740,"text":"if overflow do out of memory error then warm start"},{"address":45742,"text":"save array data pointer high byte"},{"address":45744,"text":"copy array data pointer high byte"},{"address":45745,"text":"copy array size low byte"},{"address":45746,"text":"add array data pointer low byte"},{"address":45748,"text":"branch if no rollover"},{"address":45750,"text":"else increment next array pointer high byte"},{"address":45751,"text":"if rolled over do out of memory error then warm start"},{"address":45753,"text":"check available memory, do out of memory error if no room"},{"address":45756,"text":"set end of arrays low byte"},{"address":45758,"text":"set end of arrays high byte\nnow the aray is created we need to zero all the elements in it"},{"address":45760,"text":"clear A for array clear"},{"address":45762,"text":"increment array size high byte, now block count"},{"address":45764,"text":"get array size low byte, now index to block"},{"address":45766,"text":"branch if $00"},{"address":45768,"text":"decrement index, do 0 to n-1"},{"address":45769,"text":"clear array element byte"},{"address":45771,"text":"loop until this block done"},{"address":45773,"text":"decrement array pointer high byte"},{"address":45775,"text":"decrement block count high byte"},{"address":45777,"text":"loop until all blocks done"},{"address":45779,"text":"correct for last loop"},{"address":45781,"text":"set carry for subtract"},{"address":45782,"text":"get end of arrays low byte"},{"address":45784,"text":"subtract array start low byte"},{"address":45786,"text":"index to array size low byte"},{"address":45788,"text":"save array size low byte"},{"address":45790,"text":"get end of arrays high byte"},{"address":45792,"text":"index to array size high byte"},{"address":45793,"text":"subtract array start high byte"},{"address":45795,"text":"save array size high byte"},{"address":45797,"text":"get default DIM flag"},{"address":45799,"text":"exit if this was a DIM command\nelse, find element"},{"address":45801,"text":"set index to # of dimensions, the dimension indeces\nare on the stack and will be removed as the position\nof the array element is calculated"},{"address":45802,"text":"get array's dimension count"},{"address":45804,"text":"save it"},{"address":45806,"text":"clear byte"},{"address":45808,"text":"clear array data pointer low byte"},{"address":45810,"text":"save array data pointer high byte"},{"address":45812,"text":"increment index, point to array bound high byte"},{"address":45813,"text":"pull array index low byte"},{"address":45814,"text":"copy to X"},{"address":45815,"text":"save index low byte to FAC1 mantissa 3"},{"address":45817,"text":"pull array index high byte"},{"address":45818,"text":"save index high byte to FAC1 mantissa 4"},{"address":45820,"text":"compare with array bound high byte"},{"address":45822,"text":"branch if within bounds"},{"address":45824,"text":"if outside bounds do bad subscript error\nelse high byte was = so test low bytes"},{"address":45826,"text":"index to array bound low byte"},{"address":45827,"text":"get array index low byte"},{"address":45828,"text":"compare with array bound low byte"},{"address":45830,"text":"branch if within bounds"},{"address":45832,"text":"do bad subscript error"},{"address":45835,"text":"do out of memory error then warm start"},{"address":45838,"text":"index to array bound low byte"},{"address":45839,"text":"get array data pointer high byte"},{"address":45841,"text":"OR with array data pointer low byte"},{"address":45843,"text":"clear carry for either add, carry always clear here ??"},{"address":45844,"text":"branch if array data pointer = null, skip multiply"},{"address":45846,"text":"compute array size"},{"address":45849,"text":"get result low byte"},{"address":45850,"text":"add index low byte from FAC1 mantissa 3"},{"address":45852,"text":"save result low byte"},{"address":45853,"text":"get result high byte"},{"address":45854,"text":"restore index"},{"address":45856,"text":"add index high byte from FAC1 mantissa 4"},{"address":45858,"text":"save array data pointer low byte"},{"address":45860,"text":"decrement dimensions count"},{"address":45862,"text":"loop if dimensions still to do"},{"address":45864,"text":"save array data pointer high byte"},{"address":45866,"text":"set default element size"},{"address":45868,"text":"get variable name 1st byte"},{"address":45870,"text":"branch if not string or floating point array"},{"address":45872,"text":"decrement element size, $04"},{"address":45873,"text":"get variable name 2nd byte"},{"address":45875,"text":"branch if not integer or string"},{"address":45877,"text":"decrement element size, $03"},{"address":45878,"text":"decrement element size, $02"},{"address":45879,"text":"save dimension size low byte"},{"address":45881,"text":"clear dimension size high byte"},{"address":45883,"text":"compute array size"},{"address":45886,"text":"copy array size low byte"},{"address":45887,"text":"add array data start pointer low byte"},{"address":45889,"text":"save as current variable pointer low byte"},{"address":45891,"text":"copy array size high byte"},{"address":45892,"text":"add array data start pointer high byte"},{"address":45894,"text":"save as current variable pointer high byte"},{"address":45896,"text":"copy high byte to Y"},{"address":45897,"text":"get current variable pointer low byte\npointer to element is now in AY"},{"address":45900,"text":"save index"},{"address":45902,"text":"get dimension size low byte"},{"address":45904,"text":"save dimension size low byte"},{"address":45906,"text":"decrement index"},{"address":45907,"text":"get dimension size high byte"},{"address":45909,"text":"save dimension size high byte"},{"address":45911,"text":"count = $10 (16 bit multiply)"},{"address":45913,"text":"save bit count"},{"address":45915,"text":"clear result low byte"},{"address":45917,"text":"clear result high byte"},{"address":45919,"text":"get result low byte"},{"address":45920,"text":"*2"},{"address":45921,"text":"save result low byte"},{"address":45922,"text":"get result high byte"},{"address":45923,"text":"*2"},{"address":45924,"text":"save result high byte"},{"address":45925,"text":"if overflow go do \"Out of memory\" error"},{"address":45927,"text":"shift element size low byte"},{"address":45929,"text":"shift element size high byte"},{"address":45931,"text":"skip add if no carry"},{"address":45933,"text":"else clear carry for add"},{"address":45934,"text":"get result low byte"},{"address":45935,"text":"add dimension size low byte"},{"address":45937,"text":"save result low byte"},{"address":45938,"text":"get result high byte"},{"address":45939,"text":"add dimension size high byte"},{"address":45941,"text":"save result high byte"},{"address":45942,"text":"if overflow go do \"Out of memory\" error"},{"address":45944,"text":"decrement bit count"},{"address":45946,"text":"loop until all done"},{"address":45949,"text":"get data type flag, $FF = string, $00 = numeric"},{"address":45951,"text":"branch if numeric"},{"address":45953,"text":"pop string off descriptor stack, or from top of string\nspace returns with A = length, X=$71=pointer low byte,\nY=$72=pointer high byte\nFRE(n) was numeric so do this"},{"address":45956,"text":"go do garbage collection"},{"address":45959,"text":"set carry for subtract"},{"address":45960,"text":"get bottom of string space low byte"},{"address":45962,"text":"subtract end of arrays low byte"},{"address":45964,"text":"copy result to Y"},{"address":45965,"text":"get bottom of string space high byte"},{"address":45967,"text":"subtract end of arrays high byte"},{"address":45969,"text":"set type = numeric"},{"address":45971,"text":"clear data type flag, $FF = string, $00 = numeric"},{"address":45973,"text":"save FAC1 mantissa 1"},{"address":45975,"text":"save FAC1 mantissa 2"},{"address":45977,"text":"set exponent=2^16 (integer)"},{"address":45979,"text":"set exp = X, clear FAC1 3 and 4, normalise and return"},{"address":45982,"text":"set Cb for read cursor position"},{"address":45983,"text":"read/set X,Y cursor position"},{"address":45986,"text":"clear high byte"},{"address":45988,"text":"convert fixed integer AY to float FAC1, branch always\ncheck not Direct, used by DEF and INPUT"},{"address":45990,"text":"get current line number high byte"},{"address":45992,"text":"increment it"},{"address":45993,"text":"return if not direct mode\nelse do illegal direct error"},{"address":45995,"text":"error $15, illegal direct error"},{"address":45998,"text":"error $1B, undefined function error"},{"address":46000,"text":"do error #X then warm start"},{"address":46003,"text":"check FNx syntax"},{"address":46006,"text":"check not direct, back here if ok"},{"address":46009,"text":"scan for \"(\", else do syntax error then warm start"},{"address":46012,"text":"set flag for FNx"},{"address":46014,"text":"save subscript/FNx flag"},{"address":46016,"text":"get variable address"},{"address":46019,"text":"check if source is numeric, else do type mismatch"},{"address":46022,"text":"scan for \")\", else do syntax error then warm start"},{"address":46025,"text":"get = token"},{"address":46027,"text":"scan for CHR$(A), else do syntax error then warm start"},{"address":46030,"text":"push next character"},{"address":46031,"text":"get current variable pointer high byte"},{"address":46033,"text":"push it"},{"address":46034,"text":"get current variable pointer low byte"},{"address":46036,"text":"push it"},{"address":46037,"text":"get BASIC execute pointer high byte"},{"address":46039,"text":"push it"},{"address":46040,"text":"get BASIC execute pointer low byte"},{"address":46042,"text":"push it"},{"address":46043,"text":"perform DATA"},{"address":46046,"text":"put execute pointer and variable pointer into function\nand return"},{"address":46049,"text":"set FN token"},{"address":46051,"text":"scan for CHR$(A), else do syntax error then warm start"},{"address":46054,"text":"set FN flag bit"},{"address":46056,"text":"save FN name"},{"address":46058,"text":"search for FN variable"},{"address":46061,"text":"save function pointer low byte"},{"address":46063,"text":"save function pointer high byte"},{"address":46065,"text":"check if source is numeric and return, else do type\nmismatch"},{"address":46068,"text":"check FNx syntax"},{"address":46071,"text":"get function pointer high byte"},{"address":46073,"text":"push it"},{"address":46074,"text":"get function pointer low byte"},{"address":46076,"text":"push it"},{"address":46077,"text":"evaluate expression within parentheses"},{"address":46080,"text":"check if source is numeric, else do type mismatch"},{"address":46083,"text":"pop function pointer low byte"},{"address":46084,"text":"restore it"},{"address":46086,"text":"pop function pointer high byte"},{"address":46087,"text":"restore it"},{"address":46089,"text":"index to variable pointer high byte"},{"address":46091,"text":"get variable address low byte"},{"address":46093,"text":"save current variable pointer low byte"},{"address":46095,"text":"copy address low byte"},{"address":46096,"text":"index to variable address high byte"},{"address":46097,"text":"get variable pointer high byte"},{"address":46099,"text":"branch if high byte zero"},{"address":46101,"text":"save current variable pointer high byte"},{"address":46103,"text":"index to mantissa 3\nnow stack the function variable value before use"},{"address":46104,"text":"get byte from variable"},{"address":46106,"text":"stack it"},{"address":46107,"text":"decrement index"},{"address":46108,"text":"loop until variable stacked"},{"address":46110,"text":"get current variable pointer high byte"},{"address":46112,"text":"pack FAC1 into (XY)"},{"address":46115,"text":"get BASIC execute pointer high byte"},{"address":46117,"text":"push it"},{"address":46118,"text":"get BASIC execute pointer low byte"},{"address":46120,"text":"push it"},{"address":46121,"text":"get function execute pointer low byte"},{"address":46123,"text":"save BASIC execute pointer low byte"},{"address":46125,"text":"index to high byte"},{"address":46126,"text":"get function execute pointer high byte"},{"address":46128,"text":"save BASIC execute pointer high byte"},{"address":46130,"text":"get current variable pointer high byte"},{"address":46132,"text":"push it"},{"address":46133,"text":"get current variable pointer low byte"},{"address":46135,"text":"push it"},{"address":46136,"text":"evaluate expression and check is numeric, else do\ntype mismatch"},{"address":46139,"text":"pull variable address low byte"},{"address":46140,"text":"save variable address low byte"},{"address":46142,"text":"pull variable address high byte"},{"address":46143,"text":"save variable address high byte"},{"address":46145,"text":"scan memory"},{"address":46148,"text":"branch if null (should be [EOL] marker)"},{"address":46150,"text":"else syntax error then warm start"},{"address":46153,"text":"pull BASIC execute pointer low byte"},{"address":46154,"text":"save BASIC execute pointer low byte"},{"address":46156,"text":"pull BASIC execute pointer high byte"},{"address":46157,"text":"save BASIC execute pointer high byte\nput execute pointer and variable pointer into function"},{"address":46159,"text":"clear index"},{"address":46161,"text":"pull BASIC execute pointer low byte"},{"address":46162,"text":"save to function"},{"address":46164,"text":"pull BASIC execute pointer high byte"},{"address":46165,"text":"increment index"},{"address":46166,"text":"save to function"},{"address":46168,"text":"pull current variable address low byte"},{"address":46169,"text":"increment index"},{"address":46170,"text":"save to function"},{"address":46172,"text":"pull current variable address high byte"},{"address":46173,"text":"increment index"},{"address":46174,"text":"save to function"},{"address":46176,"text":"pull ??"},{"address":46177,"text":"increment index"},{"address":46178,"text":"save to function"},{"address":46181,"text":"check if source is numeric, else do type mismatch"},{"address":46184,"text":"set string index"},{"address":46186,"text":"convert FAC1 to string"},{"address":46189,"text":"dump return address (skip type check)"},{"address":46190,"text":"dump return address (skip type check)"},{"address":46191,"text":"set result string low pointer"},{"address":46193,"text":"set result string high pointer"},{"address":46195,"text":"print null terminated string to utility pointer"},{"address":46197,"text":"get descriptor pointer low byte"},{"address":46199,"text":"get descriptor pointer high byte"},{"address":46201,"text":"save descriptor pointer low byte"},{"address":46203,"text":"save descriptor pointer high byte"},{"address":46205,"text":"make space in string memory for string A long"},{"address":46208,"text":"save string pointer low byte"},{"address":46210,"text":"save string pointer high byte"},{"address":46212,"text":"save length"},{"address":46215,"text":"set terminator to \""},{"address":46217,"text":"set search character, terminator 1"},{"address":46219,"text":"set terminator 2\nprint search or alternate terminated string to utility pointer\nsource is AY"},{"address":46221,"text":"store string start low byte"},{"address":46223,"text":"store string start high byte"},{"address":46225,"text":"save string pointer low byte"},{"address":46227,"text":"save string pointer high byte"},{"address":46229,"text":"set length to -1"},{"address":46231,"text":"increment length"},{"address":46232,"text":"get byte from string"},{"address":46234,"text":"exit loop if null byte [EOS]"},{"address":46236,"text":"compare with search character, terminator 1"},{"address":46238,"text":"branch if terminator"},{"address":46240,"text":"compare with terminator 2"},{"address":46242,"text":"loop if not terminator 2"},{"address":46244,"text":"compare with \""},{"address":46246,"text":"branch if \" (carry set if = !)"},{"address":46248,"text":"clear carry for add (only if [EOL] terminated string)"},{"address":46249,"text":"save length in FAC1 exponent"},{"address":46251,"text":"copy length to A"},{"address":46252,"text":"add string start low byte"},{"address":46254,"text":"save string end low byte"},{"address":46256,"text":"get string start high byte"},{"address":46258,"text":"branch if no low byte overflow"},{"address":46260,"text":"else increment high byte"},{"address":46261,"text":"save string end high byte"},{"address":46263,"text":"get string start high byte"},{"address":46265,"text":"branch if in utility area"},{"address":46267,"text":"compare with input buffer memory high byte"},{"address":46269,"text":"branch if not in input buffer memory\nstring in input buffer or utility area, move to string\nmemory"},{"address":46271,"text":"copy length to A"},{"address":46272,"text":"copy descriptor pointer and make string space A bytes long"},{"address":46275,"text":"get string start low byte"},{"address":46277,"text":"get string start high byte"},{"address":46279,"text":"store string A bytes long from XY to utility pointer\ncheck for space on descriptor stack then ...\nput string address and length on descriptor stack and update stack pointers"},{"address":46282,"text":"get the descriptor stack pointer"},{"address":46284,"text":"compare it with the maximum + 1"},{"address":46286,"text":"if there is space on the string stack continue\nelse do string too complex error"},{"address":46288,"text":"error $19, string too complex error"},{"address":46290,"text":"do error #X then warm start\nput string address and length on descriptor stack and update stack pointers"},{"address":46293,"text":"get the string length"},{"address":46295,"text":"put it on the string stack"},{"address":46297,"text":"get the string pointer low byte"},{"address":46299,"text":"put it on the string stack"},{"address":46301,"text":"get the string pointer high byte"},{"address":46303,"text":"put it on the string stack"},{"address":46305,"text":"clear Y"},{"address":46307,"text":"save the string descriptor pointer low byte"},{"address":46309,"text":"save the string descriptor pointer high byte, always $00"},{"address":46311,"text":"clear FAC1 rounding byte"},{"address":46313,"text":"Y = $FF"},{"address":46314,"text":"save the data type flag, $FF = string"},{"address":46316,"text":"save the current descriptor stack item pointer low byte"},{"address":46318,"text":"update the stack pointer"},{"address":46319,"text":"update the stack pointer"},{"address":46320,"text":"update the stack pointer"},{"address":46321,"text":"save the new descriptor stack pointer"},{"address":46324,"text":"clear garbage collected flag (b7)\nmake space for string A long"},{"address":46326,"text":"save string length"},{"address":46327,"text":"complement it"},{"address":46329,"text":"set carry for subtract, two's complement add"},{"address":46330,"text":"add bottom of string space low byte, subtract length"},{"address":46332,"text":"get bottom of string space high byte"},{"address":46334,"text":"skip decrement if no underflow"},{"address":46336,"text":"decrement bottom of string space high byte"},{"address":46337,"text":"compare with end of arrays high byte"},{"address":46339,"text":"do out of memory error if less"},{"address":46341,"text":"if not = skip next test"},{"address":46343,"text":"compare with end of arrays low byte"},{"address":46345,"text":"do out of memory error if less"},{"address":46347,"text":"save bottom of string space low byte"},{"address":46349,"text":"save bottom of string space high byte"},{"address":46351,"text":"save string utility ptr low byte"},{"address":46353,"text":"save string utility ptr high byte"},{"address":46355,"text":"copy low byte to X"},{"address":46356,"text":"get string length back"},{"address":46358,"text":"error code $10, out of memory error"},{"address":46360,"text":"get garbage collected flag"},{"address":46362,"text":"if set then do error code X"},{"address":46364,"text":"else go do garbage collection"},{"address":46367,"text":"flag for garbage collected"},{"address":46369,"text":"set garbage collected flag"},{"address":46371,"text":"pull length"},{"address":46372,"text":"go try again (loop always, length should never be = $00)"},{"address":46374,"text":"get end of memory low byte"},{"address":46376,"text":"get end of memory high byte\nre-run routine from last ending"},{"address":46378,"text":"set bottom of string space low byte"},{"address":46380,"text":"set bottom of string space high byte"},{"address":46382,"text":"clear index"},{"address":46384,"text":"clear working pointer high byte"},{"address":46386,"text":"clear working pointer low byte"},{"address":46388,"text":"get end of arrays low byte"},{"address":46390,"text":"get end of arrays high byte"},{"address":46392,"text":"save as highest uncollected string pointer low byte"},{"address":46394,"text":"save as highest uncollected string pointer high byte"},{"address":46396,"text":"set descriptor stack pointer"},{"address":46398,"text":"clear X"},{"address":46400,"text":"save descriptor stack pointer low byte"},{"address":46402,"text":"save descriptor stack pointer high byte ($00)"},{"address":46404,"text":"compare with descriptor stack pointer"},{"address":46406,"text":"branch if ="},{"address":46408,"text":"check string salvageability"},{"address":46411,"text":"loop always\ndone stacked strings, now do string variables"},{"address":46413,"text":"set step size = $07, collecting variables"},{"address":46415,"text":"save garbage collection step size"},{"address":46417,"text":"get start of variables low byte"},{"address":46419,"text":"get start of variables high byte"},{"address":46421,"text":"save as pointer low byte"},{"address":46423,"text":"save as pointer high byte"},{"address":46425,"text":"compare end of variables high byte,\nstart of arrays high byte"},{"address":46427,"text":"branch if no high byte match"},{"address":46429,"text":"else compare end of variables low byte,\nstart of arrays low byte"},{"address":46431,"text":"branch if = variable memory end"},{"address":46433,"text":"check variable salvageability"},{"address":46436,"text":"loop always\ndone string variables, now do string arrays"},{"address":46438,"text":"save start of arrays low byte as working pointer"},{"address":46440,"text":"save start of arrays high byte as working pointer"},{"address":46442,"text":"set step size, collecting descriptors"},{"address":46444,"text":"save step size"},{"address":46446,"text":"get pointer low byte"},{"address":46448,"text":"get pointer high byte"},{"address":46450,"text":"compare with end of arrays high byte"},{"address":46452,"text":"branch if not at end"},{"address":46454,"text":"else compare with end of arrays low byte"},{"address":46456,"text":"branch if not at end"},{"address":46458,"text":"collect string, tidy up and exit if at end ??"},{"address":46461,"text":"save pointer low byte"},{"address":46463,"text":"save pointer high byte"},{"address":46465,"text":"set index"},{"address":46467,"text":"get array name first byte"},{"address":46469,"text":"copy it"},{"address":46470,"text":"increment index"},{"address":46471,"text":"get array name second byte"},{"address":46473,"text":"push the flags"},{"address":46474,"text":"increment index"},{"address":46475,"text":"get array size low byte"},{"address":46477,"text":"add start of this array low byte"},{"address":46479,"text":"save start of next array low byte"},{"address":46481,"text":"increment index"},{"address":46482,"text":"get array size high byte"},{"address":46484,"text":"add start of this array high byte"},{"address":46486,"text":"save start of next array high byte"},{"address":46488,"text":"restore the flags"},{"address":46489,"text":"skip if not string array\nwas possibly string array so ..."},{"address":46491,"text":"get name first byte back"},{"address":46492,"text":"skip if not string array"},{"address":46494,"text":"increment index"},{"address":46495,"text":"get # of dimensions"},{"address":46497,"text":"clear index"},{"address":46499,"text":"*2"},{"address":46500,"text":"+5 (array header size)"},{"address":46502,"text":"add pointer low byte"},{"address":46504,"text":"save pointer low byte"},{"address":46506,"text":"branch if no rollover"},{"address":46508,"text":"else increment pointer hgih byte"},{"address":46510,"text":"get pointer high byte"},{"address":46512,"text":"compare pointer high byte with end of this array high byte"},{"address":46514,"text":"branch if not there yet"},{"address":46516,"text":"compare pointer low byte with end of this array low byte"},{"address":46518,"text":"if at end of this array go check next array"},{"address":46520,"text":"check string salvageability"},{"address":46523,"text":"loop\ncheck variable salvageability"},{"address":46525,"text":"get variable name first byte"},{"address":46527,"text":"add step and exit if not string"},{"address":46529,"text":"increment index"},{"address":46530,"text":"get variable name second byte"},{"address":46532,"text":"add step and exit if not string"},{"address":46534,"text":"increment index\ncheck string salvageability"},{"address":46535,"text":"get string length"},{"address":46537,"text":"add step and exit if null string"},{"address":46539,"text":"increment index"},{"address":46540,"text":"get string pointer low byte"},{"address":46542,"text":"copy to X"},{"address":46543,"text":"increment index"},{"address":46544,"text":"get string pointer high byte"},{"address":46546,"text":"compare string pointer high byte with bottom of string\nspace high byte"},{"address":46548,"text":"if bottom of string space greater go test against highest\nuncollected string"},{"address":46550,"text":"if bottom of string space less string has been collected\nso go update pointers, step to next and return\nhigh bytes were equal so test low bytes"},{"address":46552,"text":"compare string pointer low byte with bottom of string\nspace low byte"},{"address":46554,"text":"if bottom of string space less string has been collected\nso go update pointers, step to next and return\nelse test string against highest uncollected string so far"},{"address":46556,"text":"compare string pointer high byte with highest uncollected\nstring high byte"},{"address":46558,"text":"if highest uncollected string is greater then go update\npointers, step to next and return"},{"address":46560,"text":"if highest uncollected string is less then go set this\nstring as highest uncollected so far\nhigh bytes were equal so test low bytes"},{"address":46562,"text":"compare string pointer low byte with highest uncollected\nstring low byte"},{"address":46564,"text":"if highest uncollected string is greater then go update\npointers, step to next and return\nelse set current string as highest uncollected string"},{"address":46566,"text":"save string pointer low byte as highest uncollected string\nlow byte"},{"address":46568,"text":"save string pointer high byte as highest uncollected\nstring high byte"},{"address":46570,"text":"get descriptor pointer low byte"},{"address":46572,"text":"get descriptor pointer high byte"},{"address":46574,"text":"save working pointer high byte"},{"address":46576,"text":"save working pointer low byte"},{"address":46578,"text":"get step size"},{"address":46580,"text":"copy step size"},{"address":46582,"text":"get step size"},{"address":46584,"text":"clear carry for add"},{"address":46585,"text":"add pointer low byte"},{"address":46587,"text":"save pointer low byte"},{"address":46589,"text":"branch if no rollover"},{"address":46591,"text":"else increment pointer high byte"},{"address":46593,"text":"get pointer high byte"},{"address":46595,"text":"flag not moved"},{"address":46598,"text":"get working pointer low byte"},{"address":46600,"text":"OR working pointer high byte"},{"address":46602,"text":"exit if nothing to collect"},{"address":46604,"text":"get copied step size"},{"address":46606,"text":"mask step size, $04 for variables, $00 for array or stack"},{"address":46608,"text":"\u003e\u003e 1"},{"address":46609,"text":"copy to index"},{"address":46610,"text":"save offset to descriptor start"},{"address":46612,"text":"get string length low byte"},{"address":46614,"text":"add string start low byte"},{"address":46616,"text":"set block end low byte"},{"address":46618,"text":"get string start high byte"},{"address":46620,"text":"add carry"},{"address":46622,"text":"set block end high byte"},{"address":46624,"text":"get bottom of string space low byte"},{"address":46626,"text":"get bottom of string space high byte"},{"address":46628,"text":"save destination end low byte"},{"address":46630,"text":"save destination end high byte"},{"address":46632,"text":"open up space in memory, don't set array end. this\ncopies the string from where it is to the end of the\nuncollected string memory"},{"address":46635,"text":"restore offset to descriptor start"},{"address":46637,"text":"increment index to string pointer low byte"},{"address":46638,"text":"get new string pointer low byte"},{"address":46640,"text":"save new string pointer low byte"},{"address":46642,"text":"copy string pointer low byte"},{"address":46643,"text":"increment new string pointer high byte"},{"address":46645,"text":"get new string pointer high byte"},{"address":46647,"text":"increment index to string pointer high byte"},{"address":46648,"text":"save new string pointer high byte"},{"address":46650,"text":"re-run routine from last ending, XA holds new bottom\nof string memory pointer"},{"address":46653,"text":"get descriptor pointer high byte"},{"address":46655,"text":"put on stack"},{"address":46656,"text":"get descriptor pointer low byte"},{"address":46658,"text":"put on stack"},{"address":46659,"text":"get value from line"},{"address":46662,"text":"check if source is string, else do type mismatch"},{"address":46665,"text":"get descriptor pointer low byte back"},{"address":46666,"text":"set pointer low byte"},{"address":46668,"text":"get descriptor pointer high byte back"},{"address":46669,"text":"set pointer high byte"},{"address":46671,"text":"clear index"},{"address":46673,"text":"get length of first string from descriptor"},{"address":46675,"text":"clear carry for add"},{"address":46676,"text":"add length of second string"},{"address":46678,"text":"branch if no overflow"},{"address":46680,"text":"else error $17, string too long error"},{"address":46682,"text":"do error #X then warm start"},{"address":46685,"text":"copy descriptor pointer and make string space A bytes long"},{"address":46688,"text":"copy string from descriptor to utility pointer"},{"address":46691,"text":"get descriptor pointer low byte"},{"address":46693,"text":"get descriptor pointer high byte"},{"address":46695,"text":"pop (YA) descriptor off stack or from top of string space\nreturns with A = length, X = pointer low byte,\nY = pointer high byte"},{"address":46698,"text":"store string from pointer to utility pointer"},{"address":46701,"text":"get descriptor pointer low byte"},{"address":46703,"text":"get descriptor pointer high byte"},{"address":46705,"text":"pop (YA) descriptor off stack or from top of string space\nreturns with A = length, X = pointer low byte,\nY = pointer high byte"},{"address":46708,"text":"check space on descriptor stack then put string address\nand length on descriptor stack and update stack pointers"},{"address":46711,"text":"continue evaluation"},{"address":46714,"text":"clear index"},{"address":46716,"text":"get string length"},{"address":46718,"text":"save it"},{"address":46719,"text":"increment index"},{"address":46720,"text":"get string pointer low byte"},{"address":46722,"text":"copy to X"},{"address":46723,"text":"increment index"},{"address":46724,"text":"get string pointer high byte"},{"address":46726,"text":"copy to Y"},{"address":46727,"text":"get length back"},{"address":46728,"text":"save string pointer low byte"},{"address":46730,"text":"save string pointer high byte\nstore string from pointer to utility pointer"},{"address":46732,"text":"copy length as index"},{"address":46733,"text":"branch if null string"},{"address":46735,"text":"save length"},{"address":46736,"text":"decrement length/index"},{"address":46737,"text":"get byte from string"},{"address":46739,"text":"save byte to destination"},{"address":46741,"text":"copy length/index"},{"address":46742,"text":"loop if not all done yet"},{"address":46744,"text":"restore length"},{"address":46745,"text":"clear carry for add"},{"address":46746,"text":"add string utility ptr low byte"},{"address":46748,"text":"save string utility ptr low byte"},{"address":46750,"text":"branch if no rollover"},{"address":46752,"text":"increment string utility ptr high byte"},{"address":46755,"text":"check if source is string, else do type mismatch\npop string off descriptor stack, or from top of string space\nreturns with A = length, X = pointer low byte, Y = pointer high byte"},{"address":46758,"text":"get descriptor pointer low byte"},{"address":46760,"text":"get descriptor pointer high byte\npop (YA) descriptor off stack or from top of string space\nreturns with A = length, X = pointer low byte, Y = pointer high byte"},{"address":46762,"text":"save string pointer low byte"},{"address":46764,"text":"save string pointer high byte"},{"address":46766,"text":"clean descriptor stack, YA = pointer"},{"address":46769,"text":"save status flags"},{"address":46770,"text":"clear index"},{"address":46772,"text":"get length from string descriptor"},{"address":46774,"text":"put on stack"},{"address":46775,"text":"increment index"},{"address":46776,"text":"get string pointer low byte from descriptor"},{"address":46778,"text":"copy to X"},{"address":46779,"text":"increment index"},{"address":46780,"text":"get string pointer high byte from descriptor"},{"address":46782,"text":"copy to Y"},{"address":46783,"text":"get string length back"},{"address":46784,"text":"restore status"},{"address":46785,"text":"branch if pointer \u003c\u003e last_sl,last_sh"},{"address":46787,"text":"compare with bottom of string space high byte"},{"address":46789,"text":"branch if \u003c\u003e"},{"address":46791,"text":"else compare with bottom of string space low byte"},{"address":46793,"text":"branch if \u003c\u003e"},{"address":46795,"text":"save string length"},{"address":46796,"text":"clear carry for add"},{"address":46797,"text":"add bottom of string space low byte"},{"address":46799,"text":"set bottom of string space low byte"},{"address":46801,"text":"skip increment if no overflow"},{"address":46803,"text":"increment bottom of string space high byte"},{"address":46805,"text":"restore string length"},{"address":46806,"text":"save string pointer low byte"},{"address":46808,"text":"save string pointer high byte"},{"address":46811,"text":"compare high byte with current descriptor stack item\npointer high byte"},{"address":46813,"text":"exit if \u003c\u003e"},{"address":46815,"text":"compare low byte with current descriptor stack item\npointer low byte"},{"address":46817,"text":"exit if \u003c\u003e"},{"address":46819,"text":"set descriptor stack pointer"},{"address":46821,"text":"update last string pointer low byte"},{"address":46823,"text":"save current descriptor stack item pointer low byte"},{"address":46825,"text":"clear high byte"},{"address":46828,"text":"evaluate byte expression, result in X"},{"address":46831,"text":"copy to A"},{"address":46832,"text":"save character"},{"address":46833,"text":"string is single byte"},{"address":46835,"text":"make string space A bytes long"},{"address":46838,"text":"get character back"},{"address":46839,"text":"clear index"},{"address":46841,"text":"save byte in string - byte IS string!"},{"address":46843,"text":"dump return address (skip type check)"},{"address":46844,"text":"dump return address (skip type check)"},{"address":46845,"text":"check space on descriptor stack then put string address\nand length on descriptor stack and update stack pointers"},{"address":46848,"text":"pull string data and byte parameter from stack\nreturn pointer in descriptor, byte in A (and X), Y=0"},{"address":46851,"text":"compare byte parameter with string length"},{"address":46853,"text":"clear A"},{"address":46854,"text":"branch if string length \u003e byte parameter"},{"address":46856,"text":"else make parameter = length"},{"address":46858,"text":"copy to byte parameter copy"},{"address":46859,"text":"clear string start offset"},{"address":46860,"text":"save string start offset"},{"address":46861,"text":"copy byte parameter (or string length if \u003c)"},{"address":46862,"text":"save string length"},{"address":46863,"text":"make string space A bytes long"},{"address":46866,"text":"get descriptor pointer low byte"},{"address":46868,"text":"get descriptor pointer high byte"},{"address":46870,"text":"pop (YA) descriptor off stack or from top of string space\nreturns with A = length, X = pointer low byte,\nY = pointer high byte"},{"address":46873,"text":"get string length back"},{"address":46874,"text":"copy length to Y"},{"address":46875,"text":"get string start offset back"},{"address":46876,"text":"clear carry for add"},{"address":46877,"text":"add start offset to string start pointer low byte"},{"address":46879,"text":"save string start pointer low byte"},{"address":46881,"text":"branch if no overflow"},{"address":46883,"text":"else increment string start pointer high byte"},{"address":46885,"text":"copy length to A"},{"address":46886,"text":"store string from pointer to utility pointer"},{"address":46889,"text":"check space on descriptor stack then put string address\nand length on descriptor stack and update stack pointers"},{"address":46892,"text":"pull string data and byte parameter from stack\nreturn pointer in descriptor, byte in A (and X), Y=0"},{"address":46895,"text":"clear carry for add-1"},{"address":46896,"text":"subtract string length"},{"address":46898,"text":"invert it (A=LEN(expression$)-l)"},{"address":46900,"text":"go do rest of LEFT$()"},{"address":46903,"text":"set default length = 255"},{"address":46905,"text":"save default length"},{"address":46907,"text":"scan memory"},{"address":46910,"text":"compare with \")\""},{"address":46912,"text":"branch if = \")\" (skip second byte get)"},{"address":46914,"text":"scan for \",\", else do syntax error then warm start"},{"address":46917,"text":"get byte parameter"},{"address":46920,"text":"pull string data and byte parameter from stack\nreturn pointer in descriptor, byte in A (and X), Y=0"},{"address":46923,"text":"if null do illegal quantity error then warm start"},{"address":46925,"text":"decrement start index"},{"address":46926,"text":"copy to A"},{"address":46927,"text":"save string start offset"},{"address":46928,"text":"clear carry for sub-1"},{"address":46929,"text":"clear output string length"},{"address":46931,"text":"subtract string length"},{"address":46933,"text":"if start\u003estring length go do null string"},{"address":46935,"text":"complement -length"},{"address":46937,"text":"compare byte parameter"},{"address":46939,"text":"if length\u003eremaining string go do RIGHT$"},{"address":46941,"text":"get length byte"},{"address":46943,"text":"go do string copy, branch always"},{"address":46945,"text":"scan for \")\", else do syntax error then warm start"},{"address":46948,"text":"pull return address low byte"},{"address":46949,"text":"save return address low byte"},{"address":46950,"text":"pull return address high byte"},{"address":46951,"text":"save return address high byte"},{"address":46953,"text":"dump call to function vector low byte"},{"address":46954,"text":"dump call to function vector high byte"},{"address":46955,"text":"pull byte parameter"},{"address":46956,"text":"copy byte parameter to X"},{"address":46957,"text":"pull string pointer low byte"},{"address":46958,"text":"save it"},{"address":46960,"text":"pull string pointer high byte"},{"address":46961,"text":"save it"},{"address":46963,"text":"get return address high byte"},{"address":46965,"text":"back on stack"},{"address":46966,"text":"get return address low byte"},{"address":46967,"text":"back on stack"},{"address":46968,"text":"clear index"},{"address":46970,"text":"copy byte parameter"},{"address":46972,"text":"evaluate string, get length in A (and Y)"},{"address":46975,"text":"convert Y to byte in FAC1 and return"},{"address":46978,"text":"evaluate string"},{"address":46981,"text":"set data type = numeric"},{"address":46983,"text":"clear data type flag, $FF = string, $00 = numeric"},{"address":46985,"text":"copy length to Y"},{"address":46987,"text":"evaluate string, get length in A (and Y)"},{"address":46990,"text":"if null do illegal quantity error then warm start"},{"address":46992,"text":"set index to first character"},{"address":46994,"text":"get byte"},{"address":46996,"text":"copy to Y"},{"address":46997,"text":"convert Y to byte in FAC1 and return"},{"address":47000,"text":"do illegal quantity error then warm start"},{"address":47003,"text":"increment and scan memory"},{"address":47006,"text":"evaluate expression and check is numeric, else do\ntype mismatch"},{"address":47009,"text":"evaluate integer expression, sign check"},{"address":47012,"text":"get FAC1 mantissa 3"},{"address":47014,"text":"if not null do illegal quantity error then warm start"},{"address":47016,"text":"get FAC1 mantissa 4"},{"address":47018,"text":"scan memory and return"},{"address":47021,"text":"evaluate string, get length in A (and Y)"},{"address":47024,"text":"branch if not null string\nstring was null so set result = $00"},{"address":47026,"text":"clear FAC1 exponent and sign and return"},{"address":47029,"text":"get BASIC execute pointer low byte"},{"address":47031,"text":"get BASIC execute pointer high byte"},{"address":47033,"text":"save BASIC execute pointer low byte"},{"address":47035,"text":"save BASIC execute pointer high byte"},{"address":47037,"text":"get string pointer low byte"},{"address":47039,"text":"save BASIC execute pointer low byte"},{"address":47041,"text":"clear carry for add"},{"address":47042,"text":"add string length"},{"address":47044,"text":"save string end low byte"},{"address":47046,"text":"get string pointer high byte"},{"address":47048,"text":"save BASIC execute pointer high byte"},{"address":47050,"text":"branch if no high byte increment"},{"address":47052,"text":"increment string end high byte"},{"address":47053,"text":"save string end high byte"},{"address":47055,"text":"set index to $00"},{"address":47057,"text":"get string end byte"},{"address":47059,"text":"push it"},{"address":47060,"text":"clear A"},{"address":47061,"text":"terminate string with $00"},{"address":47063,"text":"scan memory"},{"address":47066,"text":"get FAC1 from string"},{"address":47069,"text":"restore string end byte"},{"address":47070,"text":"clear index"},{"address":47072,"text":"put string end byte back"},{"address":47074,"text":"get BASIC execute pointer low byte back"},{"address":47076,"text":"get BASIC execute pointer high byte back"},{"address":47078,"text":"save BASIC execute pointer low byte"},{"address":47080,"text":"save BASIC execute pointer high byte"},{"address":47083,"text":"evaluate expression and check is numeric, else do\ntype mismatch"},{"address":47086,"text":"convert FAC_1 to integer in temporary integer"},{"address":47089,"text":"scan for \",\", else do syntax error then warm start"},{"address":47092,"text":"get byte parameter and return"},{"address":47095,"text":"get FAC1 sign"},{"address":47097,"text":"if -ve do illegal quantity error then warm start"},{"address":47099,"text":"get FAC1 exponent"},{"address":47101,"text":"compare with exponent = 2^16"},{"address":47103,"text":"if \u003e= do illegal quantity error then warm start"},{"address":47105,"text":"convert FAC1 floating to fixed"},{"address":47108,"text":"get FAC1 mantissa 3"},{"address":47110,"text":"get FAC1 mantissa 4"},{"address":47112,"text":"save temporary integer low byte"},{"address":47114,"text":"save temporary integer high byte"},{"address":47117,"text":"get line number high byte"},{"address":47119,"text":"save line number high byte"},{"address":47120,"text":"get line number low byte"},{"address":47122,"text":"save line number low byte"},{"address":47123,"text":"convert FAC_1 to integer in temporary integer"},{"address":47126,"text":"clear index"},{"address":47128,"text":"read byte"},{"address":47130,"text":"copy byte to A"},{"address":47131,"text":"pull byte"},{"address":47132,"text":"restore line number low byte"},{"address":47134,"text":"pull byte"},{"address":47135,"text":"restore line number high byte"},{"address":47137,"text":"convert Y to byte in FAC_1 and return"},{"address":47140,"text":"get parameters for POKE/WAIT"},{"address":47143,"text":"copy byte to A"},{"address":47144,"text":"clear index"},{"address":47146,"text":"write byte"},{"address":47149,"text":"get parameters for POKE/WAIT"},{"address":47152,"text":"save byte"},{"address":47154,"text":"clear mask"},{"address":47156,"text":"scan memory"},{"address":47159,"text":"skip if no third argument"},{"address":47161,"text":"scan for \",\" and get byte, else syntax error then\nwarm start"},{"address":47164,"text":"save EOR argument"},{"address":47166,"text":"clear index"},{"address":47168,"text":"get byte via temporary integer (address)"},{"address":47170,"text":"EOR with second argument       (mask)"},{"address":47172,"text":"AND with first argument        (byte)"},{"address":47174,"text":"loop if result is zero"},{"address":47177,"text":"set 0.5 pointer low byte"},{"address":47179,"text":"set 0.5 pointer high byte"},{"address":47181,"text":"add (AY) to FAC1"},{"address":47184,"text":"unpack memory (AY) into FAC2"},{"address":47187,"text":"get FAC1 sign (b7)"},{"address":47189,"text":"complement it"},{"address":47191,"text":"save FAC1 sign (b7)"},{"address":47193,"text":"EOR with FAC2 sign (b7)"},{"address":47195,"text":"save sign compare (FAC1 EOR FAC2)"},{"address":47197,"text":"get FAC1 exponent"},{"address":47199,"text":"add FAC2 to FAC1 and return"},{"address":47202,"text":"shift FACX A times right (\u003e8 shifts)"},{"address":47205,"text":"go subtract mantissas"},{"address":47207,"text":"unpack memory (AY) into FAC2"},{"address":47210,"text":"branch if FAC1 is not zero"},{"address":47212,"text":"FAC1 was zero so copy FAC2 to FAC1 and return\nFAC1 is non zero"},{"address":47215,"text":"get FAC1 rounding byte"},{"address":47217,"text":"save as FAC2 rounding byte"},{"address":47219,"text":"set index to FAC2 exponent address"},{"address":47221,"text":"get FAC2 exponent"},{"address":47223,"text":"copy exponent"},{"address":47224,"text":"exit if zero"},{"address":47226,"text":"set carry for subtract"},{"address":47227,"text":"subtract FAC1 exponent"},{"address":47229,"text":"if equal go add mantissas"},{"address":47231,"text":"if FAC2 \u003c FAC1 then go shift FAC2 right\nelse FAC2 \u003e FAC1"},{"address":47233,"text":"save FAC1 exponent"},{"address":47235,"text":"get FAC2 sign (b7)"},{"address":47237,"text":"save FAC1 sign (b7)"},{"address":47239,"text":"complement A"},{"address":47241,"text":"+1, twos complement, carry is set"},{"address":47243,"text":"clear Y"},{"address":47245,"text":"clear FAC2 rounding byte"},{"address":47247,"text":"set index to FAC1 exponent address"},{"address":47249,"text":"branch always\nFAC2 \u003c FAC1"},{"address":47251,"text":"clear Y"},{"address":47253,"text":"clear FAC1 rounding byte"},{"address":47255,"text":"compare exponent diff with $F9"},{"address":47257,"text":"branch if range $79-$F8"},{"address":47259,"text":"copy exponent difference to Y"},{"address":47260,"text":"get FAC1 rounding byte"},{"address":47262,"text":"shift FAC? mantissa 1"},{"address":47264,"text":"shift FACX Y times right\nexponents are equal now do mantissa subtract"},{"address":47267,"text":"test sign compare (FAC1 EOR FAC2)"},{"address":47269,"text":"if = add FAC2 mantissa to FAC1 mantissa and return"},{"address":47271,"text":"set the Y index to FAC1 exponent address"},{"address":47273,"text":"compare X to FAC2 exponent address"},{"address":47275,"text":"if = continue, Y = FAC1, X = FAC2"},{"address":47277,"text":"else set the Y index to FAC2 exponent address\nsubtract the smaller from the bigger (take the sign of\nthe bigger)"},{"address":47279,"text":"set carry for subtract"},{"address":47280,"text":"ones complement A"},{"address":47282,"text":"add FAC2 rounding byte"},{"address":47284,"text":"save FAC1 rounding byte"},{"address":47286,"text":"get FACY mantissa 4"},{"address":47289,"text":"subtract FACX mantissa 4"},{"address":47291,"text":"save FAC1 mantissa 4"},{"address":47293,"text":"get FACY mantissa 3"},{"address":47296,"text":"subtract FACX mantissa 3"},{"address":47298,"text":"save FAC1 mantissa 3"},{"address":47300,"text":"get FACY mantissa 2"},{"address":47303,"text":"subtract FACX mantissa 2"},{"address":47305,"text":"save FAC1 mantissa 2"},{"address":47307,"text":"get FACY mantissa 1"},{"address":47310,"text":"subtract FACX mantissa 1"},{"address":47312,"text":"save FAC1 mantissa 1"},{"address":47314,"text":"branch if number is +ve"},{"address":47316,"text":"negate FAC1"},{"address":47319,"text":"clear Y"},{"address":47321,"text":"clear A"},{"address":47322,"text":"clear carry for add"},{"address":47323,"text":"get FAC1 mantissa 1"},{"address":47325,"text":"if not zero normalise FAC1"},{"address":47327,"text":"get FAC1 mantissa 2"},{"address":47329,"text":"save FAC1 mantissa 1"},{"address":47331,"text":"get FAC1 mantissa 3"},{"address":47333,"text":"save FAC1 mantissa 2"},{"address":47335,"text":"get FAC1 mantissa 4"},{"address":47337,"text":"save FAC1 mantissa 3"},{"address":47339,"text":"get FAC1 rounding byte"},{"address":47341,"text":"save FAC1 mantissa 4"},{"address":47343,"text":"clear FAC1 rounding byte"},{"address":47345,"text":"add x to exponent offset"},{"address":47347,"text":"compare with $20, max offset, all bits would be = 0"},{"address":47349,"text":"loop if not max"},{"address":47351,"text":"clear A"},{"address":47353,"text":"set FAC1 exponent"},{"address":47355,"text":"save FAC1 sign (b7)"},{"address":47358,"text":"add FAC2 rounding byte"},{"address":47360,"text":"save FAC1 rounding byte"},{"address":47362,"text":"get FAC1 mantissa 4"},{"address":47364,"text":"add FAC2 mantissa 4"},{"address":47366,"text":"save FAC1 mantissa 4"},{"address":47368,"text":"get FAC1 mantissa 3"},{"address":47370,"text":"add FAC2 mantissa 3"},{"address":47372,"text":"save FAC1 mantissa 3"},{"address":47374,"text":"get FAC1 mantissa 2"},{"address":47376,"text":"add FAC2 mantissa 2"},{"address":47378,"text":"save FAC1 mantissa 2"},{"address":47380,"text":"get FAC1 mantissa 1"},{"address":47382,"text":"add FAC2 mantissa 1"},{"address":47384,"text":"save FAC1 mantissa 1"},{"address":47386,"text":"test and normalise FAC1 for C=0/1"},{"address":47389,"text":"add 1 to exponent offset"},{"address":47391,"text":"shift FAC1 rounding byte"},{"address":47393,"text":"shift FAC1 mantissa 4"},{"address":47395,"text":"shift FAC1 mantissa 3"},{"address":47397,"text":"shift FAC1 mantissa 2"},{"address":47399,"text":"shift FAC1 mantissa 1\nnormalise FAC1"},{"address":47401,"text":"loop if not normalised"},{"address":47403,"text":"set carry for subtract"},{"address":47404,"text":"subtract FAC1 exponent"},{"address":47406,"text":"branch if underflow (set result = $0)"},{"address":47408,"text":"complement exponent"},{"address":47410,"text":"+1 (twos complement)"},{"address":47412,"text":"save FAC1 exponent\ntest and normalise FAC1 for C=0/1"},{"address":47414,"text":"exit if no overflow\nnormalise FAC1 for C=1"},{"address":47416,"text":"increment FAC1 exponent"},{"address":47418,"text":"if zero do overflow error then warm start"},{"address":47420,"text":"shift FAC1 mantissa 1"},{"address":47422,"text":"shift FAC1 mantissa 2"},{"address":47424,"text":"shift FAC1 mantissa 3"},{"address":47426,"text":"shift FAC1 mantissa 4"},{"address":47428,"text":"shift FAC1 rounding byte"},{"address":47431,"text":"get FAC1 sign (b7)"},{"address":47433,"text":"complement it"},{"address":47435,"text":"save FAC1 sign (b7)\ntwos complement FAC1 mantissa"},{"address":47437,"text":"get FAC1 mantissa 1"},{"address":47439,"text":"complement it"},{"address":47441,"text":"save FAC1 mantissa 1"},{"address":47443,"text":"get FAC1 mantissa 2"},{"address":47445,"text":"complement it"},{"address":47447,"text":"save FAC1 mantissa 2"},{"address":47449,"text":"get FAC1 mantissa 3"},{"address":47451,"text":"complement it"},{"address":47453,"text":"save FAC1 mantissa 3"},{"address":47455,"text":"get FAC1 mantissa 4"},{"address":47457,"text":"complement it"},{"address":47459,"text":"save FAC1 mantissa 4"},{"address":47461,"text":"get FAC1 rounding byte"},{"address":47463,"text":"complement it"},{"address":47465,"text":"save FAC1 rounding byte"},{"address":47467,"text":"increment FAC1 rounding byte"},{"address":47469,"text":"exit if no overflow\nincrement FAC1 mantissa"},{"address":47471,"text":"increment FAC1 mantissa 4"},{"address":47473,"text":"finished if no rollover"},{"address":47475,"text":"increment FAC1 mantissa 3"},{"address":47477,"text":"finished if no rollover"},{"address":47479,"text":"increment FAC1 mantissa 2"},{"address":47481,"text":"finished if no rollover"},{"address":47483,"text":"increment FAC1 mantissa 1"},{"address":47486,"text":"error $0F, overflow error"},{"address":47488,"text":"do error #X then warm start"},{"address":47491,"text":"set the offset to FACtemp"},{"address":47493,"text":"get FACX mantissa 4"},{"address":47495,"text":"save as FAC1 rounding byte"},{"address":47497,"text":"get FACX mantissa 3"},{"address":47499,"text":"save FACX mantissa 4"},{"address":47501,"text":"get FACX mantissa 2"},{"address":47503,"text":"save FACX mantissa 3"},{"address":47505,"text":"get FACX mantissa 1"},{"address":47507,"text":"save FACX mantissa 2"},{"address":47509,"text":"get FAC1 overflow byte"},{"address":47511,"text":"save FACX mantissa 1\nshift FACX -A times right (\u003e 8 shifts)"},{"address":47513,"text":"add 8 to shift count"},{"address":47515,"text":"go do 8 shift if still -ve"},{"address":47517,"text":"go do 8 shift if zero"},{"address":47519,"text":"else subtract 8 again"},{"address":47521,"text":"save count to Y"},{"address":47522,"text":"get FAC1 rounding byte"},{"address":47526,"text":"shift FACX mantissa 1"},{"address":47528,"text":"branch if +ve"},{"address":47530,"text":"this sets b7 eventually"},{"address":47532,"text":"shift FACX mantissa 1 (correct for ASL)"},{"address":47534,"text":"shift FACX mantissa 1 (put carry in b7)\nshift FACX Y times right"},{"address":47536,"text":"shift FACX mantissa 2"},{"address":47538,"text":"shift FACX mantissa 3"},{"address":47540,"text":"shift FACX mantissa 4"},{"address":47542,"text":"shift FACX rounding byte"},{"address":47543,"text":"increment exponent diff"},{"address":47544,"text":"branch if range adjust not complete"},{"address":47546,"text":"just clear it"},{"address":47594,"text":"test sign and zero"},{"address":47597,"text":"if zero do illegal quantity error then warm start"},{"address":47599,"text":"skip error if +ve"},{"address":47601,"text":"do illegal quantity error then warm start"},{"address":47604,"text":"get FAC1 exponent"},{"address":47606,"text":"normalise it"},{"address":47608,"text":"save it"},{"address":47609,"text":"set exponent to zero"},{"address":47611,"text":"save FAC1 exponent"},{"address":47613,"text":"pointer to 1/root 2 low byte"},{"address":47615,"text":"pointer to 1/root 2 high byte"},{"address":47617,"text":"add (AY) to FAC1 (1/root2)"},{"address":47620,"text":"pointer to root 2 low byte"},{"address":47622,"text":"pointer to root 2 high byte"},{"address":47624,"text":"convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))"},{"address":47627,"text":"pointer to 1 low byte"},{"address":47629,"text":"pointer to 1 high byte"},{"address":47631,"text":"subtract FAC1 ((root2/(x+(1/root2)))-1) from (AY)"},{"address":47634,"text":"pointer to series for LOG(n) low byte"},{"address":47636,"text":"pointer to series for LOG(n) high byte"},{"address":47638,"text":"^2 then series evaluation"},{"address":47641,"text":"pointer to -0.5 low byte"},{"address":47643,"text":"pointer to -0.5 high byte"},{"address":47645,"text":"add (AY) to FAC1"},{"address":47648,"text":"restore FAC1 exponent"},{"address":47649,"text":"evaluate new ASCII digit"},{"address":47652,"text":"pointer to LOG(2) low byte"},{"address":47654,"text":"pointer to LOG(2) high byte"},{"address":47656,"text":"unpack memory (AY) into FAC2"},{"address":47659,"text":"multiply FAC1 by FAC2 ??"},{"address":47661,"text":"exit if zero"},{"address":47664,"text":"test and adjust accumulators"},{"address":47667,"text":"clear A"},{"address":47669,"text":"clear temp mantissa 1"},{"address":47671,"text":"clear temp mantissa 2"},{"address":47673,"text":"clear temp mantissa 3"},{"address":47675,"text":"clear temp mantissa 4"},{"address":47677,"text":"get FAC1 rounding byte"},{"address":47679,"text":"go do shift/add FAC2"},{"address":47682,"text":"get FAC1 mantissa 4"},{"address":47684,"text":"go do shift/add FAC2"},{"address":47687,"text":"get FAC1 mantissa 3"},{"address":47689,"text":"go do shift/add FAC2"},{"address":47692,"text":"get FAC1 mantissa 2"},{"address":47694,"text":"go do shift/add FAC2"},{"address":47697,"text":"get FAC1 mantissa 1"},{"address":47699,"text":"go do shift/add FAC2"},{"address":47702,"text":"copy temp to FAC1, normalise and return"},{"address":47705,"text":"branch if byte \u003c\u003e zero"},{"address":47707,"text":"shift FCAtemp \u003c\u003c A+8 times\nelse do shift and add"},{"address":47710,"text":"shift byte"},{"address":47711,"text":"set top bit (mark for 8 times)"},{"address":47713,"text":"copy result"},{"address":47714,"text":"skip next if bit was zero"},{"address":47716,"text":"clear carry for add"},{"address":47717,"text":"get temp mantissa 4"},{"address":47719,"text":"add FAC2 mantissa 4"},{"address":47721,"text":"save temp mantissa 4"},{"address":47723,"text":"get temp mantissa 3"},{"address":47725,"text":"add FAC2 mantissa 3"},{"address":47727,"text":"save temp mantissa 3"},{"address":47729,"text":"get temp mantissa 2"},{"address":47731,"text":"add FAC2 mantissa 2"},{"address":47733,"text":"save temp mantissa 2"},{"address":47735,"text":"get temp mantissa 1"},{"address":47737,"text":"add FAC2 mantissa 1"},{"address":47739,"text":"save temp mantissa 1"},{"address":47741,"text":"shift temp mantissa 1"},{"address":47743,"text":"shift temp mantissa 2"},{"address":47745,"text":"shift temp mantissa 3"},{"address":47747,"text":"shift temp mantissa 4"},{"address":47749,"text":"shift temp rounding byte"},{"address":47751,"text":"get byte back"},{"address":47752,"text":"shift byte"},{"address":47753,"text":"loop if all bits not done"},{"address":47756,"text":"save pointer low byte"},{"address":47758,"text":"save pointer high byte"},{"address":47760,"text":"5 bytes to get (0-4)"},{"address":47762,"text":"get mantissa 4"},{"address":47764,"text":"save FAC2 mantissa 4"},{"address":47766,"text":"decrement index"},{"address":47767,"text":"get mantissa 3"},{"address":47769,"text":"save FAC2 mantissa 3"},{"address":47771,"text":"decrement index"},{"address":47772,"text":"get mantissa 2"},{"address":47774,"text":"save FAC2 mantissa 2"},{"address":47776,"text":"decrement index"},{"address":47777,"text":"get mantissa 1 + sign"},{"address":47779,"text":"save FAC2 sign (b7)"},{"address":47781,"text":"EOR with FAC1 sign (b7)"},{"address":47783,"text":"save sign compare (FAC1 EOR FAC2)"},{"address":47785,"text":"recover FAC2 sign (b7)"},{"address":47787,"text":"set 1xxx xxx (set normal bit)"},{"address":47789,"text":"save FAC2 mantissa 1"},{"address":47791,"text":"decrement index"},{"address":47792,"text":"get exponent byte"},{"address":47794,"text":"save FAC2 exponent"},{"address":47796,"text":"get FAC1 exponent"},{"address":47799,"text":"get FAC2 exponent"},{"address":47801,"text":"branch if FAC2 = $00 (handle underflow)"},{"address":47803,"text":"clear carry for add"},{"address":47804,"text":"add FAC1 exponent"},{"address":47806,"text":"branch if sum of exponents \u003c $0100"},{"address":47808,"text":"do overflow error"},{"address":47810,"text":"clear carry for the add"},{"address":47812,"text":"if +ve go handle underflow"},{"address":47814,"text":"adjust exponent"},{"address":47816,"text":"save FAC1 exponent"},{"address":47818,"text":"branch if not zero"},{"address":47820,"text":"save FAC1 sign and return"},{"address":47823,"text":"get sign compare (FAC1 EOR FAC2)"},{"address":47825,"text":"save FAC1 sign (b7)"},{"address":47828,"text":"get FAC1 sign (b7)"},{"address":47830,"text":"complement it"},{"address":47832,"text":"do overflow error\nhandle underflow"},{"address":47834,"text":"pop return address low byte"},{"address":47835,"text":"pop return address high byte"},{"address":47836,"text":"clear FAC1 exponent and sign and return"},{"address":47839,"text":"do overflow error then warm start"},{"address":47842,"text":"round and copy FAC1 to FAC2"},{"address":47845,"text":"copy exponent (set the flags)"},{"address":47846,"text":"exit if zero"},{"address":47848,"text":"clear carry for add"},{"address":47849,"text":"add two to exponent (*4)"},{"address":47851,"text":"do overflow error if \u003e $FF\nFAC1 = (FAC1 + FAC2) * 2"},{"address":47853,"text":"clear byte"},{"address":47855,"text":"clear sign compare (FAC1 EOR FAC2)"},{"address":47857,"text":"add FAC2 to FAC1 (*5)"},{"address":47860,"text":"increment FAC1 exponent (*10)"},{"address":47862,"text":"if exponent now zero go do overflow error"},{"address":47870,"text":"round and copy FAC1 to FAC2"},{"address":47873,"text":"set 10 pointer low byte"},{"address":47875,"text":"set 10 pointer high byte"},{"address":47877,"text":"clear sign"},{"address":47879,"text":"save sign compare (FAC1 EOR FAC2)"},{"address":47881,"text":"unpack memory (AY) into FAC1"},{"address":47884,"text":"do FAC2/FAC1\nPerform divide-by"},{"address":47887,"text":"unpack memory (AY) into FAC2"},{"address":47890,"text":"if zero go do /0 error"},{"address":47892,"text":"round FAC1"},{"address":47895,"text":"clear A"},{"address":47897,"text":"set carry for subtract"},{"address":47898,"text":"subtract FAC1 exponent (2s complement)"},{"address":47900,"text":"save FAC1 exponent"},{"address":47902,"text":"test and adjust accumulators"},{"address":47905,"text":"increment FAC1 exponent"},{"address":47907,"text":"if zero do overflow error"},{"address":47909,"text":"set index to FAC temp"},{"address":47911,"text":"set byte"},{"address":47913,"text":"get FAC2 mantissa 1"},{"address":47915,"text":"compare FAC1 mantissa 1"},{"address":47917,"text":"branch if \u003c\u003e"},{"address":47919,"text":"get FAC2 mantissa 2"},{"address":47921,"text":"compare FAC1 mantissa 2"},{"address":47923,"text":"branch if \u003c\u003e"},{"address":47925,"text":"get FAC2 mantissa 3"},{"address":47927,"text":"compare FAC1 mantissa 3"},{"address":47929,"text":"branch if \u003c\u003e"},{"address":47931,"text":"get FAC2 mantissa 4"},{"address":47933,"text":"compare FAC1 mantissa 4"},{"address":47935,"text":"save FAC2-FAC1 compare status"},{"address":47936,"text":"shift byte"},{"address":47937,"text":"skip next if no carry"},{"address":47939,"text":"increment index to FAC temp"},{"address":47948,"text":"restore FAC2-FAC1 compare status"},{"address":47949,"text":"if FAC2 \u003e= FAC1 then do subtract\nFAC2 = FAC2*2"},{"address":47951,"text":"shift FAC2 mantissa 4"},{"address":47953,"text":"shift FAC2 mantissa 3"},{"address":47955,"text":"shift FAC2 mantissa 2"},{"address":47957,"text":"shift FAC2 mantissa 1"},{"address":47959,"text":"loop with no compare"},{"address":47961,"text":"loop with compare"},{"address":47963,"text":"loop with no compare, branch always"},{"address":47965,"text":"save FAC2-FAC1 compare status"},{"address":47966,"text":"get FAC2 mantissa 4"},{"address":47968,"text":"subtract FAC1 mantissa 4"},{"address":47970,"text":"save FAC2 mantissa 4"},{"address":47972,"text":"get FAC2 mantissa 3"},{"address":47974,"text":"subtract FAC1 mantissa 3"},{"address":47976,"text":"save FAC2 mantissa 3"},{"address":47978,"text":"get FAC2 mantissa 2"},{"address":47980,"text":"subtract FAC1 mantissa 2"},{"address":47982,"text":"save FAC2 mantissa 2"},{"address":47984,"text":"get FAC2 mantissa 1"},{"address":47986,"text":"subtract FAC1 mantissa 1"},{"address":47988,"text":"save FAC2 mantissa 1"},{"address":47990,"text":"restore FAC2-FAC1 compare status"},{"address":47996,"text":"branch always\ndo A\u003c\u003c6, save as FAC1 rounding byte, normalise and return"},{"address":48004,"text":"save FAC1 rounding byte"},{"address":48006,"text":"dump FAC2-FAC1 compare status"},{"address":48007,"text":"copy temp to FAC1, normalise and return\ndo \"Divide by zero\" error"},{"address":48010,"text":"error $14, divide by zero error"},{"address":48012,"text":"do error #X then warm start"},{"address":48015,"text":"get temp mantissa 1"},{"address":48017,"text":"save FAC1 mantissa 1"},{"address":48019,"text":"get temp mantissa 2"},{"address":48021,"text":"save FAC1 mantissa 2"},{"address":48023,"text":"get temp mantissa 3"},{"address":48025,"text":"save FAC1 mantissa 3"},{"address":48027,"text":"get temp mantissa 4"},{"address":48029,"text":"save FAC1 mantissa 4"},{"address":48031,"text":"normalise FAC1 and return"},{"address":48034,"text":"save pointer low byte"},{"address":48036,"text":"save pointer high byte"},{"address":48038,"text":"5 bytes to do"},{"address":48040,"text":"get fifth byte"},{"address":48042,"text":"save FAC1 mantissa 4"},{"address":48044,"text":"decrement index"},{"address":48045,"text":"get fourth byte"},{"address":48047,"text":"save FAC1 mantissa 3"},{"address":48049,"text":"decrement index"},{"address":48050,"text":"get third byte"},{"address":48052,"text":"save FAC1 mantissa 2"},{"address":48054,"text":"decrement index"},{"address":48055,"text":"get second byte"},{"address":48057,"text":"save FAC1 sign (b7)"},{"address":48059,"text":"set 1xxx xxxx (add normal bit)"},{"address":48061,"text":"save FAC1 mantissa 1"},{"address":48063,"text":"decrement index"},{"address":48064,"text":"get first byte (exponent)"},{"address":48066,"text":"save FAC1 exponent"},{"address":48068,"text":"clear FAC1 rounding byte"},{"address":48071,"text":"set pointer low byte"},{"address":48074,"text":"set pointer low byte"},{"address":48076,"text":"set pointer high byte"},{"address":48078,"text":"pack FAC1 into (XY) and return, branch always"},{"address":48080,"text":"get destination pointer low byte"},{"address":48082,"text":"get destination pointer high byte"},{"address":48084,"text":"round FAC1"},{"address":48087,"text":"save pointer low byte"},{"address":48089,"text":"save pointer high byte"},{"address":48091,"text":"set index"},{"address":48093,"text":"get FAC1 mantissa 4"},{"address":48095,"text":"store in destination"},{"address":48097,"text":"decrement index"},{"address":48098,"text":"get FAC1 mantissa 3"},{"address":48100,"text":"store in destination"},{"address":48102,"text":"decrement index"},{"address":48103,"text":"get FAC1 mantissa 2"},{"address":48105,"text":"store in destination"},{"address":48107,"text":"decrement index"},{"address":48108,"text":"get FAC1 sign (b7)"},{"address":48110,"text":"set bits x111 1111"},{"address":48112,"text":"AND in FAC1 mantissa 1"},{"address":48114,"text":"store in destination"},{"address":48116,"text":"decrement index"},{"address":48117,"text":"get FAC1 exponent"},{"address":48119,"text":"store in destination"},{"address":48121,"text":"clear FAC1 rounding byte"},{"address":48124,"text":"get FAC2 sign (b7)\nsave FAC1 sign and copy ABS(FAC2) to FAC1"},{"address":48126,"text":"save FAC1 sign (b7)"},{"address":48128,"text":"5 bytes to copy"},{"address":48130,"text":"get byte from FAC2,X"},{"address":48132,"text":"save byte at FAC1,X"},{"address":48134,"text":"decrement count"},{"address":48135,"text":"loop if not all done"},{"address":48137,"text":"clear FAC1 rounding byte"},{"address":48140,"text":"round FAC1\ncopy FAC1 to FAC2"},{"address":48143,"text":"6 bytes to copy"},{"address":48145,"text":"get byte from FAC1,X"},{"address":48147,"text":"save byte at FAC2,X"},{"address":48149,"text":"decrement count"},{"address":48150,"text":"loop if not all done"},{"address":48152,"text":"clear FAC1 rounding byte"},{"address":48155,"text":"get FAC1 exponent"},{"address":48157,"text":"exit if zero"},{"address":48159,"text":"shift FAC1 rounding byte"},{"address":48161,"text":"exit if no overflow\nround FAC1 (no check)"},{"address":48163,"text":"increment FAC1 mantissa"},{"address":48166,"text":"branch if no overflow"},{"address":48168,"text":"nornalise FAC1 for C=1 and return"},{"address":48171,"text":"get FAC1 exponent"},{"address":48173,"text":"exit if zero (allready correct SGN(0)=0)"},{"address":48175,"text":"else get FAC1 sign (b7)"},{"address":48177,"text":"move sign bit to carry"},{"address":48178,"text":"set byte for -ve result"},{"address":48180,"text":"return if sign was set (-ve)"},{"address":48182,"text":"else set byte for +ve result"},{"address":48185,"text":"get FAC1 sign, return A = $FF -ve, A = $01 +ve"},{"address":48188,"text":"save FAC1 mantissa 1"},{"address":48190,"text":"clear A"},{"address":48192,"text":"clear FAC1 mantissa 2"},{"address":48194,"text":"set exponent\nset exponent = X, clear FAC1 3 and 4 and normalise"},{"address":48196,"text":"get FAC1 mantissa 1"},{"address":48198,"text":"complement it"},{"address":48200,"text":"sign bit into carry\nset exponent = X, clear mantissa 4 and 3 and normalise FAC1"},{"address":48201,"text":"clear A"},{"address":48203,"text":"clear FAC1 mantissa 4"},{"address":48205,"text":"clear FAC1 mantissa 3\nset exponent = X and normalise FAC1"},{"address":48207,"text":"set FAC1 exponent"},{"address":48209,"text":"clear FAC1 rounding byte"},{"address":48211,"text":"clear FAC1 sign (b7)"},{"address":48213,"text":"do ABS and normalise FAC1"},{"address":48216,"text":"clear FAC1 sign, put zero in b7"},{"address":48219,"text":"save pointer low byte"},{"address":48221,"text":"save pointer high byte"},{"address":48223,"text":"clear index"},{"address":48225,"text":"get exponent"},{"address":48227,"text":"increment index"},{"address":48228,"text":"copy (AY) exponent to X"},{"address":48229,"text":"branch if (AY) exponent=0 and get FAC1 sign\nA = $FF, Cb = 1/-ve A = $01, Cb = 0/+ve"},{"address":48231,"text":"get (AY) mantissa 1, with sign"},{"address":48233,"text":"EOR FAC1 sign (b7)"},{"address":48235,"text":"if signs \u003c\u003e do return A = $FF, Cb = 1/-ve\nA = $01, Cb = 0/+ve and return"},{"address":48237,"text":"compare (AY) exponent with FAC1 exponent"},{"address":48239,"text":"branch if different"},{"address":48241,"text":"get (AY) mantissa 1, with sign"},{"address":48243,"text":"normalise top bit"},{"address":48245,"text":"compare with FAC1 mantissa 1"},{"address":48247,"text":"branch if different"},{"address":48249,"text":"increment index"},{"address":48250,"text":"get mantissa 2"},{"address":48252,"text":"compare with FAC1 mantissa 2"},{"address":48254,"text":"branch if different"},{"address":48256,"text":"increment index"},{"address":48257,"text":"get mantissa 3"},{"address":48259,"text":"compare with FAC1 mantissa 3"},{"address":48261,"text":"branch if different"},{"address":48263,"text":"increment index"},{"address":48264,"text":"set for 1/2 value rounding byte"},{"address":48266,"text":"compare with FAC1 rounding byte (set carry)"},{"address":48268,"text":"get mantissa 4"},{"address":48270,"text":"subtract FAC1 mantissa 4"},{"address":48272,"text":"exit if mantissa 4 equal\ngets here if number \u003c\u003e FAC1"},{"address":48274,"text":"get FAC1 sign (b7)"},{"address":48276,"text":"branch if FAC1 \u003e (AY)"},{"address":48278,"text":"else toggle FAC1 sign"},{"address":48280,"text":"return A = $FF, Cb = 1/-ve A = $01, Cb = 0/+ve"},{"address":48283,"text":"get FAC1 exponent"},{"address":48285,"text":"if zero go clear FAC1 and return"},{"address":48287,"text":"set carry for subtract"},{"address":48288,"text":"subtract maximum integer range exponent"},{"address":48290,"text":"test FAC1 sign (b7)"},{"address":48292,"text":"branch if FAC1 +ve\nFAC1 was -ve"},{"address":48294,"text":"copy subtracted exponent"},{"address":48295,"text":"overflow for -ve number"},{"address":48297,"text":"set FAC1 overflow byte"},{"address":48299,"text":"twos complement FAC1 mantissa"},{"address":48302,"text":"restore subtracted exponent"},{"address":48303,"text":"set index to FAC1"},{"address":48305,"text":"compare exponent result"},{"address":48307,"text":"if \u003c 8 shifts shift FAC1 A times right and return"},{"address":48309,"text":"shift FAC1 A times right (\u003e 8 shifts)"},{"address":48312,"text":"clear FAC1 overflow byte"},{"address":48315,"text":"copy shift count"},{"address":48316,"text":"get FAC1 sign (b7)"},{"address":48318,"text":"mask sign bit only (x000 0000)"},{"address":48320,"text":"shift FAC1 mantissa 1"},{"address":48322,"text":"OR sign in b7 FAC1 mantissa 1"},{"address":48324,"text":"save FAC1 mantissa 1"},{"address":48326,"text":"shift FAC1 Y times right"},{"address":48329,"text":"clear FAC1 overflow byte"},{"address":48332,"text":"get FAC1 exponent"},{"address":48334,"text":"compare with max int"},{"address":48336,"text":"exit if \u003e= (allready int, too big for fractional part!)"},{"address":48338,"text":"convert FAC1 floating to fixed"},{"address":48341,"text":"save FAC1 rounding byte"},{"address":48343,"text":"get FAC1 sign (b7)"},{"address":48345,"text":"save FAC1 sign (b7)"},{"address":48347,"text":"toggle FAC1 sign"},{"address":48349,"text":"shift into carry"},{"address":48350,"text":"set new exponent"},{"address":48352,"text":"save FAC1 exponent"},{"address":48354,"text":"get FAC1 mantissa 4"},{"address":48356,"text":"save FAC1 mantissa 4 for power function"},{"address":48358,"text":"do ABS and normalise FAC1"},{"address":48361,"text":"clear FAC1 mantissa 1"},{"address":48363,"text":"clear FAC1 mantissa 2"},{"address":48365,"text":"clear FAC1 mantissa 3"},{"address":48367,"text":"clear FAC1 mantissa 4"},{"address":48369,"text":"clear Y"},{"address":48371,"text":"clear Y"},{"address":48373,"text":"set index"},{"address":48375,"text":"clear byte"},{"address":48377,"text":"decrement index"},{"address":48378,"text":"loop until numexp to negnum (and FAC1) = $00"},{"address":48380,"text":"branch if first character is numeric"},{"address":48382,"text":"else compare with \"-\""},{"address":48384,"text":"branch if not \"-\""},{"address":48386,"text":"set flag for -ve n (negnum = $FF)"},{"address":48388,"text":"branch always"},{"address":48390,"text":"else compare with \"+\""},{"address":48392,"text":"branch if not \"+\""},{"address":48394,"text":"increment and scan memory"},{"address":48397,"text":"branch if numeric character"},{"address":48399,"text":"else compare with \".\""},{"address":48401,"text":"branch if \".\""},{"address":48403,"text":"else compare with \"E\""},{"address":48405,"text":"branch if not \"E\"\nwas \"E\" so evaluate exponential part"},{"address":48407,"text":"increment and scan memory"},{"address":48410,"text":"branch if numeric character"},{"address":48412,"text":"else compare with token for -"},{"address":48414,"text":"branch if token for -"},{"address":48416,"text":"else compare with \"-\""},{"address":48418,"text":"branch if \"-\""},{"address":48420,"text":"else compare with token for +"},{"address":48422,"text":"branch if token for +"},{"address":48424,"text":"else compare with \"+\""},{"address":48426,"text":"branch if \"+\""},{"address":48428,"text":"branch always"},{"address":48430,"text":"set exponent -ve flag (C, which=1, into b7)"},{"address":48432,"text":"increment and scan memory"},{"address":48435,"text":"branch if numeric character"},{"address":48437,"text":"test exponent -ve flag"},{"address":48439,"text":"if +ve go evaluate exponent\nelse do exponent = -exponent"},{"address":48441,"text":"clear result"},{"address":48443,"text":"set carry for subtract"},{"address":48444,"text":"subtract exponent byte"},{"address":48446,"text":"go evaluate exponent"},{"address":48449,"text":"set decimal point flag"},{"address":48451,"text":"test decimal point flag"},{"address":48453,"text":"branch if only one decimal point so far\nevaluate exponent"},{"address":48455,"text":"get exponent count byte"},{"address":48457,"text":"set carry for subtract"},{"address":48458,"text":"subtract numerator exponent"},{"address":48460,"text":"save exponent count byte"},{"address":48462,"text":"branch if no adjustment"},{"address":48464,"text":"else if +ve go do FAC1*10^expcnt\nelse go do FAC1/10^(0-expcnt)"},{"address":48466,"text":"divide FAC1 by 10"},{"address":48469,"text":"increment exponent count byte"},{"address":48471,"text":"loop until all done"},{"address":48473,"text":"branch always"},{"address":48475,"text":"multiply FAC1 by 10"},{"address":48478,"text":"decrement exponent count byte"},{"address":48480,"text":"loop until all done"},{"address":48482,"text":"get -ve flag"},{"address":48484,"text":"if -ve do - FAC1 and return"},{"address":48487,"text":"do - FAC1\ndo unsigned FAC1*10+number"},{"address":48490,"text":"save character"},{"address":48491,"text":"test decimal point flag"},{"address":48493,"text":"skip exponent increment if not set"},{"address":48495,"text":"else increment number exponent"},{"address":48497,"text":"multiply FAC1 by 10"},{"address":48500,"text":"restore character"},{"address":48501,"text":"set carry for subtract"},{"address":48502,"text":"convert to binary"},{"address":48504,"text":"evaluate new ASCII digit"},{"address":48507,"text":"go do next character\nevaluate new ASCII digit\nmultiply FAC1 by 10 then (ABS) add in new digit"},{"address":48510,"text":"save digit"},{"address":48511,"text":"round and copy FAC1 to FAC2"},{"address":48514,"text":"restore digit"},{"address":48515,"text":"save A as integer byte"},{"address":48518,"text":"get FAC2 sign (b7)"},{"address":48520,"text":"toggle with FAC1 sign (b7)"},{"address":48522,"text":"save sign compare (FAC1 EOR FAC2)"},{"address":48524,"text":"get FAC1 exponent"},{"address":48526,"text":"add FAC2 to FAC1 and return\nevaluate next character of exponential part of number"},{"address":48529,"text":"get exponent count byte"},{"address":48531,"text":"compare with 10 decimal"},{"address":48533,"text":"branch if less"},{"address":48535,"text":"make all -ve exponents = -100 decimal (causes underflow)"},{"address":48537,"text":"test exponent -ve flag"},{"address":48539,"text":"branch if -ve"},{"address":48541,"text":"else do overflow error then warm start"},{"address":48544,"text":"*2"},{"address":48545,"text":"*4"},{"address":48546,"text":"clear carry for add"},{"address":48547,"text":"*5"},{"address":48549,"text":"*10"},{"address":48550,"text":"clear carry for add"},{"address":48551,"text":"set index"},{"address":48553,"text":"add character (will be $30 too much!)"},{"address":48555,"text":"set carry for subtract"},{"address":48556,"text":"convert character to binary"},{"address":48558,"text":"save exponent count byte"},{"address":48560,"text":"go get next character"},{"address":48578,"text":"set \" IN \" pointer low byte"},{"address":48580,"text":"set \" IN \" pointer high byte"},{"address":48582,"text":"print null terminated string"},{"address":48585,"text":"get the current line number high byte"},{"address":48587,"text":"get the current line number low byte"},{"address":48589,"text":"save high byte as FAC1 mantissa1"},{"address":48591,"text":"save low byte as FAC1 mantissa2"},{"address":48593,"text":"set exponent to 16d bits"},{"address":48595,"text":"set integer is +ve flag"},{"address":48596,"text":"set exponent = X, clear mantissa 4 and 3 and normalise\nFAC1"},{"address":48599,"text":"convert FAC1 to string"},{"address":48602,"text":"print null terminated string"},{"address":48605,"text":"set index = 1"},{"address":48607,"text":"character = \" \" (assume +ve)"},{"address":48609,"text":"test FAC1 sign (b7)"},{"address":48611,"text":"branch if +ve"},{"address":48613,"text":"else character = \"-\""},{"address":48615,"text":"save leading character (\" \" or \"-\")"},{"address":48618,"text":"save FAC1 sign (b7)"},{"address":48620,"text":"save index"},{"address":48622,"text":"increment index"},{"address":48623,"text":"set character = \"0\""},{"address":48625,"text":"get FAC1 exponent"},{"address":48627,"text":"branch if FAC1\u003c\u003e0\nexponent was $00 so FAC1 is 0"},{"address":48629,"text":"save last character, [EOT] and exit\nFAC1 is some non zero value"},{"address":48632,"text":"clear (number exponent count)"},{"address":48634,"text":"compare FAC1 exponent with $80 (\u003c1.00000)"},{"address":48636,"text":"branch if 0.5 \u003c= FAC1 \u003c 1.0"},{"address":48638,"text":"branch if FAC1=\u003e1"},{"address":48640,"text":"set 1000000000 pointer low byte"},{"address":48642,"text":"set 1000000000 pointer high byte"},{"address":48644,"text":"do convert AY, FCA1*(AY)"},{"address":48647,"text":"set number exponent count"},{"address":48649,"text":"save number exponent count"},{"address":48651,"text":"set 999999999.25 pointer low byte (max before sci note)"},{"address":48653,"text":"set 999999999.25 pointer high byte"},{"address":48655,"text":"compare FAC1 with (AY)"},{"address":48658,"text":"exit if FAC1 = (AY)"},{"address":48660,"text":"go do /10 if FAC1 \u003e (AY)\nFAC1 \u003c (AY)"},{"address":48662,"text":"set 99999999.90625 pointer low byte"},{"address":48664,"text":"set 99999999.90625 pointer high byte"},{"address":48666,"text":"compare FAC1 with (AY)"},{"address":48669,"text":"branch if FAC1 = (AY) (allow decimal places)"},{"address":48671,"text":"branch if FAC1 \u003e (AY) (no decimal places)\nFAC1 \u003c= (AY)"},{"address":48673,"text":"multiply FAC1 by 10"},{"address":48676,"text":"decrement number exponent count"},{"address":48678,"text":"go test again, branch always"},{"address":48680,"text":"divide FAC1 by 10"},{"address":48683,"text":"increment number exponent count"},{"address":48685,"text":"go test again, branch always\nnow we have just the digits to do"},{"address":48687,"text":"add 0.5 to FAC1 (round FAC1)"},{"address":48690,"text":"convert FAC1 floating to fixed"},{"address":48693,"text":"set default digits before dp = 1"},{"address":48695,"text":"get number exponent count"},{"address":48697,"text":"clear carry for add"},{"address":48698,"text":"up to 9 digits before point"},{"address":48700,"text":"if -ve then 1 digit before dp"},{"address":48702,"text":"A\u003e=$0B if n\u003e=1E9"},{"address":48704,"text":"branch if \u003e= $0B\ncarry is clear"},{"address":48706,"text":"take 1 from digit count"},{"address":48708,"text":"copy to X"},{"address":48709,"text":"set exponent adjust"},{"address":48711,"text":"set carry for subtract"},{"address":48712,"text":"-2"},{"address":48714,"text":"save exponent adjust"},{"address":48716,"text":"save digits before dp count"},{"address":48718,"text":"copy to A"},{"address":48719,"text":"branch if no digits before dp"},{"address":48721,"text":"branch if digits before dp"},{"address":48723,"text":"get output string index"},{"address":48725,"text":"character \".\""},{"address":48727,"text":"increment index"},{"address":48728,"text":"save to output string"},{"address":48734,"text":"character \"0\""},{"address":48736,"text":"increment index"},{"address":48737,"text":"save to output string"},{"address":48740,"text":"save output string index"},{"address":48742,"text":"clear index (point to 100,000)"},{"address":48746,"text":"get FAC1 mantissa 4"},{"address":48748,"text":"clear carry for add"},{"address":48749,"text":"add byte 4, least significant"},{"address":48752,"text":"save FAC1 mantissa4"},{"address":48754,"text":"get FAC1 mantissa 3"},{"address":48756,"text":"add byte 3"},{"address":48759,"text":"save FAC1 mantissa3"},{"address":48761,"text":"get FAC1 mantissa 2"},{"address":48763,"text":"add byte 2"},{"address":48766,"text":"save FAC1 mantissa2"},{"address":48768,"text":"get FAC1 mantissa 1"},{"address":48770,"text":"add byte 1, most significant"},{"address":48773,"text":"save FAC1 mantissa1"},{"address":48775,"text":"increment the digit, set the sign on the test sense bit"},{"address":48776,"text":"if the carry is set go test if the result was positive\nelse the result needs to be negative"},{"address":48778,"text":"not -ve so try again"},{"address":48780,"text":"else done so return the digit"},{"address":48782,"text":"not +ve so try again\nelse done so return the digit"},{"address":48784,"text":"copy the digit"},{"address":48785,"text":"if Cb=0 just use it"},{"address":48787,"text":"else make the 2's complement .."},{"address":48789,"text":".. and subtract it from 10"},{"address":48791,"text":"add \"0\"-1 to result"},{"address":48793,"text":"increment .."},{"address":48794,"text":".. index to.."},{"address":48795,"text":".. next less .."},{"address":48796,"text":".. power of ten"},{"address":48797,"text":"save current variable pointer low byte"},{"address":48799,"text":"get output string index"},{"address":48801,"text":"increment output string index"},{"address":48802,"text":"copy character to X"},{"address":48803,"text":"mask out top bit"},{"address":48805,"text":"save to output string"},{"address":48808,"text":"decrement # of characters before the dp"},{"address":48810,"text":"branch if still characters to do\nelse output the point"},{"address":48812,"text":"character \".\""},{"address":48814,"text":"increment output string index"},{"address":48815,"text":"save to output string"},{"address":48818,"text":"save output string index"},{"address":48820,"text":"get current variable pointer low byte"},{"address":48822,"text":"get character back"},{"address":48823,"text":"toggle the test sense bit"},{"address":48825,"text":"clear the digit"},{"address":48827,"text":"copy it to the new digit"},{"address":48830,"text":"if at the max exit the digit loop"},{"address":48834,"text":"loop if not at the max\nnow remove trailing zeroes"},{"address":48836,"text":"restore the output string index"},{"address":48838,"text":"get character from output string"},{"address":48841,"text":"decrement output string index"},{"address":48842,"text":"compare with \"0\""},{"address":48844,"text":"loop until non \"0\" character found"},{"address":48846,"text":"compare with \".\""},{"address":48848,"text":"branch if was dp\nrestore last character"},{"address":48850,"text":"increment output string index"},{"address":48851,"text":"character \"+\""},{"address":48853,"text":"get exponent count"},{"address":48855,"text":"if zero go set null terminator and exit\nexponent isn't zero so write exponent"},{"address":48857,"text":"branch if exponent count +ve"},{"address":48859,"text":"clear A"},{"address":48861,"text":"set carry for subtract"},{"address":48862,"text":"subtract exponent count adjust (convert -ve to +ve)"},{"address":48864,"text":"copy exponent count to X"},{"address":48865,"text":"character \"-\""},{"address":48867,"text":"save to output string"},{"address":48870,"text":"character \"E\""},{"address":48872,"text":"save exponent sign to output string"},{"address":48875,"text":"get exponent count back"},{"address":48876,"text":"one less than \"0\" character"},{"address":48878,"text":"set carry for subtract"},{"address":48879,"text":"increment 10's character"},{"address":48880,"text":"subtract 10 from exponent count"},{"address":48882,"text":"loop while still \u003e= 0"},{"address":48884,"text":"add character \":\" ($30+$0A, result is 10 less that value)"},{"address":48886,"text":"save to output string"},{"address":48889,"text":"copy 10's character"},{"address":48890,"text":"save to output string"},{"address":48893,"text":"set null terminator"},{"address":48895,"text":"save to output string"},{"address":48898,"text":"go set string pointer (AY) and exit, branch always\nsave last character, [EOT] and exit"},{"address":48900,"text":"save last character to output string\nset null terminator and exit"},{"address":48903,"text":"set null terminator"},{"address":48905,"text":"save after last character\nset string pointer (AY) and exit"},{"address":48908,"text":"set result string pointer low byte"},{"address":48910,"text":"set result string pointer high byte"},{"address":49009,"text":"round and copy FAC1 to FAC2"},{"address":49012,"text":"set 0.5 pointer low address"},{"address":49014,"text":"set 0.5 pointer high address"},{"address":49016,"text":"unpack memory (AY) into FAC1"},{"address":49019,"text":"perform EXP()"},{"address":49021,"text":"get FAC2 exponent"},{"address":49023,"text":"branch if FAC2\u003c\u003e0"},{"address":49025,"text":"clear FAC1 exponent and sign and return"},{"address":49028,"text":"set destination pointer low byte"},{"address":49030,"text":"set destination pointer high byte"},{"address":49032,"text":"pack FAC1 into (XY)"},{"address":49035,"text":"get FAC2 sign (b7)"},{"address":49037,"text":"branch if FAC2\u003e0\nelse FAC2 is -ve and can only be raised to an\ninteger power which gives an x + j0 result"},{"address":49039,"text":"perform INT()"},{"address":49042,"text":"set source pointer low byte"},{"address":49044,"text":"set source pointer high byte"},{"address":49046,"text":"compare FAC1 with (AY)"},{"address":49049,"text":"branch if FAC1 \u003c\u003e (AY) to allow Function Call error\nthis will leave FAC1 -ve and cause a Function Call\nerror when LOG() is called"},{"address":49051,"text":"clear sign b7"},{"address":49052,"text":"get FAC1 mantissa 4 from INT() function as sign in\nY for possible later negation, b0 only needed"},{"address":49054,"text":"save FAC1 sign and copy ABS(FAC2) to FAC1"},{"address":49057,"text":"copy sign back .."},{"address":49058,"text":".. and save it"},{"address":49059,"text":"perform LOG()"},{"address":49062,"text":"set pointer low byte"},{"address":49064,"text":"set pointer high byte"},{"address":49066,"text":"do convert AY, FCA1*(AY)"},{"address":49069,"text":"perform EXP()"},{"address":49072,"text":"pull sign from stack"},{"address":49073,"text":"b0 is to be tested"},{"address":49074,"text":"if no bit then exit\ndo - FAC1"},{"address":49076,"text":"get FAC1 exponent"},{"address":49078,"text":"exit if FAC1_e = $00"},{"address":49080,"text":"get FAC1 sign (b7)"},{"address":49082,"text":"complement it"},{"address":49084,"text":"save FAC1 sign (b7)"},{"address":49133,"text":"set 1.443 pointer low byte"},{"address":49135,"text":"set 1.443 pointer high byte"},{"address":49137,"text":"do convert AY, FCA1*(AY)"},{"address":49140,"text":"get FAC1 rounding byte"},{"address":49142,"text":"+$50/$100"},{"address":49144,"text":"skip rounding if no carry"},{"address":49146,"text":"round FAC1 (no check)"},{"address":49149,"text":"continue EXP()"},{"address":57344,"text":"save FAC2 rounding byte"},{"address":57346,"text":"copy FAC1 to FAC2"},{"address":57349,"text":"get FAC1 exponent"},{"address":57351,"text":"compare with EXP limit (256d)"},{"address":57353,"text":"branch if less"},{"address":57355,"text":"handle overflow and underflow"},{"address":57358,"text":"perform INT()"},{"address":57361,"text":"get mantissa 4 from INT()"},{"address":57363,"text":"clear carry for add"},{"address":57364,"text":"normalise +1"},{"address":57366,"text":"if $00 result has overflowed so go handle it"},{"address":57368,"text":"set carry for subtract"},{"address":57369,"text":"exponent now correct"},{"address":57371,"text":"save FAC2 exponent\nswap FAC1 and FAC2"},{"address":57372,"text":"4 bytes to do"},{"address":57374,"text":"get FAC2,X"},{"address":57376,"text":"get FAC1,X"},{"address":57378,"text":"save FAC1,X"},{"address":57380,"text":"save FAC2,X"},{"address":57382,"text":"decrement count/index"},{"address":57383,"text":"loop if not all done"},{"address":57385,"text":"get FAC2 rounding byte"},{"address":57387,"text":"save as FAC1 rounding byte"},{"address":57389,"text":"perform subtraction, FAC2 from FAC1"},{"address":57392,"text":"do - FAC1"},{"address":57395,"text":"set counter pointer low byte"},{"address":57397,"text":"set counter pointer high byte"},{"address":57399,"text":"go do series evaluation"},{"address":57402,"text":"clear A"},{"address":57404,"text":"clear sign compare (FAC1 EOR FAC2)"},{"address":57406,"text":"get saved FAC2 exponent"},{"address":57407,"text":"test and adjust accumulators"},{"address":57411,"text":"save count pointer low byte"},{"address":57413,"text":"save count pointer high byte"},{"address":57415,"text":"pack FAC1 into $57"},{"address":57418,"text":"set pointer low byte (Y already $00)"},{"address":57420,"text":"do convert AY, FCA1*(AY)"},{"address":57423,"text":"go do series evaluation"},{"address":57426,"text":"pointer to original # low byte"},{"address":57428,"text":"pointer to original # high byte"},{"address":57430,"text":"do convert AY, FCA1*(AY)\ndo series evaluation"},{"address":57433,"text":"save count pointer low byte"},{"address":57435,"text":"save count pointer high byte\ndo series evaluation"},{"address":57437,"text":"pack FAC1 into $5C"},{"address":57440,"text":"get constants count"},{"address":57442,"text":"save constants count"},{"address":57444,"text":"get count pointer low byte"},{"address":57446,"text":"increment it (now constants pointer)"},{"address":57447,"text":"copy it"},{"address":57448,"text":"skip next if no overflow"},{"address":57450,"text":"else increment high byte"},{"address":57452,"text":"save low byte"},{"address":57454,"text":"get high byte"},{"address":57456,"text":"do convert AY, FCA1*(AY)"},{"address":57459,"text":"get constants pointer low byte"},{"address":57461,"text":"get constants pointer high byte"},{"address":57463,"text":"clear carry for add"},{"address":57464,"text":"+5 to low pointer (5 bytes per constant)"},{"address":57466,"text":"skip next if no overflow"},{"address":57468,"text":"increment high byte"},{"address":57469,"text":"save pointer low byte"},{"address":57471,"text":"save pointer high byte"},{"address":57473,"text":"add (AY) to FAC1"},{"address":57476,"text":"set pointer low byte to partial"},{"address":57478,"text":"set pointer high byte to partial"},{"address":57480,"text":"decrement constants count"},{"address":57482,"text":"loop until all done"},{"address":57495,"text":"get FAC1 sign\nreturn A = $FF -ve, A = $01 +ve"},{"address":57498,"text":"if n\u003c0 copy byte swapped FAC1 into RND() seed"},{"address":57500,"text":"if n\u003e0 get next number in RND() sequence\nelse n=0 so get the RND() number from VIA 1 timers"},{"address":57502,"text":"return base address of I/O devices"},{"address":57505,"text":"save pointer low byte"},{"address":57507,"text":"save pointer high byte"},{"address":57509,"text":"set index to T1 low byte"},{"address":57511,"text":"get T1 low byte"},{"address":57513,"text":"save FAC1 mantissa 1"},{"address":57515,"text":"increment index"},{"address":57516,"text":"get T1 high byte"},{"address":57518,"text":"save FAC1 mantissa 3"},{"address":57520,"text":"set index to T2 low byte"},{"address":57522,"text":"get T2 low byte"},{"address":57524,"text":"save FAC1 mantissa 2"},{"address":57526,"text":"increment index"},{"address":57527,"text":"get T2 high byte"},{"address":57529,"text":"save FAC1 mantissa 4"},{"address":57531,"text":"set exponent and exit"},{"address":57534,"text":"set seed pointer low address"},{"address":57536,"text":"set seed pointer high address"},{"address":57538,"text":"unpack memory (AY) into FAC1"},{"address":57541,"text":"set 11879546 pointer low byte"},{"address":57543,"text":"set 11879546 pointer high byte"},{"address":57545,"text":"do convert AY, FCA1*(AY)"},{"address":57548,"text":"set 3.927677739E-8 pointer low byte"},{"address":57550,"text":"set 3.927677739E-8 pointer high byte"},{"address":57552,"text":"add (AY) to FAC1"},{"address":57555,"text":"get FAC1 mantissa 4"},{"address":57557,"text":"get FAC1 mantissa 1"},{"address":57559,"text":"save FAC1 mantissa 4"},{"address":57561,"text":"save FAC1 mantissa 1"},{"address":57563,"text":"get FAC1 mantissa 2"},{"address":57565,"text":"get FAC1 mantissa 3"},{"address":57567,"text":"save FAC1 mantissa 2"},{"address":57569,"text":"save FAC1 mantissa 3"},{"address":57571,"text":"clear byte"},{"address":57573,"text":"clear FAC1 sign (always +ve)"},{"address":57575,"text":"get FAC1 exponent"},{"address":57577,"text":"save FAC1 rounding byte"},{"address":57579,"text":"set exponent = $80"},{"address":57581,"text":"save FAC1 exponent"},{"address":57583,"text":"normalise FAC1"},{"address":57586,"text":"set seed pointer low address"},{"address":57588,"text":"set seed pointer high address"},{"address":57590,"text":"pack FAC1 into (XY)"},{"address":57593,"text":"compare error with $F0"},{"address":57595,"text":"branch if not $F0"},{"address":57597,"text":"set end of memory high byte"},{"address":57599,"text":"set end of memory low byte"},{"address":57601,"text":"clear from start to end and return\nerror was not $F0"},{"address":57604,"text":"copy error #"},{"address":57605,"text":"branch if not $00"},{"address":57607,"text":"else error $1E, break error"},{"address":57609,"text":"do error #X then warm start"},{"address":57612,"text":"output character to channel"},{"address":57615,"text":"if error go handle BASIC I/O error"},{"address":57618,"text":"input character from channel"},{"address":57621,"text":"if error go handle BASIC I/O error"},{"address":57624,"text":"open channel for output"},{"address":57627,"text":"if error go handle BASIC I/O error"},{"address":57630,"text":"open channel for input"},{"address":57633,"text":"if error go handle BASIC I/O error"},{"address":57636,"text":"get character from input device"},{"address":57639,"text":"if error go handle BASIC I/O error"},{"address":57642,"text":"evaluate expression and check is numeric, else do\ntype mismatch"},{"address":57645,"text":"convert FAC_1 to integer in temporary integer"},{"address":57648,"text":"get return address high byte"},{"address":57650,"text":"push as return address"},{"address":57651,"text":"get return address low byte"},{"address":57653,"text":"push as return address"},{"address":57654,"text":"get saved status register"},{"address":57657,"text":"put on stack"},{"address":57658,"text":"get saved A"},{"address":57661,"text":"get saved X"},{"address":57664,"text":"get saved Y"},{"address":57667,"text":"pull processor status"},{"address":57668,"text":"call SYS address\ntail end of SYS code"},{"address":57671,"text":"save status"},{"address":57672,"text":"save returned A"},{"address":57675,"text":"save returned X"},{"address":57678,"text":"save returned Y"},{"address":57681,"text":"restore saved status"},{"address":57682,"text":"save status"},{"address":57686,"text":"get parameters for LOAD/SAVE"},{"address":57689,"text":"get start of variables low byte"},{"address":57691,"text":"get start of variables high byte"},{"address":57693,"text":"index to start of program memory"},{"address":57695,"text":"save RAM to device, A = index to start address, XY = end\naddress low/high"},{"address":57698,"text":"if error go handle BASIC I/O error"},{"address":57701,"text":"flag verify"},{"address":57704,"text":"flag load"},{"address":57706,"text":"set load/verify flag"},{"address":57708,"text":"get parameters for LOAD/SAVE"},{"address":57711,"text":"get load/verify flag"},{"address":57713,"text":"get start of memory low byte"},{"address":57715,"text":"get start of memory high byte"},{"address":57717,"text":"load RAM from a device"},{"address":57720,"text":"if error go handle BASIC I/O error"},{"address":57722,"text":"get load/verify flag"},{"address":57724,"text":"branch if load"},{"address":57726,"text":"error $1C, verify error"},{"address":57728,"text":"read I/O status word"},{"address":57731,"text":"mask for tape read error"},{"address":57733,"text":"branch if no read error"},{"address":57735,"text":"get the BASIC execute pointer low byte\nis this correct ?? won't this mean the \"OK\" prompt\nwhen doing a load from within a program ?"},{"address":57739,"text":"if ?? skip \"OK\" prompt"},{"address":57741,"text":"set \"OK\" pointer low byte"},{"address":57743,"text":"set \"OK\" pointer high byte"},{"address":57745,"text":"print null terminated string"},{"address":57749,"text":"read I/O status word"},{"address":57752,"text":"mask x0xx xxxx, clear read error"},{"address":57754,"text":"branch if no errors"},{"address":57756,"text":"error $1D, load error"},{"address":57758,"text":"do error #X then warm start"},{"address":57761,"text":"get BASIC execute pointer high byte"},{"address":57763,"text":"compare with $02xx"},{"address":57765,"text":"branch if not immediate mode"},{"address":57767,"text":"set start of variables low byte"},{"address":57769,"text":"set start of variables high byte"},{"address":57771,"text":"set \"READY.\" pointer low byte"},{"address":57773,"text":"set \"READY.\" pointer high byte"},{"address":57775,"text":"print null terminated string"},{"address":57778,"text":"reset execution, clear variables, flush stack,\nrebuild BASIC chain and do warm start"},{"address":57781,"text":"set BASIC execute pointer to start of memory - 1"},{"address":57784,"text":"rebuild BASIC line chaining"},{"address":57787,"text":"rebuild BASIC line chaining, do RESTORE and return"},{"address":57790,"text":"get parameters for OPEN/CLOSE"},{"address":57793,"text":"open a logical file"},{"address":57796,"text":"branch if error"},{"address":57799,"text":"get parameters for OPEN/CLOSE"},{"address":57802,"text":"get logical file number"},{"address":57804,"text":"close a specified logical file"},{"address":57807,"text":"exit if no error"},{"address":57809,"text":"go handle BASIC I/O error"},{"address":57812,"text":"clear file name length"},{"address":57814,"text":"clear the filename"},{"address":57817,"text":"set default device number, cassette"},{"address":57819,"text":"set default command"},{"address":57821,"text":"set logical, first and second addresses"},{"address":57824,"text":"exit function if [EOT] or \":\""},{"address":57827,"text":"set filename"},{"address":57830,"text":"exit function if [EOT] or \":\""},{"address":57833,"text":"scan and get byte, else do syntax error then warm start"},{"address":57836,"text":"clear command"},{"address":57838,"text":"save device number"},{"address":57840,"text":"set logical, first and second addresses"},{"address":57843,"text":"exit function if [EOT] or \":\""},{"address":57846,"text":"scan and get byte, else do syntax error then warm start"},{"address":57849,"text":"copy command to A"},{"address":57850,"text":"copy command to Y"},{"address":57851,"text":"get device number back"},{"address":57853,"text":"set logical, first and second addresses and return"},{"address":57856,"text":"scan for \",byte\", else do syntax error then warm start"},{"address":57859,"text":"get byte parameter and return\nexit function if [EOT] or \":\""},{"address":57862,"text":"scan memory"},{"address":57865,"text":"branch if not [EOL] or \":\""},{"address":57867,"text":"dump return address low byte"},{"address":57868,"text":"dump return address high byte"},{"address":57870,"text":"scan for \",\", else do syntax error then warm start"},{"address":57873,"text":"scan memory"},{"address":57876,"text":"exit if following byte"},{"address":57878,"text":"else do syntax error then warm start"},{"address":57881,"text":"clear the filename length"},{"address":57883,"text":"clear the filename"},{"address":57886,"text":"scan for valid byte, else do syntax error then warm start"},{"address":57889,"text":"get byte parameter, logical file number"},{"address":57892,"text":"save logical file number"},{"address":57894,"text":"copy logical file number to A"},{"address":57895,"text":"set default device number, cassette"},{"address":57897,"text":"set default command"},{"address":57899,"text":"set logical, first and second addresses"},{"address":57902,"text":"exit function if [EOT] or \":\""},{"address":57905,"text":"scan and get byte, else do syntax error then warm start"},{"address":57908,"text":"save device number"},{"address":57910,"text":"clear command"},{"address":57912,"text":"get logical file number"},{"address":57914,"text":"compare device number with screen"},{"address":57916,"text":"branch if less than screen"},{"address":57918,"text":"else decrement command"},{"address":57919,"text":"set logical, first and second addresses"},{"address":57922,"text":"exit function if [EOT] or \":\""},{"address":57925,"text":"scan and get byte, else do syntax error then warm start"},{"address":57928,"text":"copy command to A"},{"address":57929,"text":"copy command to Y"},{"address":57930,"text":"get device number"},{"address":57932,"text":"get logical file number"},{"address":57934,"text":"set logical, first and second addresses"},{"address":57937,"text":"exit function if [EOT] or \":\""},{"address":57940,"text":"scan for \",byte\", else do syntax error then warm start"},{"address":57943,"text":"evaluate expression"},{"address":57946,"text":"evaluate string"},{"address":57949,"text":"get string pointer low byte"},{"address":57951,"text":"get string pointer high byte"},{"address":57953,"text":"set the filename and return"},{"address":57956,"text":"set pi/2 pointer low byte"},{"address":57958,"text":"set pi/2 pointer high byte"},{"address":57960,"text":"add (AY) to FAC1"},{"address":57963,"text":"round and copy FAC1 to FAC2"},{"address":57966,"text":"set 2*pi pointer low byte"},{"address":57968,"text":"set 2*pi pointer high byte"},{"address":57970,"text":"get FAC2 sign (b7)"},{"address":57972,"text":"divide by (AY) (X=sign)"},{"address":57975,"text":"round and copy FAC1 to FAC2"},{"address":57978,"text":"perform INT()"},{"address":57981,"text":"clear byte"},{"address":57983,"text":"clear sign compare (FAC1 EOR FAC2)"},{"address":57985,"text":"perform subtraction, FAC2 from FAC1"},{"address":57988,"text":"set 0.25 pointer low byte"},{"address":57990,"text":"set 0.25 pointer high byte"},{"address":57992,"text":"perform subtraction, FAC1 from (AY)"},{"address":57995,"text":"get FAC1 sign (b7)"},{"address":57997,"text":"save FAC1 sign"},{"address":57998,"text":"branch if +ve\nFAC1 sign was -ve"},{"address":58000,"text":"add 0.5 to FAC1 (round FAC1)"},{"address":58003,"text":"get FAC1 sign (b7)"},{"address":58005,"text":"branch if -ve"},{"address":58007,"text":"get the comparison evaluation flag"},{"address":58009,"text":"toggle flag"},{"address":58011,"text":"save the comparison evaluation flag"},{"address":58013,"text":"do - FAC1"},{"address":58016,"text":"set 0.25 pointer low byte"},{"address":58018,"text":"set 0.25 pointer high byte"},{"address":58020,"text":"add (AY) to FAC1"},{"address":58023,"text":"restore FAC1 sign"},{"address":58024,"text":"branch if was +ve\nelse correct FAC1"},{"address":58026,"text":"do - FAC1"},{"address":58029,"text":"set pointer low byte to counter"},{"address":58031,"text":"set pointer high byte to counter"},{"address":58033,"text":"^2 then series evaluation and return"},{"address":58036,"text":"pack FAC1 into $57"},{"address":58039,"text":"clear A"},{"address":58041,"text":"clear the comparison evaluation flag"},{"address":58043,"text":"perform SIN()"},{"address":58046,"text":"set sin(n) pointer low byte"},{"address":58048,"text":"set sin(n) pointer high byte"},{"address":58050,"text":"pack FAC1 into (XY)"},{"address":58053,"text":"set n pointer low byte"},{"address":58055,"text":"set n pointer high byte"},{"address":58057,"text":"unpack memory (AY) into FAC1"},{"address":58060,"text":"clear byte"},{"address":58062,"text":"clear FAC1 sign (b7)"},{"address":58064,"text":"get the comparison evaluation flag"},{"address":58066,"text":"save flag and go do series evaluation"},{"address":58069,"text":"set sin(n) pointer low byte"},{"address":58071,"text":"set sin(n) pointer high byte"},{"address":58073,"text":"convert AY and do (AY)/FAC1"},{"address":58076,"text":"save comparison flag"},{"address":58077,"text":"add 0.25, ^2 then series evaluation"},{"address":58126,"text":"get FAC1 sign (b7)"},{"address":58128,"text":"save sign"},{"address":58129,"text":"branch if +ve"},{"address":58131,"text":"else do - FAC1"},{"address":58134,"text":"get FAC1 exponent"},{"address":58136,"text":"push exponent"},{"address":58137,"text":"compare with 1"},{"address":58139,"text":"branch if FAC1 \u003c 1"},{"address":58141,"text":"pointer to 1 low byte"},{"address":58143,"text":"pointer to 1 high byte"},{"address":58145,"text":"convert AY and do (AY)/FAC1"},{"address":58148,"text":"pointer to series low byte"},{"address":58150,"text":"pointer to series high byte"},{"address":58152,"text":"^2 then series evaluation"},{"address":58155,"text":"restore old FAC1 exponent"},{"address":58156,"text":"compare with 1"},{"address":58158,"text":"branch if FAC1 \u003c 1"},{"address":58160,"text":"pointer to (pi/2) low byte"},{"address":58162,"text":"pointer to (pi/2) low byte"},{"address":58164,"text":"perform subtraction, FAC1 from (AY)"},{"address":58167,"text":"restore FAC1 sign"},{"address":58168,"text":"exit if was +ve"},{"address":58170,"text":"else do - FAC1 and return"},{"address":58235,"text":"close input and output channels"},{"address":58238,"text":"clear A"},{"address":58240,"text":"set current I/O channel, flag default"},{"address":58242,"text":"flush BASIC stack and clear continue pointer"},{"address":58245,"text":"enable the interrupts"},{"address":58246,"text":"set -ve error, just do warm start"},{"address":58248,"text":"go handle error message, normally $E38B"},{"address":58251,"text":"copy the error number"},{"address":58252,"text":"if -ve go do warm start"},{"address":58254,"text":"else do error #X then warm start"},{"address":58257,"text":"do warm start"},{"address":58260,"text":"initialise the BASIC vector table"},{"address":58263,"text":"initialise the BASIC RAM locations"},{"address":58266,"text":"print the start up message and initialise the memory\npointers\nnot ok ??"},{"address":58269,"text":"value for start stack"},{"address":58271,"text":"set stack pointer"},{"address":58272,"text":"do \"READY.\" warm start, branch always"},{"address":58274,"text":"increment BASIC execute pointer low byte"},{"address":58276,"text":"branch if no carry\nelse"},{"address":58278,"text":"increment BASIC execute pointer high byte\npage 0 initialisation table from $0079\nscan memory"},{"address":58280,"text":"get byte to scan, address set by call routine"},{"address":58283,"text":"compare with \":\""},{"address":58285,"text":"exit if\u003e=\npage 0 initialisation table from $0080\nclear Cb if numeric"},{"address":58287,"text":"compare with \" \""},{"address":58289,"text":"if \" \" go do next"},{"address":58291,"text":"set carry for SBC"},{"address":58292,"text":"subtract \"0\""},{"address":58294,"text":"set carry for SBC"},{"address":58295,"text":"subtract -\"0\"\nclear carry if byte = \"0\"-\"9\""},{"address":58303,"text":"opcode for JMP"},{"address":58305,"text":"save for functions vector jump"},{"address":58307,"text":"save for USR() vector jump\nset USR() vector to illegal quantity error"},{"address":58310,"text":"set USR() vector low byte"},{"address":58312,"text":"set USR() vector high byte"},{"address":58314,"text":"save USR() vector low byte"},{"address":58317,"text":"save USR() vector high byte"},{"address":58320,"text":"set fixed to float vector low byte"},{"address":58322,"text":"set fixed to float vector high byte"},{"address":58324,"text":"save fixed to float vector low byte"},{"address":58326,"text":"save fixed to float vector high byte"},{"address":58328,"text":"set float to fixed vector low byte"},{"address":58330,"text":"set float to fixed vector high byte"},{"address":58332,"text":"save float to fixed vector low byte"},{"address":58334,"text":"save float to fixed vector high byte\ncopy the character get subroutine from $E3A2 to $0074"},{"address":58336,"text":"set the byte count"},{"address":58338,"text":"get a byte from the table"},{"address":58341,"text":"save the byte in page zero"},{"address":58343,"text":"decrement the count"},{"address":58344,"text":"loop if not all done\nclear descriptors, strings, program area and mamory pointers"},{"address":58346,"text":"set the step size, collecting descriptors"},{"address":58348,"text":"save the garbage collection step size"},{"address":58350,"text":"clear A"},{"address":58352,"text":"clear FAC1 overflow byte"},{"address":58354,"text":"clear the current I/O channel, flag default"},{"address":58356,"text":"clear the current descriptor stack item pointer high byte"},{"address":58358,"text":"set X"},{"address":58360,"text":"set the chain link pointer low byte"},{"address":58363,"text":"set the chain link pointer high byte"},{"address":58366,"text":"initial the value for descriptor stack"},{"address":58368,"text":"set descriptor stack pointer"},{"address":58370,"text":"set Cb = 1 to read the bottom of memory"},{"address":58371,"text":"read/set the bottom of memory"},{"address":58374,"text":"save the start of memory low byte"},{"address":58376,"text":"save the start of memory high byte"},{"address":58378,"text":"set Cb = 1 to read the top of memory"},{"address":58379,"text":"read/set the top of memory"},{"address":58382,"text":"save the end of memory low byte"},{"address":58384,"text":"save the end of memory high byte"},{"address":58386,"text":"set the bottom of string space low byte"},{"address":58388,"text":"set the bottom of string space high byte"},{"address":58390,"text":"clear the index"},{"address":58392,"text":"clear the A"},{"address":58393,"text":"clear the the first byte of memory"},{"address":58395,"text":"increment the start of memory low byte"},{"address":58397,"text":"if no rollover skip the high byte increment"},{"address":58399,"text":"increment start of memory high byte"},{"address":58402,"text":"get the start of memory low byte"},{"address":58404,"text":"get the start of memory high byte"},{"address":58406,"text":"check available memory, do out of memory error if no room"},{"address":58409,"text":"set \"**** COMMODORE 64 BASIC V2 ****\" pointer low byte"},{"address":58411,"text":"set \"**** COMMODORE 64 BASIC V2 ****\" pointer high byte"},{"address":58413,"text":"print a null terminated string"},{"address":58416,"text":"get the end of memory low byte"},{"address":58418,"text":"set carry for subtract"},{"address":58419,"text":"subtract the start of memory low byte"},{"address":58421,"text":"copy the result to X"},{"address":58422,"text":"get the end of memory high byte"},{"address":58424,"text":"subtract the start of memory high byte"},{"address":58426,"text":"print XA as unsigned integer"},{"address":58429,"text":"set \" BYTES FREE\" pointer low byte"},{"address":58431,"text":"set \" BYTES FREE\" pointer high byte"},{"address":58433,"text":"print a null terminated string"},{"address":58436,"text":"do NEW, CLEAR, RESTORE and return"},{"address":58451,"text":"set byte count"},{"address":58453,"text":"get byte from table"},{"address":58456,"text":"save byte to RAM"},{"address":58459,"text":"decrement index"},{"address":58460,"text":"loop if more to do"},{"address":58541,"text":"save the flag byte"},{"address":58542,"text":"open channel for output"},{"address":58545,"text":"copy the returned flag byte"},{"address":58546,"text":"restore the alling flag byte"},{"address":58547,"text":"if there is no error skip copying the error flag"},{"address":58549,"text":"else copy the error flag"},{"address":58579,"text":"save the start bit check flag, set start bit received"},{"address":58581,"text":"set the initial parity state"},{"address":58583,"text":"save the receiver parity bit"},{"address":58586,"text":"get the current colour code"},{"address":58589,"text":"save it to the colour RAM"},{"address":58592,"text":"set the number of jiffies to wait"},{"address":58594,"text":"read the stop key column"},{"address":58596,"text":"test for $FF, no keys pressed"},{"address":58597,"text":"if any keys were pressed just exit"},{"address":58599,"text":"compare the wait time with the jiffy clock mid byte"},{"address":58601,"text":"if not there yet go wait some more"},{"address":58624,"text":"get the I/O base address low byte"},{"address":58626,"text":"get the I/O base address high byte"},{"address":58629,"text":"get the x size"},{"address":58631,"text":"get the y size"},{"address":58634,"text":"if read cursor go do read"},{"address":58636,"text":"save the cursor row"},{"address":58638,"text":"save the cursor column"},{"address":58640,"text":"set the screen pointers for the cursor row, column"},{"address":58643,"text":"get the cursor row"},{"address":58645,"text":"get the cursor column"},{"address":58648,"text":"initialise the vic chip"},{"address":58651,"text":"clear A"},{"address":58653,"text":"clear the shift mode switch"},{"address":58656,"text":"clear the cursor blink phase"},{"address":58658,"text":"get the keyboard decode logic pointer low byte"},{"address":58660,"text":"save the keyboard decode logic pointer low byte"},{"address":58663,"text":"get the keyboard decode logic pointer high byte"},{"address":58665,"text":"save the keyboard decode logic pointer high byte"},{"address":58668,"text":"set the maximum size of the keyboard buffer"},{"address":58670,"text":"save the maximum size of the keyboard buffer"},{"address":58673,"text":"save the repeat delay counter"},{"address":58676,"text":"set light blue"},{"address":58678,"text":"save the current colour code"},{"address":58681,"text":"speed 4"},{"address":58683,"text":"save the repeat speed counter"},{"address":58686,"text":"set the cursor flash timing"},{"address":58688,"text":"save the cursor timing countdown"},{"address":58690,"text":"save the cursor enable, $00 = flash cursor"},{"address":58692,"text":"get the screen memory page"},{"address":58695,"text":"set the high bit, flag every line is a logical line start"},{"address":58697,"text":"copy to Y"},{"address":58698,"text":"clear the line start low byte"},{"address":58700,"text":"clear the index"},{"address":58701,"text":"save the start of line X pointer high byte"},{"address":58703,"text":"clear carry for add"},{"address":58704,"text":"add the line length to the low byte"},{"address":58706,"text":"if no rollover skip the high byte increment"},{"address":58708,"text":"else increment the high byte"},{"address":58709,"text":"increment the line index"},{"address":58710,"text":"compare it with the number of lines + 1"},{"address":58712,"text":"loop if not all done"},{"address":58714,"text":"set the end of table marker"},{"address":58716,"text":"mark the end of the table"},{"address":58718,"text":"set the line count, 25 lines to do, 0 to 24"},{"address":58720,"text":"clear screen line X"},{"address":58723,"text":"decrement the count"},{"address":58724,"text":"loop if more to do"},{"address":58726,"text":"clear Y"},{"address":58728,"text":"clear the cursor column"},{"address":58730,"text":"clear the cursor row"},{"address":58732,"text":"get the cursor row"},{"address":58734,"text":"get the cursor column"},{"address":58736,"text":"get start of line X pointer high byte"},{"address":58738,"text":"if it is the logical line start continue"},{"address":58740,"text":"else clear carry for add"},{"address":58741,"text":"add one line length"},{"address":58743,"text":"save the cursor column"},{"address":58745,"text":"decrement the cursor row"},{"address":58746,"text":"loop, branch always"},{"address":58748,"text":"fetch a screen address"},{"address":58751,"text":"set the line length"},{"address":58753,"text":"increment the cursor row"},{"address":58754,"text":"get the start of line X pointer high byte"},{"address":58756,"text":"if logical line start exit"},{"address":58758,"text":"else clear carry for add"},{"address":58759,"text":"add one line length to the current line length"},{"address":58761,"text":"increment the cursor row"},{"address":58762,"text":"loop, branch always"},{"address":58764,"text":"save current screen line length"},{"address":58766,"text":"calculate the pointer to colour RAM and return"},{"address":58769,"text":"compare it with the input cursor row"},{"address":58771,"text":"if there just exit"},{"address":58773,"text":"else go ??"},{"address":58777,"text":"huh"},{"address":58778,"text":"initialise the vic chip"},{"address":58781,"text":"home the cursor and return"},{"address":58784,"text":"set the screen as the output device"},{"address":58786,"text":"save the output device number"},{"address":58788,"text":"set the keyboard as the input device"},{"address":58790,"text":"save the input device number"},{"address":58792,"text":"set the count/index"},{"address":58794,"text":"get a vic ii chip initialisation value"},{"address":58797,"text":"save it to the vic ii chip"},{"address":58800,"text":"decrement the count/index"},{"address":58801,"text":"loop if more to do"},{"address":58804,"text":"get the current character from the buffer"},{"address":58807,"text":"clear the index"},{"address":58809,"text":"get the next character,X from the buffer"},{"address":58812,"text":"save it as the current character,X in the buffer"},{"address":58815,"text":"increment the index"},{"address":58816,"text":"compare it with the keyboard buffer index"},{"address":58818,"text":"loop if more to do"},{"address":58820,"text":"decrement keyboard buffer index"},{"address":58822,"text":"copy the key to A"},{"address":58823,"text":"enable the interrupts"},{"address":58824,"text":"flag got byte"},{"address":58826,"text":"output character"},{"address":58829,"text":"get the keyboard buffer index"},{"address":58831,"text":"cursor enable, $00 = flash cursor, $xx = no flash"},{"address":58833,"text":"screen scrolling flag, $00 = scroll, $xx = no scroll\nthis disables both the cursor flash and the screen scroll\nwhile there are characters in the keyboard buffer"},{"address":58836,"text":"loop if the buffer is empty"},{"address":58838,"text":"disable the interrupts"},{"address":58839,"text":"get the cursor blink phase"},{"address":58841,"text":"if cursor phase skip the overwrite\nelse it is the character phase"},{"address":58843,"text":"get the character under the cursor"},{"address":58845,"text":"get the colour under the cursor"},{"address":58848,"text":"clear Y"},{"address":58850,"text":"clear the cursor blink phase"},{"address":58852,"text":"print character A and colour X"},{"address":58855,"text":"input from the keyboard buffer"},{"address":58858,"text":"compare with [SHIFT][RUN]"},{"address":58860,"text":"if not [SHIFT][RUN] skip the buffer fill\nkeys are [SHIFT][RUN] so put \"LOAD\",$0D,\"RUN\",$0D into\nthe buffer"},{"address":58862,"text":"set the byte count"},{"address":58864,"text":"disable the interrupts"},{"address":58865,"text":"set the keyboard buffer index"},{"address":58867,"text":"get byte from the auto load/run table"},{"address":58870,"text":"save it to the keyboard buffer"},{"address":58873,"text":"decrement the count/index"},{"address":58874,"text":"loop while more to do"},{"address":58876,"text":"loop for the next key, branch always\nwas not [SHIFT][RUN]"},{"address":58878,"text":"compare the key with [CR]"},{"address":58880,"text":"if not [CR] print the character and get the next key\nelse it was [CR]"},{"address":58882,"text":"get the current screen line length"},{"address":58884,"text":"input from keyboard or screen, $xx = screen,\n$00 = keyboard"},{"address":58886,"text":"get the character from the current screen line"},{"address":58888,"text":"compare it with [SPACE]"},{"address":58890,"text":"if not [SPACE] continue"},{"address":58892,"text":"else eliminate the space, decrement end of input line"},{"address":58893,"text":"loop, branch always"},{"address":58895,"text":"increment past the last non space character on line"},{"address":58896,"text":"save the input [EOL] pointer"},{"address":58898,"text":"clear A"},{"address":58900,"text":"clear the screen scrolling flag, $00 = scroll"},{"address":58903,"text":"clear the cursor column"},{"address":58905,"text":"clear the cursor quote flag, $xx = quote, $00 = no quote"},{"address":58907,"text":"get the input cursor row"},{"address":58911,"text":"get the cursor row"},{"address":58913,"text":"find and set the pointers for the start of logical line"},{"address":58916,"text":"compare with input cursor row"},{"address":58920,"text":"get the input cursor column"},{"address":58922,"text":"save the cursor column"},{"address":58924,"text":"compare the cursor column with input [EOL] pointer"},{"address":58926,"text":"if less, cursor is in line, go ??"},{"address":58928,"text":"else the cursor is beyond the line end, branch always"},{"address":58930,"text":"copy Y"},{"address":58931,"text":"save Y"},{"address":58932,"text":"copy X"},{"address":58933,"text":"save X"},{"address":58934,"text":"input from keyboard or screen, $xx = screen,\n$00 = keyboard"},{"address":58936,"text":"if keyboard go wait for key"},{"address":58938,"text":"get the cursor column"},{"address":58940,"text":"get character from the current screen line"},{"address":58942,"text":"save temporary last character"},{"address":58944,"text":"mask key bits"},{"address":58946,"text":"\u003c\u003c temporary last character"},{"address":58948,"text":"test it"},{"address":58950,"text":"branch if not [NO KEY]"},{"address":58956,"text":"get the cursor quote flag, $xx = quote, $00 = no quote"},{"address":58958,"text":"if in quote mode go ??"},{"address":58964,"text":"increment the cursor column"},{"address":58966,"text":"if open quote toggle the cursor quote flag"},{"address":58969,"text":"compare ?? with input [EOL] pointer"},{"address":58971,"text":"if not at line end go ??"},{"address":58973,"text":"clear A"},{"address":58975,"text":"clear input from keyboard or screen, $xx = screen,\n$00 = keyboard"},{"address":58977,"text":"set character [CR]"},{"address":58979,"text":"get the input device number"},{"address":58981,"text":"compare the input device with the screen"},{"address":58983,"text":"if screen go ??"},{"address":58985,"text":"get the output device number"},{"address":58987,"text":"compare the output device with the screen"},{"address":58989,"text":"if screen go ??"},{"address":58991,"text":"output the character"},{"address":58994,"text":"set character [CR]"},{"address":58996,"text":"save character"},{"address":58998,"text":"pull X"},{"address":58999,"text":"restore X"},{"address":59000,"text":"pull Y"},{"address":59001,"text":"restore Y"},{"address":59002,"text":"restore character"},{"address":59010,"text":"flag ok"},{"address":59012,"text":"comapre byte with \""},{"address":59014,"text":"exit if not \""},{"address":59016,"text":"get cursor quote flag, $xx = quote, $00 = no quote"},{"address":59018,"text":"toggle it"},{"address":59020,"text":"save cursor quote flag"},{"address":59022,"text":"restore the \""},{"address":59025,"text":"change to uppercase/graphic"},{"address":59027,"text":"get the reverse flag"},{"address":59029,"text":"branch if not reverse\nelse ..\ninsert reversed character"},{"address":59031,"text":"reverse character"},{"address":59033,"text":"get the insert count"},{"address":59035,"text":"branch if none"},{"address":59037,"text":"else decrement the insert count"},{"address":59039,"text":"get the current colour code"},{"address":59042,"text":"print character A and colour X"},{"address":59045,"text":"advance the cursor\nrestore the registers, set the quote flag and exit"},{"address":59048,"text":"pull Y"},{"address":59049,"text":"restore Y"},{"address":59050,"text":"get the insert count"},{"address":59052,"text":"skip quote flag clear if inserts to do"},{"address":59054,"text":"clear cursor quote flag, $xx = quote, $00 = no quote"},{"address":59056,"text":"pull X"},{"address":59057,"text":"restore X"},{"address":59058,"text":"restore A"},{"address":59060,"text":"enable the interrupts"},{"address":59062,"text":"test for line increment"},{"address":59065,"text":"increment the cursor column"},{"address":59067,"text":"get current screen line length"},{"address":59069,"text":"compare ?? with the cursor column"},{"address":59071,"text":"exit if line length \u003e= cursor column"},{"address":59073,"text":"compare with max length"},{"address":59075,"text":"if at max clear column, back cursor up and do newline"},{"address":59077,"text":"get the autoscroll flag"},{"address":59080,"text":"branch if autoscroll on"},{"address":59082,"text":"else open space on screen"},{"address":59085,"text":"get the cursor row"},{"address":59087,"text":"compare with max + 1"},{"address":59089,"text":"if less than max + 1 go add this row to the current\nlogical line"},{"address":59091,"text":"else scroll the screen"},{"address":59094,"text":"decrement the cursor row"},{"address":59096,"text":"get the cursor row\nadd this row to the current logical line"},{"address":59098,"text":"shift start of line X pointer high byte"},{"address":59100,"text":"shift start of line X pointer high byte back,\nmake next screen line start of logical line, increment line length and set pointers\nclear b7, start of logical line"},{"address":59102,"text":"increment screen row"},{"address":59103,"text":"get start of line X pointer high byte"},{"address":59105,"text":"mark as start of logical line"},{"address":59107,"text":"set start of line X pointer high byte"},{"address":59109,"text":"restore screen row"},{"address":59110,"text":"get current screen line length\nadd one line length and set the pointers for the start of the line"},{"address":59112,"text":"clear carry for add"},{"address":59113,"text":"add one line length"},{"address":59115,"text":"save current screen line length"},{"address":59117,"text":"get start of line X pointer high byte"},{"address":59119,"text":"exit loop if start of logical line"},{"address":59121,"text":"else back up one line"},{"address":59122,"text":"loop if not on first line"},{"address":59124,"text":"fetch a screen address"},{"address":59127,"text":"decrement the cursor row"},{"address":59129,"text":"do newline"},{"address":59132,"text":"clear A"},{"address":59134,"text":"clear the cursor column"},{"address":59137,"text":"get the cursor row"},{"address":59139,"text":"branch if not top row"},{"address":59141,"text":"clear cursor column"},{"address":59143,"text":"dump return address low byte"},{"address":59144,"text":"dump return address high byte"},{"address":59145,"text":"restore registers, set quote flag and exit, branch always"},{"address":59147,"text":"decrement the cursor row"},{"address":59148,"text":"save the cursor row"},{"address":59150,"text":"set the screen pointers for cursor row, column"},{"address":59153,"text":"get current screen line length"},{"address":59155,"text":"save the cursor column"},{"address":59158,"text":"save character"},{"address":59159,"text":"save temporary last character"},{"address":59161,"text":"copy X"},{"address":59162,"text":"save X"},{"address":59163,"text":"copy Y"},{"address":59164,"text":"save Y"},{"address":59165,"text":"clear A"},{"address":59167,"text":"clear input from keyboard or screen, $xx = screen,\n$00 = keyboard"},{"address":59169,"text":"get cursor column"},{"address":59171,"text":"restore last character"},{"address":59173,"text":"branch if unshifted"},{"address":59175,"text":"do shifted characters and return"},{"address":59178,"text":"compare with [CR]"},{"address":59180,"text":"branch if not [CR]"},{"address":59182,"text":"else output [CR] and return"},{"address":59185,"text":"compare with [SPACE]"},{"address":59187,"text":"branch if \u003c [SPACE]"},{"address":59191,"text":"branch if $20 to $5F\ncharacter is $60 or greater"},{"address":59199,"text":"if open quote toggle cursor direct/programmed flag"},{"address":59205,"text":"get the insert count"},{"address":59207,"text":"if no characters to insert continue"},{"address":59209,"text":"insert reversed character"},{"address":59212,"text":"compare the character with [INSERT]/[DELETE]"},{"address":59214,"text":"if not [INSERT]/[DELETE] go ??"},{"address":59219,"text":"back onto the previous line if possible"},{"address":59225,"text":"test for line decrement\nnow close up the line"},{"address":59228,"text":"decrement index to previous character"},{"address":59229,"text":"save the cursor column"},{"address":59231,"text":"calculate the pointer to colour RAM"},{"address":59234,"text":"increment index to next character"},{"address":59235,"text":"get character from current screen line"},{"address":59237,"text":"decrement index to previous character"},{"address":59238,"text":"save character to current screen line"},{"address":59240,"text":"increment index to next character"},{"address":59241,"text":"get colour RAM byte"},{"address":59243,"text":"decrement index to previous character"},{"address":59244,"text":"save colour RAM byte"},{"address":59246,"text":"increment index to next character"},{"address":59247,"text":"compare with current screen line length"},{"address":59249,"text":"loop if not there yet"},{"address":59251,"text":"set [SPACE]"},{"address":59253,"text":"clear last character on current screen line"},{"address":59255,"text":"get the current colour code"},{"address":59258,"text":"save to colour RAM"},{"address":59260,"text":"branch always"},{"address":59262,"text":"get cursor quote flag, $xx = quote, $00 = no quote"},{"address":59264,"text":"branch if not quote mode"},{"address":59266,"text":"insert reversed character"},{"address":59269,"text":"compare with [RVS ON]"},{"address":59271,"text":"if not [RVS ON] skip setting the reverse flag"},{"address":59273,"text":"else set the reverse flag"},{"address":59275,"text":"compare with [CLR HOME]"},{"address":59277,"text":"if not [CLR HOME] continue"},{"address":59279,"text":"home the cursor"},{"address":59282,"text":"compare with [CURSOR RIGHT]"},{"address":59284,"text":"if not [CURSOR RIGHT] go ??"},{"address":59286,"text":"increment the cursor column"},{"address":59287,"text":"test for line increment"},{"address":59290,"text":"save the cursor column"},{"address":59292,"text":"decrement the cursor column"},{"address":59293,"text":"compare cursor column with current screen line length"},{"address":59295,"text":"exit if less\nelse the cursor column is \u003e= the current screen line\nlength so back onto the current line and do a newline"},{"address":59297,"text":"decrement the cursor row"},{"address":59299,"text":"do newline"},{"address":59302,"text":"clear cursor column"},{"address":59304,"text":"save the cursor column"},{"address":59306,"text":"restore the registers, set the quote flag and exit"},{"address":59309,"text":"compare with [CURSOR DOWN]"},{"address":59311,"text":"if not [CURSOR DOWN] go ??"},{"address":59313,"text":"clear carry for add"},{"address":59314,"text":"copy the cursor column"},{"address":59315,"text":"add one line"},{"address":59317,"text":"copy back to Y"},{"address":59318,"text":"increment the cursor row"},{"address":59320,"text":"compare cursor column with current screen line length"},{"address":59322,"text":"if less go save cursor column and exit"},{"address":59324,"text":"if equal go save cursor column and exit\nelse the cursor has moved beyond the end of this line\nso back it up until it's on the start of the logical line"},{"address":59326,"text":"decrement the cursor row"},{"address":59328,"text":"subtract one line"},{"address":59330,"text":"if on previous line exit the loop"},{"address":59332,"text":"else save the cursor column"},{"address":59334,"text":"loop if not at the start of the line"},{"address":59336,"text":"do newline"},{"address":59339,"text":"restore the registers, set the quote flag and exit"},{"address":59342,"text":"set the colour code"},{"address":59345,"text":"go check for special character codes"},{"address":59348,"text":"mask 0xxx xxxx, clear b7"},{"address":59350,"text":"was it $FF before the mask"},{"address":59352,"text":"branch if not"},{"address":59354,"text":"else make it $5E"},{"address":59356,"text":"compare the character with [SPACE]"},{"address":59358,"text":"if \u003c [SPACE] go ??"},{"address":59360,"text":"insert uppercase/graphic character and return\ncharacter was $80 to $9F and is now $00 to $1F"},{"address":59363,"text":"compare with [CR]"},{"address":59365,"text":"if not [CR] continue"},{"address":59367,"text":"else output [CR] and return\nwas not [CR]"},{"address":59370,"text":"get the cursor quote flag, $xx = quote, $00 = no quote"},{"address":59372,"text":"branch if quote mode"},{"address":59374,"text":"compare with [INSERT DELETE]"},{"address":59376,"text":"if not [INSERT DELETE] go ??"},{"address":59378,"text":"get current screen line length"},{"address":59380,"text":"get character from current screen line"},{"address":59382,"text":"compare the character with [SPACE]"},{"address":59384,"text":"if not [SPACE] continue"},{"address":59386,"text":"compare the current column with the cursor column"},{"address":59388,"text":"if not cursor column go open up space on line"},{"address":59390,"text":"compare current column with max line length"},{"address":59392,"text":"if at line end just exit"},{"address":59394,"text":"else open up a space on the screen\nnow open up space on the line to insert a character"},{"address":59397,"text":"get current screen line length"},{"address":59399,"text":"calculate the pointer to colour RAM"},{"address":59402,"text":"decrement the index to previous character"},{"address":59403,"text":"get the character from the current screen line"},{"address":59405,"text":"increment the index to next character"},{"address":59406,"text":"save the character to the current screen line"},{"address":59408,"text":"decrement the index to previous character"},{"address":59409,"text":"get the current screen line colour RAM byte"},{"address":59411,"text":"increment the index to next character"},{"address":59412,"text":"save the current screen line colour RAM byte"},{"address":59414,"text":"decrement the index to the previous character"},{"address":59415,"text":"compare the index with the cursor column"},{"address":59417,"text":"loop if not there yet"},{"address":59419,"text":"set [SPACE]"},{"address":59421,"text":"clear character at cursor position on current screen line"},{"address":59423,"text":"get current colour code"},{"address":59426,"text":"save to cursor position on current screen line colour RAM"},{"address":59428,"text":"increment insert count"},{"address":59430,"text":"restore the registers, set the quote flag and exit"},{"address":59433,"text":"get the insert count"},{"address":59435,"text":"branch if no insert space"},{"address":59437,"text":"change to uppercase/graphic"},{"address":59439,"text":"insert reversed character"},{"address":59442,"text":"compare with [CURSOR UP]"},{"address":59444,"text":"branch if not [CURSOR UP]"},{"address":59446,"text":"get the cursor row"},{"address":59448,"text":"if on the top line go restore the registers, set the\nquote flag and exit"},{"address":59450,"text":"decrement the cursor row"},{"address":59452,"text":"get the cursor column"},{"address":59454,"text":"set carry for subtract"},{"address":59455,"text":"subtract one line length"},{"address":59457,"text":"branch if stepped back to previous line"},{"address":59459,"text":"else save the cursor column .."},{"address":59461,"text":".. and exit, branch always"},{"address":59463,"text":"set the screen pointers for cursor row, column .."},{"address":59466,"text":".. and exit, branch always"},{"address":59468,"text":"compare with [RVS OFF]"},{"address":59470,"text":"if not [RVS OFF] continue"},{"address":59472,"text":"else clear A"},{"address":59474,"text":"clear the reverse flag"},{"address":59476,"text":"compare with [CURSOR LEFT]"},{"address":59478,"text":"if not [CURSOR LEFT] go ??"},{"address":59480,"text":"copy the cursor column"},{"address":59481,"text":"if at start of line go back onto the previous line"},{"address":59483,"text":"test for line decrement"},{"address":59486,"text":"decrement the cursor column"},{"address":59487,"text":"save the cursor column"},{"address":59489,"text":"restore the registers, set the quote flag and exit"},{"address":59492,"text":"back onto the previous line if possible"},{"address":59495,"text":"restore the registers, set the quote flag and exit"},{"address":59498,"text":"compare with [CLR]"},{"address":59500,"text":"if not [CLR] continue"},{"address":59502,"text":"clear the screen"},{"address":59505,"text":"restore the registers, set the quote flag and exit"},{"address":59508,"text":"restore b7, colour can only be black, cyan, magenta\nor yellow"},{"address":59510,"text":"set the colour code"},{"address":59513,"text":"go check for special character codes except fro switch\nto lower case"},{"address":59516,"text":"shift \u003e\u003e input cursor row"},{"address":59518,"text":"get the cursor row"},{"address":59520,"text":"increment the row"},{"address":59521,"text":"compare it with last row + 1"},{"address":59523,"text":"if not last row + 1 skip the screen scroll"},{"address":59525,"text":"else scroll the screen"},{"address":59528,"text":"get start of line X pointer high byte"},{"address":59530,"text":"loop if not start of logical line"},{"address":59532,"text":"save the cursor row"},{"address":59534,"text":"set the screen pointers for cursor row, column and return"},{"address":59537,"text":"clear X"},{"address":59539,"text":"clear the insert count"},{"address":59541,"text":"clear the reverse flag"},{"address":59543,"text":"clear the cursor quote flag, $xx = quote, $00 = no quote"},{"address":59545,"text":"save the cursor column"},{"address":59547,"text":"do newline"},{"address":59550,"text":"restore the registers, set the quote flag and exit"},{"address":59553,"text":"set the count"},{"address":59555,"text":"set the column"},{"address":59557,"text":"compare the column with the cursor column"},{"address":59559,"text":"if at the start of the line go decrement the cursor row\nand exit"},{"address":59561,"text":"else clear carry for add"},{"address":59562,"text":"increment to next line"},{"address":59564,"text":"decrement loop count"},{"address":59565,"text":"loop if more to test"},{"address":59568,"text":"else decrement the cursor row"},{"address":59571,"text":"set the count"},{"address":59573,"text":"set the column"},{"address":59575,"text":"compare the column with the cursor column"},{"address":59577,"text":"if at end of line test and possibly increment cursor row"},{"address":59579,"text":"else clear carry for add"},{"address":59580,"text":"increment to the next line"},{"address":59582,"text":"decrement the loop count"},{"address":59583,"text":"loop if more to test"},{"address":59586,"text":"get the cursor row"},{"address":59588,"text":"compare it with the end of the screen"},{"address":59590,"text":"if at the end of screen just exit"},{"address":59592,"text":"else increment the cursor row"},{"address":59597,"text":"compare the character with a table code"},{"address":59600,"text":"if a match go save the colour and exit"},{"address":59602,"text":"else decrement the index"},{"address":59603,"text":"loop if more to do"},{"address":59606,"text":"save the current colour code"},{"address":59626,"text":"copy the tape buffer start pointer"},{"address":59628,"text":"save it"},{"address":59629,"text":"copy the tape buffer start pointer"},{"address":59631,"text":"save it"},{"address":59632,"text":"copy the tape buffer end pointer"},{"address":59634,"text":"save it"},{"address":59635,"text":"copy the tape buffer end pointer"},{"address":59637,"text":"save it"},{"address":59638,"text":"set to -1 for pre increment loop"},{"address":59640,"text":"decrement the cursor row"},{"address":59642,"text":"decrement the input cursor row"},{"address":59644,"text":"decrement the screen row marker"},{"address":59647,"text":"increment the line number"},{"address":59648,"text":"fetch a screen address, set the start of line X"},{"address":59651,"text":"compare with last line"},{"address":59653,"text":"branch if \u003e= $16"},{"address":59655,"text":"get the start of the next line pointer low byte"},{"address":59658,"text":"save the next line pointer low byte"},{"address":59660,"text":"get the start of the next line pointer high byte"},{"address":59662,"text":"shift the screen line up"},{"address":59665,"text":"loop, branch always"},{"address":59667,"text":"clear screen line X\nnow shift up the start of logical line bits"},{"address":59670,"text":"clear index"},{"address":59672,"text":"get the start of line X pointer high byte"},{"address":59674,"text":"clear the line X start of logical line bit"},{"address":59676,"text":"get the start of the next line pointer high byte"},{"address":59678,"text":"if next line is not a start of line skip the start set"},{"address":59680,"text":"set line X start of logical line bit"},{"address":59682,"text":"set start of line X pointer high byte"},{"address":59684,"text":"increment line number"},{"address":59685,"text":"compare with last line"},{"address":59687,"text":"loop if not last line"},{"address":59689,"text":"get start of last line pointer high byte"},{"address":59691,"text":"mark as start of logical line"},{"address":59693,"text":"set start of last line pointer high byte"},{"address":59695,"text":"get start of first line pointer high byte"},{"address":59697,"text":"if not start of logical line loop back and\nscroll the screen up another line"},{"address":59699,"text":"increment the cursor row"},{"address":59701,"text":"increment screen row marker"},{"address":59704,"text":"set keyboard column c7"},{"address":59706,"text":"save VIA 1 DRA, keyboard column drive"},{"address":59709,"text":"read VIA 1 DRB, keyboard row port"},{"address":59712,"text":"compare with row r2 active, [CTL]"},{"address":59714,"text":"save status"},{"address":59715,"text":"set keyboard column c7"},{"address":59717,"text":"save VIA 1 DRA, keyboard column drive"},{"address":59720,"text":"restore status"},{"address":59721,"text":"skip delay if ??\nfirst time round the inner loop X will be $16"},{"address":59723,"text":"clear delay outer loop count, do this 256 times"},{"address":59725,"text":"waste cycles"},{"address":59726,"text":"decrement inner loop count"},{"address":59727,"text":"loop if not all done"},{"address":59729,"text":"decrement outer loop count"},{"address":59730,"text":"loop if not all done"},{"address":59732,"text":"clear the keyboard buffer index"},{"address":59734,"text":"get the cursor row\nrestore the tape buffer pointers and exit"},{"address":59736,"text":"pull tape buffer end pointer"},{"address":59737,"text":"restore it"},{"address":59739,"text":"pull tape buffer end pointer"},{"address":59740,"text":"restore it"},{"address":59742,"text":"pull tape buffer pointer"},{"address":59743,"text":"restore it"},{"address":59745,"text":"pull tape buffer pointer"},{"address":59746,"text":"restore it"},{"address":59749,"text":"get the cursor row"},{"address":59751,"text":"increment the row"},{"address":59752,"text":"get the start of line X pointer high byte"},{"address":59754,"text":"loop if not start of logical line"},{"address":59756,"text":"save the screen row marker"},{"address":59759,"text":"compare it with the last line"},{"address":59761,"text":"if = last line go ??"},{"address":59763,"text":"if \u003c last line go ??\nelse it was \u003e last line"},{"address":59765,"text":"scroll the screen"},{"address":59768,"text":"get the screen row marker"},{"address":59771,"text":"decrement the screen row marker"},{"address":59772,"text":"decrement the cursor row"},{"address":59774,"text":"add this row to the current logical line and return"},{"address":59777,"text":"copy tape buffer pointer"},{"address":59779,"text":"save it"},{"address":59780,"text":"copy tape buffer pointer"},{"address":59782,"text":"save it"},{"address":59783,"text":"copy tape buffer end pointer"},{"address":59785,"text":"save it"},{"address":59786,"text":"copy tape buffer end pointer"},{"address":59788,"text":"save it"},{"address":59789,"text":"set to end line + 1 for predecrement loop"},{"address":59791,"text":"decrement the line number"},{"address":59792,"text":"fetch a screen address"},{"address":59795,"text":"compare it with the screen row marker"},{"address":59798,"text":"if \u003c screen row marker go ??"},{"address":59800,"text":"if = screen row marker go ??"},{"address":59802,"text":"else get the start of the previous line low byte from the\nROM table"},{"address":59805,"text":"save previous line pointer low byte"},{"address":59807,"text":"get the start of the previous line pointer high byte"},{"address":59809,"text":"shift the screen line down"},{"address":59812,"text":"loop, branch always"},{"address":59814,"text":"clear screen line X"},{"address":59819,"text":"compare it with the screen row marker"},{"address":59828,"text":"get start of line X pointer high byte"},{"address":59839,"text":"get the screen row marker"},{"address":59842,"text":"add this row to the current logical line"},{"address":59845,"text":"restore the tape buffer pointers and exit"},{"address":59848,"text":"mask 0000 00xx, line memory page"},{"address":59850,"text":"OR with screen memory page"},{"address":59853,"text":"save next/previous line pointer high byte"},{"address":59855,"text":"calculate pointers to screen lines colour RAM"},{"address":59858,"text":"set the column count"},{"address":59860,"text":"get character from next/previous screen line"},{"address":59862,"text":"save character to current screen line"},{"address":59864,"text":"get colour from next/previous screen line colour RAM"},{"address":59866,"text":"save colour to current screen line colour RAM"},{"address":59868,"text":"decrement column index/count"},{"address":59869,"text":"loop if more to do"},{"address":59872,"text":"calculate the pointer to the current screen line colour\nRAM"},{"address":59875,"text":"get the next screen line pointer low byte"},{"address":59877,"text":"save the next screen line colour RAM pointer low byte"},{"address":59879,"text":"get the next screen line pointer high byte"},{"address":59881,"text":"mask 0000 00xx, line memory page"},{"address":59883,"text":"set  1101 01xx, colour memory page"},{"address":59885,"text":"save the next screen line colour RAM pointer high byte"},{"address":59888,"text":"get the start of line low byte from the ROM table"},{"address":59891,"text":"set the current screen line pointer low byte"},{"address":59893,"text":"get the start of line high byte from the RAM table"},{"address":59895,"text":"mask 0000 00xx, line memory page"},{"address":59897,"text":"OR with the screen memory page"},{"address":59900,"text":"save the current screen line pointer high byte"},{"address":59903,"text":"set number of columns to clear"},{"address":59905,"text":"fetch a screen address"},{"address":59908,"text":"calculate the pointer to colour RAM"},{"address":59911,"text":"save the current colour to the colour RAM"},{"address":59914,"text":"set [SPACE]"},{"address":59916,"text":"clear character in current screen line"},{"address":59918,"text":"decrement index"},{"address":59919,"text":"loop if more to do"},{"address":59922,"text":"unused"},{"address":59923,"text":"copy the character"},{"address":59924,"text":"count to $02, usually $14 ??"},{"address":59926,"text":"save the cursor countdown"},{"address":59928,"text":"calculate the pointer to colour RAM"},{"address":59931,"text":"get the character back"},{"address":59932,"text":"get the cursor column"},{"address":59934,"text":"save the character from current screen line"},{"address":59936,"text":"copy the colour to A"},{"address":59937,"text":"save to colour RAM"},{"address":59940,"text":"get current screen line pointer low byte"},{"address":59942,"text":"save pointer to colour RAM low byte"},{"address":59944,"text":"get current screen line pointer high byte"},{"address":59946,"text":"mask 0000 00xx, line memory page"},{"address":59948,"text":"set  1101 01xx, colour memory page"},{"address":59950,"text":"save pointer to colour RAM high byte"},{"address":59953,"text":"increment the real time clock"},{"address":59956,"text":"get the cursor enable, $00 = flash cursor"},{"address":59958,"text":"if flash not enabled skip the flash"},{"address":59960,"text":"decrement the cursor timing countdown"},{"address":59962,"text":"if not counted out skip the flash"},{"address":59964,"text":"set the flash count"},{"address":59966,"text":"save the cursor timing countdown"},{"address":59968,"text":"get the cursor column"},{"address":59970,"text":"shift b0 cursor blink phase into carry"},{"address":59972,"text":"get the colour under the cursor"},{"address":59975,"text":"get the character from current screen line"},{"address":59977,"text":"branch if cursor phase b0 was 1"},{"address":59979,"text":"set the cursor blink phase to 1"},{"address":59981,"text":"save the character under the cursor"},{"address":59983,"text":"calculate the pointer to colour RAM"},{"address":59986,"text":"get the colour RAM byte"},{"address":59988,"text":"save the colour under the cursor"},{"address":59991,"text":"get the current colour code"},{"address":59994,"text":"get the character under the cursor"},{"address":59996,"text":"toggle b7 of character under cursor"},{"address":59998,"text":"save the character and colour to the screen @ the cursor"},{"address":60001,"text":"read the 6510 I/O port"},{"address":60003,"text":"mask 000x 0000, the cassette switch sense"},{"address":60005,"text":"if the cassette sense is low skip the motor stop\nthe cassette sense was high, the switch was open, so turn\noff the motor and clear the interlock"},{"address":60007,"text":"clear Y"},{"address":60009,"text":"clear the tape motor interlock"},{"address":60011,"text":"read the 6510 I/O port"},{"address":60013,"text":"mask xxxx xx1x, turn off the motor"},{"address":60015,"text":"go save the port value, branch always\nthe cassette sense was low so turn the motor on, perhaps"},{"address":60017,"text":"get the tape motor interlock"},{"address":60019,"text":"if the cassette interlock \u003c\u003e 0 don't turn on motor"},{"address":60021,"text":"read the 6510 I/O port"},{"address":60023,"text":"mask xxxx xx0x, turn on the motor"},{"address":60025,"text":"save the 6510 I/O port"},{"address":60027,"text":"scan the keyboard"},{"address":60030,"text":"read VIA 1 ICR, clear the timer interrupt flag"},{"address":60033,"text":"pull Y"},{"address":60034,"text":"restore Y"},{"address":60035,"text":"pull X"},{"address":60036,"text":"restore X"},{"address":60037,"text":"restore A"},{"address":60039,"text":"clear A"},{"address":60041,"text":"clear the keyboard shift/control/c= flag"},{"address":60044,"text":"set no key"},{"address":60046,"text":"save which key"},{"address":60048,"text":"clear VIA 1 DRA, keyboard column drive"},{"address":60051,"text":"read VIA 1 DRB, keyboard row port"},{"address":60054,"text":"compare with all bits set"},{"address":60056,"text":"if no key pressed clear current key and exit (does\nfurther BEQ to $EBBA)"},{"address":60058,"text":"clear the key count"},{"address":60059,"text":"get the decode table low byte"},{"address":60061,"text":"save the keyboard pointer low byte"},{"address":60063,"text":"get the decode table high byte"},{"address":60065,"text":"save the keyboard pointer high byte"},{"address":60067,"text":"set column 0 low"},{"address":60069,"text":"save VIA 1 DRA, keyboard column drive"},{"address":60072,"text":"set the row count"},{"address":60074,"text":"save the column"},{"address":60075,"text":"read VIA 1 DRB, keyboard row port"},{"address":60078,"text":"compare it with itself"},{"address":60081,"text":"loop if changing"},{"address":60083,"text":"shift row to Cb"},{"address":60084,"text":"if no key closed on this row go do next row"},{"address":60086,"text":"save row"},{"address":60087,"text":"get character from decode table"},{"address":60089,"text":"compare with $05, there is no $05 key but the control\nkeys are all less than $05"},{"address":60091,"text":"if not shift/control/c=/stop go save key count\nelse was shift/control/c=/stop key"},{"address":60093,"text":"compare with $03, stop"},{"address":60095,"text":"if stop go save key count and continue\ncharacter is $01 - shift, $02 - c= or $04 - control"},{"address":60097,"text":"OR it with the keyboard shift/control/c= flag"},{"address":60100,"text":"save the keyboard shift/control/c= flag"},{"address":60103,"text":"skip save key, branch always"},{"address":60105,"text":"save key count"},{"address":60107,"text":"restore row"},{"address":60108,"text":"increment key count"},{"address":60109,"text":"compare with max+1"},{"address":60111,"text":"exit loop if \u003e= max+1\nelse still in matrix"},{"address":60113,"text":"decrement row count"},{"address":60114,"text":"loop if more rows to do"},{"address":60116,"text":"set carry for keyboard column shift"},{"address":60117,"text":"restore the column"},{"address":60118,"text":"shift the keyboard column"},{"address":60119,"text":"save VIA 1 DRA, keyboard column drive"},{"address":60122,"text":"loop for next column, branch always"},{"address":60124,"text":"dump the saved column"},{"address":60125,"text":"evaluate the SHIFT/CTRL/C= keys, $EBDC\nkey decoding continues here after the SHIFT/CTRL/C= keys are evaluated"},{"address":60128,"text":"get saved key count"},{"address":60130,"text":"get character from decode table"},{"address":60132,"text":"copy character to X"},{"address":60133,"text":"compare key count with last key count"},{"address":60135,"text":"if this key = current key, key held, go test repeat"},{"address":60137,"text":"set the repeat delay count"},{"address":60139,"text":"save the repeat delay count"},{"address":60142,"text":"go save key to buffer and exit, branch always"},{"address":60144,"text":"clear b7"},{"address":60146,"text":"test key repeat"},{"address":60149,"text":"if repeat all go ??"},{"address":60151,"text":"if repeat none go ??"},{"address":60153,"text":"compare with end marker"},{"address":60155,"text":"if $00/end marker go save key to buffer and exit"},{"address":60157,"text":"compare with [INSERT]/[DELETE]"},{"address":60159,"text":"if [INSERT]/[DELETE] go test for repeat"},{"address":60161,"text":"compare with [SPACE]"},{"address":60163,"text":"if [SPACE] go test for repeat"},{"address":60165,"text":"compare with [CURSOR RIGHT]"},{"address":60167,"text":"if [CURSOR RIGHT] go test for repeat"},{"address":60169,"text":"compare with [CURSOR DOWN]"},{"address":60171,"text":"if not [CURSOR DOWN] just exit\nwas one of the cursor movement keys, insert/delete\nkey or the space bar so always do repeat tests"},{"address":60173,"text":"get the repeat delay counter"},{"address":60176,"text":"if delay expired go ??"},{"address":60178,"text":"else decrement repeat delay counter"},{"address":60181,"text":"if delay not expired go ??\nrepeat delay counter has expired"},{"address":60183,"text":"decrement the repeat speed counter"},{"address":60186,"text":"branch if repeat speed count not expired"},{"address":60188,"text":"set for 4/60ths of a second"},{"address":60190,"text":"save the repeat speed counter"},{"address":60193,"text":"get the keyboard buffer index"},{"address":60195,"text":"decrement it"},{"address":60196,"text":"if the buffer isn't empty just exit\nelse repeat the key immediately\npossibly save the key to the keyboard buffer. if there was no key pressed or the key\nwas not found during the scan (possibly due to key bounce) then X will be $FF here"},{"address":60198,"text":"get the key count"},{"address":60200,"text":"save it as the current key count"},{"address":60202,"text":"get the keyboard shift/control/c= flag"},{"address":60205,"text":"save it as last keyboard shift pattern"},{"address":60208,"text":"compare the character with the table end marker or no key"},{"address":60210,"text":"if it was the table end marker or no key just exit"},{"address":60212,"text":"copy the character to A"},{"address":60213,"text":"get the keyboard buffer index"},{"address":60215,"text":"compare it with the keyboard buffer size"},{"address":60218,"text":"if the buffer is full just exit"},{"address":60220,"text":"save the character to the keyboard buffer"},{"address":60223,"text":"increment the index"},{"address":60224,"text":"save the keyboard buffer index"},{"address":60226,"text":"enable column 7 for the stop key"},{"address":60228,"text":"save VIA 1 DRA, keyboard column drive"},{"address":60232,"text":"get the keyboard shift/control/c= flag"},{"address":60235,"text":"compare with [SHIFT][C=]"},{"address":60237,"text":"if not [SHIFT][C=] go ??"},{"address":60239,"text":"compare with last"},{"address":60242,"text":"exit if still the same"},{"address":60244,"text":"get the shift mode switch $00 = enabled, $80 = locked"},{"address":60247,"text":"if locked continue keyboard decode\ntoggle text mode"},{"address":60249,"text":"get the start of character memory address"},{"address":60252,"text":"toggle address b1"},{"address":60254,"text":"save the start of character memory address"},{"address":60257,"text":"continue the keyboard decode\nselect keyboard table"},{"address":60260,"text":"\u003c\u003c 1"},{"address":60261,"text":"compare with [CTRL]"},{"address":60263,"text":"if [CTRL] is not pressed skip the index change"},{"address":60265,"text":"else [CTRL] was pressed so make the index = $06"},{"address":60267,"text":"copy the index to X"},{"address":60268,"text":"get the decode table pointer low byte"},{"address":60271,"text":"save the decode table pointer low byte"},{"address":60273,"text":"get the decode table pointer high byte"},{"address":60276,"text":"save the decode table pointer high byte"},{"address":60278,"text":"continue the keyboard decode"},{"address":60484,"text":"compare with [SWITCH TO LOWER CASE]"},{"address":60486,"text":"if not [SWITCH TO LOWER CASE] skip the switch"},{"address":60488,"text":"get the start of character memory address"},{"address":60491,"text":"mask xxxx xx1x, set lower case characters"},{"address":60493,"text":"go save the new value, branch always\ncheck for special character codes except fro switch to lower case"},{"address":60495,"text":"compare with [SWITCH TO UPPER CASE]"},{"address":60497,"text":"if not [SWITCH TO UPPER CASE] go do the [SHIFT]+[C=] key\ncheck"},{"address":60499,"text":"get the start of character memory address"},{"address":60502,"text":"mask xxxx xx0x, set upper case characters"},{"address":60504,"text":"save the start of character memory address"},{"address":60507,"text":"restore the registers, set the quote flag and exit\ndo the [SHIFT]+[C=] key check"},{"address":60510,"text":"compare with disable [SHIFT][C=]"},{"address":60512,"text":"if not disable [SHIFT][C=] skip the set"},{"address":60514,"text":"set to lock shift mode switch"},{"address":60516,"text":"OR it with the shift mode switch"},{"address":60519,"text":"go save the value, branch always"},{"address":60521,"text":"compare with enable [SHIFT][C=]"},{"address":60523,"text":"exit if not enable [SHIFT][C=]"},{"address":60525,"text":"set to unlock shift mode switch"},{"address":60527,"text":"AND it with the shift mode switch"},{"address":60530,"text":"save the shift mode switch $00 = enabled, $80 = locked"},{"address":60533,"text":"restore the registers, set the quote flag and exit"},{"address":60681,"text":"OR with the TALK command"},{"address":60684,"text":"OR with the LISTEN command"},{"address":60686,"text":"check RS232 bus idle"},{"address":60689,"text":"save device address"},{"address":60690,"text":"test deferred character flag"},{"address":60692,"text":"if no defered character continue"},{"address":60694,"text":"else flag EOI"},{"address":60695,"text":"rotate into EOI flag byte"},{"address":60697,"text":"Tx byte on serial bus"},{"address":60700,"text":"clear deferred character flag"},{"address":60702,"text":"clear EOI flag"},{"address":60704,"text":"restore the device address"},{"address":60705,"text":"save as serial defered character"},{"address":60707,"text":"disable the interrupts"},{"address":60708,"text":"set the serial data out high"},{"address":60711,"text":"compare read byte with $3F"},{"address":60713,"text":"branch if not $3F, this branch will always be taken as\nafter VIA 2's PCR is read it is ANDed with $DF, so the\nresult can never be $3F ??"},{"address":60715,"text":"set the serial clock out high"},{"address":60718,"text":"read VIA 2 DRA, serial port and video address"},{"address":60721,"text":"mask xxxx 1xxx, set serial ATN low"},{"address":60723,"text":"save VIA 2 DRA, serial port and video address\nif the code drops through to here the serial clock is low and the serial data has been\nreleased so the following code will have no effect apart from delaying the first byte\nby 1ms\nset the serial clk/data, wait and Tx byte on the serial bus"},{"address":60726,"text":"disable the interrupts"},{"address":60727,"text":"set the serial clock out low"},{"address":60730,"text":"set the serial data out high"},{"address":60733,"text":"1ms delay"},{"address":60736,"text":"disable the interrupts"},{"address":60737,"text":"set the serial data out high"},{"address":60740,"text":"get the serial data status in Cb"},{"address":60743,"text":"if the serial data is high go do 'device not present'"},{"address":60745,"text":"set the serial clock out high"},{"address":60748,"text":"test the EOI flag"},{"address":60750,"text":"if not EOI go ??\nI think this is the EOI sequence so the serial clock has been released and the serial\ndata is being held low by the peripheral. first up wait for the serial data to rise"},{"address":60752,"text":"get the serial data status in Cb"},{"address":60755,"text":"loop if the data is low\nnow the data is high, EOI is signalled by waiting for at least 200us without pulling\nthe serial clock line low again. the listener should respond by pulling the serial\ndata line low"},{"address":60757,"text":"get the serial data status in Cb"},{"address":60760,"text":"loop if the data is high\nthe serial data has gone low ending the EOI sequence, now just wait for the serial\ndata line to go high again or, if this isn't an EOI sequence, just wait for the serial\ndata to go high the first time"},{"address":60762,"text":"get the serial data status in Cb"},{"address":60765,"text":"loop if the data is low\nserial data is high now pull the clock low, preferably within 60us"},{"address":60767,"text":"set the serial clock out low\nnow the C64 has to send the eight bits, LSB first. first it sets the serial data line\nto reflect the bit in the byte, then it sets the serial clock to high. The serial\nclock is left high for 26 cycles, 23us on a PAL Vic, before it is again pulled low\nand the serial data is allowed high again"},{"address":60770,"text":"eight bits to do"},{"address":60772,"text":"set serial bus bit count"},{"address":60774,"text":"read VIA 2 DRA, serial port and video address"},{"address":60777,"text":"compare it with itself"},{"address":60780,"text":"if changed go try again"},{"address":60782,"text":"shift the serial data into Cb"},{"address":60783,"text":"if the serial data is low go do serial bus timeout"},{"address":60785,"text":"rotate the transmit byte"},{"address":60787,"text":"if the bit = 1 go set the serial data out high"},{"address":60789,"text":"else set the serial data out low"},{"address":60792,"text":"continue, branch always"},{"address":60794,"text":"set the serial data out high"},{"address":60797,"text":"set the serial clock out high"},{"address":60800,"text":"waste .."},{"address":60801,"text":".. a .."},{"address":60802,"text":".. cycle .."},{"address":60803,"text":".. or two"},{"address":60804,"text":"read VIA 2 DRA, serial port and video address"},{"address":60807,"text":"mask xx0x xxxx, set the serial data out high"},{"address":60809,"text":"mask xxx1 xxxx, set the serial clock out low"},{"address":60811,"text":"save VIA 2 DRA, serial port and video address"},{"address":60814,"text":"decrement the serial bus bit count"},{"address":60816,"text":"loop if not all done\nnow all eight bits have been sent it's up to the peripheral to signal the byte was\nreceived by pulling the serial data low. this should be done within one milisecond"},{"address":60818,"text":"wait for up to about 1ms"},{"address":60820,"text":"save VIA 1 timer B high byte"},{"address":60823,"text":"load timer B, timer B single shot, start timer B"},{"address":60825,"text":"save VIA 1 CRB"},{"address":60828,"text":"read VIA 1 ICR"},{"address":60831,"text":"read VIA 1 ICR"},{"address":60834,"text":"mask 0000 00x0, timer A interrupt"},{"address":60836,"text":"if timer A interrupt go do serial bus timeout"},{"address":60838,"text":"get the serial data status in Cb"},{"address":60841,"text":"if the serial data is high go wait some more"},{"address":60843,"text":"enable the interrupts"},{"address":60845,"text":"error $80, device not present"},{"address":60848,"text":"error $03, read timeout, write timeout"},{"address":60850,"text":"OR into the serial status byte"},{"address":60853,"text":"enable the interrupts"},{"address":60854,"text":"clear for branch"},{"address":60855,"text":"ATN high, delay, clock high then data high, branch always"},{"address":60857,"text":"save the defered Tx byte"},{"address":60859,"text":"set the serial clk/data, wait and Tx the byte"},{"address":60862,"text":"read VIA 2 DRA, serial port and video address"},{"address":60865,"text":"mask xxxx 0xxx, set serial ATN high"},{"address":60867,"text":"save VIA 2 DRA, serial port and video address"},{"address":60871,"text":"save the defered Tx byte"},{"address":60873,"text":"set the serial clk/data, wait and Tx the byte"},{"address":60876,"text":"disable the interrupts"},{"address":60877,"text":"set the serial data out low"},{"address":60880,"text":"set serial ATN high"},{"address":60883,"text":"set the serial clock out high"},{"address":60886,"text":"get the serial data status in Cb"},{"address":60889,"text":"loop if the clock is high"},{"address":60891,"text":"enable the interrupts"},{"address":60893,"text":"test the deferred character flag"},{"address":60895,"text":"if there is a defered character go send it"},{"address":60897,"text":"set carry"},{"address":60898,"text":"shift into the deferred character flag"},{"address":60900,"text":"save the byte and exit, branch always"},{"address":60902,"text":"save the byte"},{"address":60903,"text":"Tx byte on serial bus"},{"address":60906,"text":"restore the byte"},{"address":60907,"text":"save the defered Tx byte"},{"address":60909,"text":"flag ok"},{"address":60911,"text":"disable the interrupts"},{"address":60912,"text":"set the serial clock out low"},{"address":60915,"text":"read VIA 2 DRA, serial port and video address"},{"address":60918,"text":"mask xxxx 1xxx, set the serial ATN low"},{"address":60920,"text":"save VIA 2 DRA, serial port and video address"},{"address":60923,"text":"set the UNTALK command"},{"address":60926,"text":"set the UNLISTEN command"},{"address":60928,"text":"send a control character"},{"address":60931,"text":"set serial ATN high\n1ms delay, clock high then data high"},{"address":60934,"text":"save the device number"},{"address":60935,"text":"short delay"},{"address":60937,"text":"decrement the count"},{"address":60938,"text":"loop if not all done"},{"address":60940,"text":"restore the device number"},{"address":60941,"text":"set the serial clock out high"},{"address":60944,"text":"set the serial data out high and return"},{"address":60947,"text":"disable the interrupts"},{"address":60948,"text":"set 0 bits to do, will flag EOI on timeour"},{"address":60950,"text":"save the serial bus bit count"},{"address":60952,"text":"set the serial clock out high"},{"address":60955,"text":"get the serial data status in Cb"},{"address":60958,"text":"loop if the serial clock is low"},{"address":60960,"text":"set the timeout count high byte"},{"address":60962,"text":"save VIA 1 timer B high byte"},{"address":60965,"text":"load timer B, timer B single shot, start timer B"},{"address":60967,"text":"save VIA 1 CRB"},{"address":60970,"text":"set the serial data out high"},{"address":60973,"text":"read VIA 1 ICR"},{"address":60976,"text":"read VIA 1 ICR"},{"address":60979,"text":"mask 0000 00x0, timer A interrupt"},{"address":60981,"text":"if timer A interrupt go ??"},{"address":60983,"text":"get the serial data status in Cb"},{"address":60986,"text":"loop if the serial clock is low"},{"address":60988,"text":"else go set 8 bits to do, branch always\ntimer A timed out"},{"address":60990,"text":"get the serial bus bit count"},{"address":60992,"text":"if not already EOI then go flag EOI"},{"address":60994,"text":"else error $02, read timeour"},{"address":60996,"text":"set the serial status and exit"},{"address":60999,"text":"set the serial data out low"},{"address":61002,"text":"set the serial clock out high"},{"address":61005,"text":"set EOI"},{"address":61007,"text":"OR into the serial status byte"},{"address":61010,"text":"increment the serial bus bit count, do error on the next\ntimeout"},{"address":61012,"text":"go try again, branch always"},{"address":61014,"text":"set 8 bits to do"},{"address":61016,"text":"save the serial bus bit count"},{"address":61018,"text":"read VIA 2 DRA, serial port and video address"},{"address":61021,"text":"compare it with itself"},{"address":61024,"text":"if changing go try again"},{"address":61026,"text":"shift the serial data into the carry"},{"address":61027,"text":"loop while the serial clock is low"},{"address":61029,"text":"shift the data bit into the receive byte"},{"address":61031,"text":"read VIA 2 DRA, serial port and video address"},{"address":61034,"text":"compare it with itself"},{"address":61037,"text":"if changing go try again"},{"address":61039,"text":"shift the serial data into the carry"},{"address":61040,"text":"loop while the serial clock is high"},{"address":61042,"text":"decrement the serial bus bit count"},{"address":61044,"text":"loop if not all done"},{"address":61046,"text":"set the serial data out low"},{"address":61049,"text":"test the serial status byte"},{"address":61051,"text":"if EOI not set skip the bus end sequence"},{"address":61053,"text":"1ms delay, clock high then data high"},{"address":61056,"text":"get the receive byte"},{"address":61058,"text":"enable the interrupts"},{"address":61059,"text":"flag ok"},{"address":61061,"text":"read VIA 2 DRA, serial port and video address"},{"address":61064,"text":"mask xxx0 xxxx, set serial clock out high"},{"address":61066,"text":"save VIA 2 DRA, serial port and video address"},{"address":61070,"text":"read VIA 2 DRA, serial port and video address"},{"address":61073,"text":"mask xxx1 xxxx, set serial clock out low"},{"address":61075,"text":"save VIA 2 DRA, serial port and video address"},{"address":61079,"text":"read VIA 2 DRA, serial port and video address"},{"address":61082,"text":"mask xx0x xxxx, set serial data out high"},{"address":61084,"text":"save VIA 2 DRA, serial port and video address"},{"address":61088,"text":"read VIA 2 DRA, serial port and video address"},{"address":61091,"text":"mask xx1x xxxx, set serial data out low"},{"address":61093,"text":"save VIA 2 DRA, serial port and video address"},{"address":61097,"text":"read VIA 2 DRA, serial port and video address"},{"address":61100,"text":"compare it with itself"},{"address":61103,"text":"if changing got try again"},{"address":61105,"text":"shift the serial data into Cb"},{"address":61107,"text":"save X"},{"address":61108,"text":"set the loop count"},{"address":61110,"text":"decrement the loop count"},{"address":61111,"text":"loop if more to do"},{"address":61113,"text":"restore X"},{"address":61115,"text":"get RS232 bit count"},{"address":61117,"text":"if zero go setup next RS232 Tx byte and return"},{"address":61119,"text":"if -ve go do stop bit(s)\nelse bit count is non zero and +ve"},{"address":61121,"text":"shift RS232 output byte buffer"},{"address":61123,"text":"set $00 for bit = 0"},{"address":61125,"text":"branch if bit was 0"},{"address":61127,"text":"set $FF for bit = 1"},{"address":61128,"text":"copy bit to A"},{"address":61129,"text":"EOR with RS232 parity byte"},{"address":61131,"text":"save RS232 parity byte"},{"address":61133,"text":"decrement RS232 bit count"},{"address":61135,"text":"if RS232 bit count now zero go do parity bit\nsave bit and exit"},{"address":61137,"text":"copy bit to A"},{"address":61138,"text":"mask 0000 0x00, RS232 Tx DATA bit"},{"address":61140,"text":"save the next RS232 data bit to send"},{"address":61143,"text":"mask 00x0 0000, parity enable bit"},{"address":61145,"text":"test the pseudo 6551 command register"},{"address":61148,"text":"if parity disabled go ??"},{"address":61150,"text":"if fixed mark or space parity go ??"},{"address":61152,"text":"if even parity go ??\nelse odd parity"},{"address":61154,"text":"get RS232 parity byte"},{"address":61156,"text":"if parity not zero leave parity bit = 0"},{"address":61158,"text":"make parity bit = 1"},{"address":61159,"text":"decrement RS232 bit count, 1 stop bit"},{"address":61161,"text":"get pseudo 6551 control register"},{"address":61164,"text":"if 1 stop bit save parity bit and exit\nelse two stop bits .."},{"address":61166,"text":"decrement RS232 bit count, 2 stop bits"},{"address":61168,"text":"save bit and exit, branch always\nparity is disabled so the parity bit becomes the first,\nand possibly only, stop bit. to do this increment the bit\ncount which effectively decrements the stop bit count."},{"address":61170,"text":"increment RS232 bit count, = -1 stop bit"},{"address":61172,"text":"set stop bit = 1 and exit\ndo even parity"},{"address":61174,"text":"get RS232 parity byte"},{"address":61176,"text":"if parity zero leave parity bit = 0"},{"address":61178,"text":"else make parity bit = 1, branch always\nfixed mark or space parity"},{"address":61180,"text":"if fixed space parity leave parity bit = 0"},{"address":61182,"text":"else fixed mark parity make parity bit = 1, branch always\ndecrement stop bit count, set stop bit = 1 and exit. $FF is one stop bit, $FE is two\nstop bits"},{"address":61184,"text":"decrement RS232 bit count"},{"address":61186,"text":"set stop bit = 1"},{"address":61188,"text":"save stop bit and exit, branch always"},{"address":61190,"text":"read the 6551 pseudo command register"},{"address":61193,"text":"handshake bit inot Cb"},{"address":61194,"text":"if 3 line interface go ??"},{"address":61196,"text":"test VIA 2 DRB, RS232 port"},{"address":61199,"text":"if DSR = 0 set DSR signal not present and exit"},{"address":61201,"text":"if CTS = 0 set CTS signal not present and exit\nwas 3 line interface"},{"address":61203,"text":"clear A"},{"address":61205,"text":"clear the RS232 parity byte"},{"address":61207,"text":"clear the RS232 next bit to send"},{"address":61209,"text":"get the number of bits to be sent/received"},{"address":61212,"text":"set the RS232 bit count"},{"address":61214,"text":"get the index to the Tx buffer start"},{"address":61217,"text":"compare it with the index to the Tx buffer end"},{"address":61220,"text":"if all done go disable T?? interrupt and return"},{"address":61222,"text":"else get a byte from the buffer"},{"address":61224,"text":"save it to the RS232 output byte buffer"},{"address":61226,"text":"increment the index to the Tx buffer start"},{"address":61230,"text":"set DSR signal not present"},{"address":61233,"text":"set CTS signal not present"},{"address":61235,"text":"OR it with the RS232 status register"},{"address":61238,"text":"save the RS232 status register"},{"address":61241,"text":"disable timer A interrupt"},{"address":61243,"text":"save VIA 2 ICR"},{"address":61246,"text":"EOR with the RS-232 interrupt enable byte"},{"address":61249,"text":"set the interrupts enable bit"},{"address":61251,"text":"save the RS-232 interrupt enable byte"},{"address":61254,"text":"save VIA 2 ICR"},{"address":61258,"text":"set bit count to 9, 8 data + 1 stop bit"},{"address":61260,"text":"mask for 8/7 data bits"},{"address":61262,"text":"test pseudo 6551 control register"},{"address":61265,"text":"branch if 8 bits"},{"address":61267,"text":"else decrement count for 7 data bits"},{"address":61268,"text":"branch if 7 bits"},{"address":61270,"text":"else decrement count .."},{"address":61271,"text":".. for 5 data bits"},{"address":61273,"text":"get start bit check flag"},{"address":61275,"text":"if no start bit received go ??"},{"address":61277,"text":"decrement receiver bit count in"},{"address":61279,"text":"if the byte is complete go add it to the buffer"},{"address":61283,"text":"get the RS232 received data bit"},{"address":61285,"text":"EOR with the receiver parity bit"},{"address":61287,"text":"save the receiver parity bit"},{"address":61289,"text":"shift the RS232 received data bit"},{"address":61294,"text":"decrement receiver bit count in"},{"address":61296,"text":"get the RS232 received data bit"},{"address":61300,"text":"get pseudo 6551 control register"},{"address":61303,"text":"shift the stop bit flag to Cb"},{"address":61304,"text":"+ 1"},{"address":61306,"text":"add receiver bit count in"},{"address":61308,"text":"exit, branch always"},{"address":61310,"text":"enable FLAG interrupt"},{"address":61312,"text":"save VIA 2 ICR"},{"address":61315,"text":"OR with the RS-232 interrupt enable byte"},{"address":61318,"text":"save the RS-232 interrupt enable byte"},{"address":61321,"text":"set start bit check flag, set no start bit received"},{"address":61323,"text":"disable timer B interrupt"},{"address":61325,"text":"set VIA 2 ICR from A and return"},{"address":61328,"text":"get the RS232 received data bit"},{"address":61330,"text":"if ?? go setup to receive an RS232 bit and return"},{"address":61332,"text":"flag the RS232 start bit and set the parity"},{"address":61335,"text":"get index to Rx buffer end"},{"address":61338,"text":"increment index"},{"address":61339,"text":"compare with index to Rx buffer start"},{"address":61342,"text":"if buffer full go do Rx overrun error"},{"address":61344,"text":"save index to Rx buffer end"},{"address":61347,"text":"decrement index"},{"address":61348,"text":"get assembled byte"},{"address":61350,"text":"get bit count"},{"address":61353,"text":"compare with byte + stop"},{"address":61355,"text":"branch if all nine bits received"},{"address":61357,"text":"else shift byte"},{"address":61358,"text":"increment bit count"},{"address":61359,"text":"loop, branch always"},{"address":61361,"text":"save received byte to Rx buffer"},{"address":61363,"text":"mask 00x0 0000, parity enable bit"},{"address":61365,"text":"test the pseudo 6551 command register"},{"address":61368,"text":"branch if parity disabled"},{"address":61370,"text":"branch if mark or space parity"},{"address":61372,"text":"get the RS232 received data bit"},{"address":61374,"text":"EOR with the receiver parity bit"},{"address":61378,"text":"if ?? just exit"},{"address":61381,"text":"if ?? just exit"},{"address":61383,"text":"set Rx parity error"},{"address":61386,"text":"set Rx overrun error"},{"address":61389,"text":"set Rx break error"},{"address":61392,"text":"set Rx frame error"},{"address":61394,"text":"OR it with the RS232 status byte"},{"address":61397,"text":"save the RS232 status byte"},{"address":61400,"text":"setup to receive an RS232 bit and return"},{"address":61405,"text":"if ?? do frame error"},{"address":61407,"text":"else do break error, branch always"},{"address":61409,"text":"save the output device number"},{"address":61411,"text":"read the pseudo 6551 command register"},{"address":61414,"text":"shift handshake bit to carry"},{"address":61415,"text":"if 3 line interface go ??"},{"address":61417,"text":"mask 0000 00x0, RTS out"},{"address":61419,"text":"test VIA 2 DRB, RS232 port"},{"address":61422,"text":"if DSR = 0 set DSR not present and exit"},{"address":61424,"text":"if RTS = 1 just exit"},{"address":61426,"text":"get the RS-232 interrupt enable byte"},{"address":61429,"text":"mask 0000 00x0, timer B interrupt"},{"address":61431,"text":"loop while the timer B interrupt is enebled"},{"address":61433,"text":"test VIA 2 DRB, RS232 port"},{"address":61436,"text":"loop while CTS high"},{"address":61438,"text":"read VIA 2 DRB, RS232 port"},{"address":61441,"text":"mask xxxx xx1x, set RTS high"},{"address":61443,"text":"save VIA 2 DRB, RS232 port"},{"address":61446,"text":"test VIA 2 DRB, RS232 port"},{"address":61449,"text":"exit if CTS high"},{"address":61451,"text":"loop while DSR high\nset no DSR and exit"},{"address":61453,"text":"set DSR signal not present"},{"address":61455,"text":"save the RS232 status register"},{"address":61458,"text":"flag ok"},{"address":61460,"text":"setup for RS232 transmit\nsend byte to the RS232 buffer, no setup"},{"address":61463,"text":"get index to Tx buffer end"},{"address":61466,"text":"+ 1"},{"address":61467,"text":"compare with index to Tx buffer start"},{"address":61470,"text":"loop while buffer full"},{"address":61472,"text":"set index to Tx buffer end"},{"address":61475,"text":"index to available buffer byte"},{"address":61476,"text":"read the RS232 character buffer"},{"address":61478,"text":"save the byte to the buffer"},{"address":61480,"text":"get the RS-232 interrupt enable byte"},{"address":61483,"text":"shift the enable bit to Cb"},{"address":61484,"text":"if interrupts are enabled just exit"},{"address":61486,"text":"start timer A"},{"address":61488,"text":"save VIA 2 CRA"},{"address":61491,"text":"get the baud rate bit time low byte"},{"address":61494,"text":"save VIA 2 timer A low byte"},{"address":61497,"text":"get the baud rate bit time high byte"},{"address":61500,"text":"save VIA 2 timer A high byte"},{"address":61503,"text":"enable timer A interrupt"},{"address":61505,"text":"set VIA 2 ICR from A"},{"address":61508,"text":"setup next RS232 Tx byte"},{"address":61511,"text":"load timer A, start timer A"},{"address":61513,"text":"save VIA 2 CRA"},{"address":61517,"text":"save the input device number"},{"address":61519,"text":"get pseudo 6551 command register"},{"address":61522,"text":"shift the handshake bit to Cb"},{"address":61523,"text":"if 3 line interface go ??"},{"address":61525,"text":"mask the duplex bit, pseudo 6551 command is \u003e\u003e 1"},{"address":61527,"text":"if full duplex go ??"},{"address":61529,"text":"mask 0000 00x0, RTS out"},{"address":61531,"text":"test VIA 2 DRB, RS232 port"},{"address":61534,"text":"if DSR = 0 set no DSR and exit"},{"address":61536,"text":"if RTS = 0 just exit"},{"address":61538,"text":"get the RS-232 interrupt enable byte"},{"address":61541,"text":"shift the timer A interrupt enable bit to Cb"},{"address":61542,"text":"loop while the timer A interrupt is enabled"},{"address":61544,"text":"read VIA 2 DRB, RS232 port"},{"address":61547,"text":"mask xxxx xx0x, clear RTS out"},{"address":61549,"text":"save VIA 2 DRB, RS232 port"},{"address":61552,"text":"read VIA 2 DRB, RS232 port"},{"address":61555,"text":"mask xxxx x1xx, DTR in"},{"address":61557,"text":"loop while DTR low"},{"address":61559,"text":"enable the FLAG interrupt"},{"address":61561,"text":"flag ok"},{"address":61562,"text":"set VIA 2 ICR from A and return"},{"address":61565,"text":"get the RS-232 interrupt enable byte"},{"address":61568,"text":"mask 000x 00x0"},{"address":61570,"text":"if FLAG or timer B bits set go enable the FLAG inetrrupt"},{"address":61572,"text":"flag ok"},{"address":61574,"text":"get the RS232 status register"},{"address":61577,"text":"get index to Rx buffer start"},{"address":61580,"text":"compare with index to Rx buffer end"},{"address":61583,"text":"return null if buffer empty"},{"address":61585,"text":"clear the Rx buffer empty bit"},{"address":61587,"text":"save the RS232 status register"},{"address":61590,"text":"get byte from Rx buffer"},{"address":61592,"text":"increment index to Rx buffer start"},{"address":61596,"text":"set the Rx buffer empty bit"},{"address":61598,"text":"save the RS232 status register"},{"address":61601,"text":"return null"},{"address":61604,"text":"save A"},{"address":61605,"text":"get the RS-232 interrupt enable byte"},{"address":61608,"text":"if no interrupts enabled just exit"},{"address":61610,"text":"get the RS-232 interrupt enable byte"},{"address":61613,"text":"mask 0000 00xx, the error bits"},{"address":61615,"text":"if there are errors loop"},{"address":61617,"text":"disable FLAG interrupt"},{"address":61619,"text":"save VIA 2 ICR"},{"address":61622,"text":"clear A"},{"address":61624,"text":"clear the RS-232 interrupt enable byte"},{"address":61627,"text":"restore A"},{"address":61739,"text":"test message mode flag"},{"address":61741,"text":"exit if control messages off\ndisplay kernel I/O message"},{"address":61743,"text":"get byte from message table"},{"address":61746,"text":"save status"},{"address":61747,"text":"clear b7"},{"address":61749,"text":"output character to channel"},{"address":61752,"text":"increment index"},{"address":61753,"text":"restore status"},{"address":61754,"text":"loop if not end of message"},{"address":61758,"text":"get the input device number"},{"address":61760,"text":"if not the keyboard go handle other devices\nthe input device was the keyboard"},{"address":61762,"text":"get the keyboard buffer index"},{"address":61764,"text":"if the buffer is empty go flag no byte and return"},{"address":61766,"text":"disable the interrupts"},{"address":61767,"text":"get input from the keyboard buffer and return\nthe input device was not the keyboard"},{"address":61770,"text":"compare the device with the RS232 device"},{"address":61772,"text":"if not the RS232 device go ??\nthe input device is the RS232 device"},{"address":61774,"text":"save Y"},{"address":61776,"text":"get a byte from RS232 buffer"},{"address":61779,"text":"restore Y"},{"address":61781,"text":"flag no error"},{"address":61783,"text":"get the input device number"},{"address":61785,"text":"if not the keyboard continue\nthe input device was the keyboard"},{"address":61787,"text":"get the cursor column"},{"address":61789,"text":"set the input cursor column"},{"address":61791,"text":"get the cursor row"},{"address":61793,"text":"set the input cursor row"},{"address":61795,"text":"input from screen or keyboard\nthe input device was not the keyboard"},{"address":61798,"text":"compare device number with screen"},{"address":61800,"text":"if not screen continue\nthe input device was the screen"},{"address":61802,"text":"input from keyboard or screen, $xx = screen,\n$00 = keyboard"},{"address":61804,"text":"get current screen line length"},{"address":61806,"text":"save input [EOL] pointer"},{"address":61808,"text":"input from screen or keyboard\nthe input device was not the screen"},{"address":61811,"text":"if input device \u003e screen go do IEC devices\nthe input device was \u003c screen"},{"address":61813,"text":"compare the device with the RS232 device"},{"address":61815,"text":"if RS232 device go get a byte from the RS232 device\nonly the tape device left .."},{"address":61817,"text":"save X"},{"address":61819,"text":"get a byte from tape"},{"address":61822,"text":"if error just exit"},{"address":61824,"text":"save the byte"},{"address":61825,"text":"get the next byte from tape"},{"address":61828,"text":"if error just exit"},{"address":61830,"text":"if end reached ??"},{"address":61832,"text":"set EOI"},{"address":61834,"text":"OR into the serial status byte"},{"address":61837,"text":"decrement tape buffer index"},{"address":61839,"text":"restore X"},{"address":61841,"text":"restore the saved byte"},{"address":61843,"text":"copy the error byte"},{"address":61844,"text":"dump the saved byte"},{"address":61845,"text":"restore error byte"},{"address":61846,"text":"restore X"},{"address":61849,"text":"bump tape pointer"},{"address":61852,"text":"if not end get next byte and exit"},{"address":61854,"text":"initiate tape read"},{"address":61857,"text":"exit if error flagged"},{"address":61859,"text":"clear A"},{"address":61861,"text":"clear tape buffer index"},{"address":61863,"text":"loop, branch always"},{"address":61865,"text":"get next byte from buffer"},{"address":61867,"text":"flag no error"},{"address":61869,"text":"get the serial status byte"},{"address":61871,"text":"if no errors flagged go input byte and return"},{"address":61873,"text":"else return [EOL]"},{"address":61875,"text":"flag no error"},{"address":61877,"text":"input byte from serial bus and return\ninput device was RS232 device"},{"address":61880,"text":"get byte from RS232 device"},{"address":61883,"text":"branch if error, this doesn't get taken as the last\ninstruction in the get byte from RS232 device routine\nis CLC ??"},{"address":61885,"text":"compare with null"},{"address":61887,"text":"exit if not null"},{"address":61889,"text":"get the RS232 status register"},{"address":61892,"text":"mask 0xx0 0000, DSR detected and ??"},{"address":61894,"text":"if ?? return null"},{"address":61896,"text":"else loop, branch always"},{"address":61898,"text":"save the character to output"},{"address":61899,"text":"get the output device number"},{"address":61901,"text":"compare the output device with the screen"},{"address":61903,"text":"if not the screen go ??"},{"address":61905,"text":"else restore the output character"},{"address":61906,"text":"go output the character to the screen"},{"address":61909,"text":"if \u003c screen go ??"},{"address":61911,"text":"else restore the output character"},{"address":61912,"text":"go output the character to the serial bus"},{"address":61915,"text":"shift b0 of the device into Cb"},{"address":61916,"text":"restore the output character"},{"address":61917,"text":"save the character to the character buffer"},{"address":61919,"text":"copy X"},{"address":61920,"text":"save X"},{"address":61921,"text":"copy Y"},{"address":61922,"text":"save Y"},{"address":61923,"text":"if Cb is clear it must be the RS232 device\noutput the character to the cassette"},{"address":61925,"text":"bump the tape pointer"},{"address":61928,"text":"if not end save next byte and exit"},{"address":61930,"text":"initiate tape write"},{"address":61933,"text":"exit if error"},{"address":61935,"text":"set data block type ??"},{"address":61937,"text":"clear index"},{"address":61939,"text":"save type to buffer ??"},{"address":61941,"text":"increment index"},{"address":61942,"text":"save tape buffer index"},{"address":61944,"text":"restore character from character buffer"},{"address":61946,"text":"save to buffer"},{"address":61948,"text":"flag no error"},{"address":61949,"text":"pull Y"},{"address":61950,"text":"restore Y"},{"address":61951,"text":"pull X"},{"address":61952,"text":"restore X"},{"address":61953,"text":"get the character from the character buffer"},{"address":61955,"text":"exit if no error"},{"address":61957,"text":"else clear A"},{"address":61960,"text":"send byte to the RS232 buffer, no setup"},{"address":61963,"text":"do no error exit"},{"address":61966,"text":"find a file"},{"address":61969,"text":"if the file is open continue"},{"address":61971,"text":"else do 'file not open' error and return"},{"address":61974,"text":"set file details from table,X"},{"address":61977,"text":"get the device number"},{"address":61979,"text":"if the device was the keyboard save the device #, flag\nok and exit"},{"address":61981,"text":"compare the device number with the screen"},{"address":61983,"text":"if the device was the screen save the device #, flag ok\nand exit"},{"address":61985,"text":"if the device was a serial bus device go ??"},{"address":61987,"text":"else compare the device with the RS232 device"},{"address":61989,"text":"if not the RS232 device continue"},{"address":61991,"text":"else go get input from the RS232 buffer and return"},{"address":61994,"text":"get the secondary address"},{"address":62000,"text":"go do 'not input file' error and return"},{"address":62003,"text":"save the input device number"},{"address":62005,"text":"flag ok"},{"address":62007,"text":"copy device number to X"},{"address":62008,"text":"command serial bus device to TALK"},{"address":62011,"text":"get the secondary address"},{"address":62015,"text":"wait for the serial bus end after send"},{"address":62021,"text":"send secondary address after TALK"},{"address":62024,"text":"copy device back to A"},{"address":62025,"text":"test the serial status byte"},{"address":62027,"text":"if device present save device number and exit"},{"address":62029,"text":"do 'device not present' error and return"},{"address":62032,"text":"find a file"},{"address":62035,"text":"if file found continue"},{"address":62037,"text":"else do 'file not open' error and return"},{"address":62040,"text":"set file details from table,X"},{"address":62043,"text":"get the device number"},{"address":62045,"text":"if the device is not the keyboard go ??"},{"address":62047,"text":"go do 'not output file' error and return"},{"address":62050,"text":"compare the device with the screen"},{"address":62052,"text":"if the device is the screen go save output the output\ndevice number and exit"},{"address":62054,"text":"if \u003e screen then go handle a serial bus device"},{"address":62056,"text":"compare the device with the RS232 device"},{"address":62058,"text":"if not the RS232 device then it must be the tape device"},{"address":62060,"text":"else go open RS232 channel for output\nopen a tape channel for output"},{"address":62063,"text":"get the secondary address"},{"address":62067,"text":"if ?? do not output file error and return"},{"address":62069,"text":"save the output device number"},{"address":62071,"text":"flag ok"},{"address":62073,"text":"copy the device number"},{"address":62074,"text":"command devices on the serial bus to LISTEN"},{"address":62077,"text":"get the secondary address"},{"address":62079,"text":"if address to send go ??"},{"address":62081,"text":"else set serial ATN high"},{"address":62084,"text":"go ??, branch always"},{"address":62086,"text":"send secondary address after LISTEN"},{"address":62089,"text":"copy device number back to A"},{"address":62090,"text":"test the serial status byte"},{"address":62092,"text":"if the device is present go save the output device number\nand exit"},{"address":62094,"text":"else do 'device not present error' and return"},{"address":62097,"text":"find file A"},{"address":62100,"text":"if file found go close it"},{"address":62102,"text":"else the file was closed so just flag ok"},{"address":62104,"text":"set file details from table,X"},{"address":62107,"text":"copy file index to A"},{"address":62108,"text":"save file index"},{"address":62109,"text":"get the device number"},{"address":62111,"text":"if it is the keyboard go restore the index and close the\nfile"},{"address":62113,"text":"compare the device number with the screen"},{"address":62115,"text":"if it is the screen go restore the index and close the\nfile"},{"address":62117,"text":"if \u003e screen go do serial bus device close"},{"address":62119,"text":"compare the device with the RS232 device"},{"address":62121,"text":"if not the RS232 device go ??\nelse close RS232 device"},{"address":62123,"text":"restore file index"},{"address":62124,"text":"close file index X"},{"address":62127,"text":"initialise RS232 output"},{"address":62130,"text":"read the top of memory"},{"address":62133,"text":"get the RS232 input buffer pointer high byte"},{"address":62135,"text":"if no RS232 input buffer go ??"},{"address":62137,"text":"else reclaim RS232 input buffer memory"},{"address":62138,"text":"get the RS232 output buffer pointer high byte"},{"address":62140,"text":"if no RS232 output buffer skip the reclaim"},{"address":62142,"text":"else reclaim the RS232 output buffer memory"},{"address":62143,"text":"clear A"},{"address":62145,"text":"clear the RS232 input buffer pointer high byte"},{"address":62147,"text":"clear the RS232 output buffer pointer high byte"},{"address":62149,"text":"go set the top of memory to F0xx\nis not the RS232 device"},{"address":62152,"text":"get the secondary address"},{"address":62154,"text":"mask the device #"},{"address":62156,"text":"if ?? restore index and close file"},{"address":62158,"text":"get tape buffer start pointer in XY"},{"address":62161,"text":"character $00"},{"address":62163,"text":"flag the tape device"},{"address":62164,"text":"output the character to the cassette or RS232 device"},{"address":62167,"text":"initiate tape write"},{"address":62176,"text":"get the secondary address"},{"address":62180,"text":"if not ?? restore index and close file"},{"address":62182,"text":"set logical end of the tape"},{"address":62184,"text":"write tape header"},{"address":62187,"text":"restore index and close file"},{"address":62190,"text":"close serial bus device"},{"address":62193,"text":"restore file index"},{"address":62194,"text":"copy index to file to close"},{"address":62195,"text":"decrement the open file count"},{"address":62197,"text":"compare the index with the open file count"},{"address":62199,"text":"exit if equal, last entry was closing file\nelse entry was not last in list so copy last table entry\nfile details over the details of the closing one"},{"address":62201,"text":"get the open file count as index"},{"address":62203,"text":"get last+1 logical file number from logical file table"},{"address":62206,"text":"save logical file number over closed file"},{"address":62209,"text":"get last+1 device number from device number table"},{"address":62212,"text":"save device number over closed file"},{"address":62215,"text":"get last+1 secondary address from secondary address table"},{"address":62218,"text":"save secondary address over closed file"},{"address":62221,"text":"flag ok"},{"address":62223,"text":"clear A"},{"address":62225,"text":"clear the serial status byte"},{"address":62227,"text":"copy the logical file number to A"},{"address":62228,"text":"get the open file count"},{"address":62230,"text":"decrememnt the count to give the index"},{"address":62231,"text":"if no files just exit"},{"address":62233,"text":"compare the logical file number with the table logical\nfile number"},{"address":62236,"text":"if no match go try again"},{"address":62239,"text":"get logical file from logical file table"},{"address":62242,"text":"save the logical file"},{"address":62244,"text":"get device number from device number table"},{"address":62247,"text":"save the device number"},{"address":62249,"text":"get secondary address from secondary address table"},{"address":62252,"text":"save the secondary address"},{"address":62255,"text":"clear A"},{"address":62257,"text":"clear the open file count"},{"address":62259,"text":"set the screen device"},{"address":62261,"text":"compare the screen with the output device number"},{"address":62263,"text":"if \u003c= screen skip the serial bus unlisten"},{"address":62265,"text":"else command the serial bus to UNLISTEN"},{"address":62268,"text":"compare the screen with the input device number"},{"address":62270,"text":"if \u003c= screen skip the serial bus untalk"},{"address":62272,"text":"else command the serial bus to UNTALK"},{"address":62275,"text":"save the screen as the output device number"},{"address":62277,"text":"set the keyboard as the input device"},{"address":62279,"text":"save the input device number"},{"address":62282,"text":"get the logical file"},{"address":62284,"text":"if there is a file continue"},{"address":62286,"text":"else do 'not input file error' and return"},{"address":62289,"text":"find a file"},{"address":62292,"text":"if file not found continue"},{"address":62294,"text":"else do 'file already open' error and return"},{"address":62297,"text":"get the open file count"},{"address":62299,"text":"compare it with the maximum + 1"},{"address":62301,"text":"if less than maximum + 1 go open the file"},{"address":62303,"text":"else do 'too many files error' and return"},{"address":62306,"text":"increment the open file count"},{"address":62308,"text":"get the logical file"},{"address":62310,"text":"save it to the logical file table"},{"address":62313,"text":"get the secondary address"},{"address":62315,"text":"OR with the OPEN CHANNEL command"},{"address":62317,"text":"save the secondary address"},{"address":62319,"text":"save it to the secondary address table"},{"address":62322,"text":"get the device number"},{"address":62324,"text":"save it to the device number table"},{"address":62327,"text":"if it is the keyboard go do the ok exit"},{"address":62329,"text":"compare the device number with the screen"},{"address":62331,"text":"if it is the screen go do the ok exit"},{"address":62333,"text":"if tape or RS232 device go ??\nelse it is a serial bus device"},{"address":62335,"text":"send the secondary address and filename"},{"address":62338,"text":"go do ok exit, branch always"},{"address":62344,"text":"go open RS232 device and return"},{"address":62347,"text":"get tape buffer start pointer in XY"},{"address":62350,"text":"if \u003e= $0200 go ??"},{"address":62352,"text":"else do 'illegal device number' and return"},{"address":62355,"text":"get the secondary address"},{"address":62361,"text":"wait for PLAY"},{"address":62364,"text":"exit if STOP was pressed"},{"address":62366,"text":"print \"Searching...\""},{"address":62369,"text":"get file name length"},{"address":62371,"text":"if null file name just go find header"},{"address":62373,"text":"find specific tape header"},{"address":62376,"text":"branch if no error"},{"address":62378,"text":"exit if ??"},{"address":62380,"text":"do file not found error and return"},{"address":62383,"text":"find tape header, exit with header in buffer"},{"address":62386,"text":"exit if end of tape found"},{"address":62392,"text":"wait for PLAY/RECORD"},{"address":62395,"text":"exit if STOP was pressed"},{"address":62397,"text":"set data file header"},{"address":62399,"text":"write tape header"},{"address":62404,"text":"get the secondary address"},{"address":62410,"text":"clear index"},{"address":62414,"text":"save to tape buffer"},{"address":62416,"text":"clear A"},{"address":62417,"text":"save tape buffer index"},{"address":62419,"text":"flag ok"},{"address":62421,"text":"get the secondary address"},{"address":62423,"text":"ok exit if -ve"},{"address":62425,"text":"get file name length"},{"address":62427,"text":"ok exit if null"},{"address":62429,"text":"clear A"},{"address":62431,"text":"clear the serial status byte"},{"address":62433,"text":"get the device number"},{"address":62435,"text":"command devices on the serial bus to LISTEN"},{"address":62438,"text":"get the secondary address"},{"address":62440,"text":"OR with the OPEN command"},{"address":62442,"text":"send secondary address after LISTEN"},{"address":62445,"text":"get the serial status byte"},{"address":62447,"text":"if device present skip the 'device not present' error"},{"address":62449,"text":"else dump calling address low byte"},{"address":62450,"text":"dump calling address high byte"},{"address":62451,"text":"do 'device not present' error and return"},{"address":62454,"text":"get file name length"},{"address":62456,"text":"branch if null name"},{"address":62458,"text":"clear index"},{"address":62460,"text":"get file name byte"},{"address":62462,"text":"output byte to serial bus"},{"address":62465,"text":"increment index"},{"address":62466,"text":"compare with file name length"},{"address":62468,"text":"loop if not all done"},{"address":62470,"text":"command serial bus to UNLISTEN and return"},{"address":62473,"text":"initialise RS232 output"},{"address":62476,"text":"save the RS232 status register"},{"address":62479,"text":"compare with file name length"},{"address":62481,"text":"exit loop if done"},{"address":62483,"text":"get file name byte"},{"address":62485,"text":"copy to 6551 register set"},{"address":62488,"text":"increment index"},{"address":62489,"text":"compare with $04"},{"address":62491,"text":"loop if not to 4 yet"},{"address":62493,"text":"compute bit count"},{"address":62496,"text":"save bit count"},{"address":62499,"text":"get pseudo 6551 control register"},{"address":62502,"text":"mask 0000 xxxx, baud rate"},{"address":62504,"text":"if zero skip the baud rate setup"},{"address":62506,"text":"* 2 bytes per entry"},{"address":62507,"text":"copy to the index"},{"address":62508,"text":"get the PAL/NTSC flag"},{"address":62511,"text":"if PAL go set PAL timing"},{"address":62513,"text":"get the NTSC baud rate value high byte"},{"address":62516,"text":"get the NTSC baud rate value low byte"},{"address":62519,"text":"go save the baud rate values"},{"address":62522,"text":"get the PAL baud rate value high byte"},{"address":62525,"text":"get the PAL baud rate value low byte"},{"address":62528,"text":"save the nonstandard bit timing high byte"},{"address":62531,"text":"save the nonstandard bit timing low byte"},{"address":62534,"text":"get the nonstandard bit timing low byte"},{"address":62537,"text":"* 2"},{"address":62541,"text":"read the pseudo 6551 command register"},{"address":62544,"text":"shift the X line/3 line bit into Cb"},{"address":62545,"text":"if 3 line skip the DRS test"},{"address":62547,"text":"read VIA 2 DRB, RS232 port"},{"address":62550,"text":"shift DSR in into Cb"},{"address":62551,"text":"if DSR present skip the error set"},{"address":62553,"text":"set no DSR"},{"address":62556,"text":"get index to Rx buffer end"},{"address":62559,"text":"set index to Rx buffer start, clear Rx buffer"},{"address":62562,"text":"get index to Tx buffer end"},{"address":62565,"text":"set index to Tx buffer start, clear Tx buffer"},{"address":62568,"text":"read the top of memory"},{"address":62571,"text":"get the RS232 input buffer pointer high byte"},{"address":62573,"text":"if buffer already set skip the save"},{"address":62575,"text":"decrement top of memory high byte, 256 byte buffer"},{"address":62576,"text":"save the RS232 input buffer pointer high byte"},{"address":62578,"text":"save the RS232 input buffer pointer low byte"},{"address":62580,"text":"get the RS232 output buffer pointer high byte"},{"address":62582,"text":"if ?? go set the top of memory to F0xx"},{"address":62585,"text":"save the RS232 output buffer pointer high byte"},{"address":62587,"text":"save the RS232 output buffer pointer low byte"},{"address":62589,"text":"read the top of memory"},{"address":62590,"text":"set $F000"},{"address":62592,"text":"set the top of memory and return"},{"address":62595,"text":"disable all interrupts"},{"address":62597,"text":"save VIA 2 ICR"},{"address":62600,"text":"set RS232 DTR output, RS232 RTS output"},{"address":62602,"text":"save VIA 2 DDRB, RS232 port"},{"address":62605,"text":"save VIA 2 DRB, RS232 port"},{"address":62608,"text":"mask xxxx x1xx, set RS232 Tx DATA high"},{"address":62610,"text":"OR it with VIA 2 DRA, serial port and video address"},{"address":62613,"text":"save VIA 2 DRA, serial port and video address"},{"address":62616,"text":"clear Y"},{"address":62618,"text":"clear the RS-232 interrupt enable byte"},{"address":62622,"text":"set kernal setup pointer low byte"},{"address":62624,"text":"set kernal setup pointer high byte"},{"address":62626,"text":"do LOAD vector, usually points to $F4A5"},{"address":62629,"text":"save load/verify flag"},{"address":62631,"text":"clear A"},{"address":62633,"text":"clear the serial status byte"},{"address":62635,"text":"get the device number"},{"address":62637,"text":"if not the keyboard continue\ndo 'illegal device number'"},{"address":62639,"text":"else do 'illegal device number' and return"},{"address":62648,"text":"get file name length"},{"address":62650,"text":"if not null name go ??"},{"address":62652,"text":"else do 'missing file name' error and return"},{"address":62655,"text":"get the secondary address"},{"address":62657,"text":"print \"Searching...\""},{"address":62662,"text":"save the secondary address"},{"address":62664,"text":"send secondary address and filename"},{"address":62667,"text":"get the device number"},{"address":62669,"text":"command serial bus device to TALK"},{"address":62672,"text":"get the secondary address"},{"address":62674,"text":"send secondary address after TALK"},{"address":62677,"text":"input byte from serial bus"},{"address":62680,"text":"save program start address low byte"},{"address":62682,"text":"get the serial status byte"},{"address":62684,"text":"shift time out read .."},{"address":62685,"text":".. into carry bit"},{"address":62686,"text":"if timed out go do file not found error and return"},{"address":62688,"text":"input byte from serial bus"},{"address":62691,"text":"save program start address high byte"},{"address":62693,"text":"copy secondary address"},{"address":62694,"text":"load location not set in LOAD call, so continue with the\nload"},{"address":62696,"text":"get the load address low byte"},{"address":62698,"text":"save the program start address low byte"},{"address":62700,"text":"get the load address high byte"},{"address":62702,"text":"save the program start address high byte"},{"address":62707,"text":"mask xxxx xx0x, clear time out read bit"},{"address":62709,"text":"mask the serial status byte"},{"address":62711,"text":"set the serial status byte"},{"address":62713,"text":"scan stop key, return Zb = 1 = [STOP]"},{"address":62716,"text":"if not [STOP] go ??"},{"address":62718,"text":"else close the serial bus device and flag stop"},{"address":62721,"text":"input byte from serial bus"},{"address":62724,"text":"copy byte"},{"address":62725,"text":"get the serial status byte"},{"address":62727,"text":"shift time out read .."},{"address":62728,"text":".. into carry bit"},{"address":62729,"text":"if timed out go try again"},{"address":62731,"text":"copy received byte back"},{"address":62732,"text":"get load/verify flag"},{"address":62734,"text":"if load go load\nelse is verify"},{"address":62736,"text":"clear index"},{"address":62738,"text":"compare byte with previously loaded byte"},{"address":62740,"text":"if match go ??"},{"address":62742,"text":"flag read error"},{"address":62744,"text":"OR into the serial status byte"},{"address":62748,"text":"save byte to memory"},{"address":62750,"text":"increment save pointer low byte"},{"address":62752,"text":"if no rollover go ??"},{"address":62754,"text":"else increment save pointer high byte"},{"address":62756,"text":"test the serial status byte"},{"address":62758,"text":"loop if not end of file\nclose file and exit"},{"address":62760,"text":"command serial bus to UNTALK"},{"address":62763,"text":"close serial bus device"},{"address":62766,"text":"if ?? go flag ok and exit"},{"address":62768,"text":"do file not found error and return"},{"address":62774,"text":"else do 'illegal device number' and return"},{"address":62777,"text":"get tape buffer start pointer in XY"},{"address":62780,"text":"if ??"},{"address":62782,"text":"else do 'illegal device number' and return"},{"address":62785,"text":"wait for PLAY"},{"address":62788,"text":"exit if STOP was pressed"},{"address":62790,"text":"print \"Searching...\""},{"address":62793,"text":"get file name length"},{"address":62797,"text":"find specific tape header"},{"address":62800,"text":"if no error continue"},{"address":62802,"text":"exit if ??"},{"address":62804,"text":", branch always"},{"address":62806,"text":"find tape header, exit with header in buffer"},{"address":62809,"text":"exit if ??"},{"address":62813,"text":"get the serial status byte"},{"address":62815,"text":"mask 000x 0000, read error"},{"address":62817,"text":"flag fail"},{"address":62818,"text":"if read error just exit"},{"address":62841,"text":"get the secondary address"},{"address":62876,"text":"set I/O start addresses low byte"},{"address":62880,"text":"set I/O start addresses high byte"},{"address":62882,"text":"display \"LOADING\" or \"VERIFYING\""},{"address":62885,"text":"do the tape read"},{"address":62889,"text":"flag ok"},{"address":62890,"text":"get the LOAD end pointer low byte"},{"address":62892,"text":"get the LOAD end pointer high byte"},{"address":62895,"text":"get message mode flag"},{"address":62897,"text":"exit if control messages off"},{"address":62901,"text":"display kernel I/O message"},{"address":62904,"text":"get file name length"},{"address":62906,"text":"exit if null name"},{"address":62910,"text":"display kernel I/O message"},{"address":62913,"text":"get file name length"},{"address":62915,"text":"exit if null file name"},{"address":62917,"text":"clear index"},{"address":62919,"text":"get file name byte"},{"address":62921,"text":"output character to channel"},{"address":62924,"text":"increment index"},{"address":62925,"text":"compare with file name length"},{"address":62927,"text":"loop if more to do"},{"address":62932,"text":"get load/verify flag"},{"address":62934,"text":"branch if load"},{"address":62938,"text":"display kernel I/O message if in direct mode and return"},{"address":62941,"text":"save end address low byte"},{"address":62943,"text":"save end address high byte"},{"address":62945,"text":"copy index to start pointer"},{"address":62946,"text":"get start address low byte"},{"address":62948,"text":"set I/O start addresses low byte"},{"address":62950,"text":"get start address high byte"},{"address":62952,"text":"set I/O start addresses high byte"},{"address":62954,"text":"go save, usually points to $F685"},{"address":62957,"text":"get the device number"},{"address":62959,"text":"if not keyboard go ??\nelse .."},{"address":62961,"text":"else do 'illegal device number' and return"},{"address":62964,"text":"compare device number with screen"},{"address":62966,"text":"if screen do illegal device number and return"},{"address":62968,"text":"branch if \u003c screen\nis greater than screen so is serial bus"},{"address":62970,"text":"set secondary address to $01\nwhen a secondary address is to be sent to a device on\nthe serial bus the address must first be ORed with $60"},{"address":62972,"text":"save the secondary address"},{"address":62974,"text":"get the file name length"},{"address":62976,"text":"if filename not null continue"},{"address":62978,"text":"else do 'missing file name' error and return"},{"address":62981,"text":"send secondary address and filename"},{"address":62984,"text":"print saving \u003cfile name\u003e"},{"address":62987,"text":"get the device number"},{"address":62989,"text":"command devices on the serial bus to LISTEN"},{"address":62992,"text":"get the secondary address"},{"address":62994,"text":"send secondary address after LISTEN"},{"address":62997,"text":"clear index"},{"address":62999,"text":"copy I/O start address to buffer address"},{"address":63002,"text":"get buffer address low byte"},{"address":63004,"text":"output byte to serial bus"},{"address":63007,"text":"get buffer address high byte"},{"address":63009,"text":"output byte to serial bus"},{"address":63012,"text":"check read/write pointer, return Cb = 1 if pointer \u003e= end"},{"address":63015,"text":"go do UNLISTEN if at end"},{"address":63017,"text":"get byte from buffer"},{"address":63019,"text":"output byte to serial bus"},{"address":63022,"text":"scan stop key"},{"address":63025,"text":"if stop not pressed go increment pointer and loop for next\nelse ..\nclose the serial bus device and flag stop"},{"address":63027,"text":"close serial bus device"},{"address":63032,"text":"flag stop"},{"address":63034,"text":"increment read/write pointer"},{"address":63037,"text":"loop, branch always"},{"address":63039,"text":"command serial bus to UNLISTEN\nclose serial bus device"},{"address":63042,"text":"test the secondary address"},{"address":63044,"text":"if already closed just exit"},{"address":63046,"text":"get the device number"},{"address":63048,"text":"command devices on the serial bus to LISTEN"},{"address":63051,"text":"get the secondary address"},{"address":63053,"text":"mask the channel number"},{"address":63055,"text":"OR with the CLOSE command"},{"address":63057,"text":"send secondary address after LISTEN"},{"address":63060,"text":"command serial bus to UNLISTEN"},{"address":63063,"text":"flag ok"},{"address":63066,"text":"if not RS232 device ??"},{"address":63068,"text":"else do 'illegal device number' and return"},{"address":63071,"text":"get tape buffer start pointer in XY"},{"address":63074,"text":"if \u003c $0200 do illegal device number and return"},{"address":63076,"text":"wait for PLAY/RECORD"},{"address":63079,"text":"exit if STOP was pressed"},{"address":63081,"text":"print saving \u003cfile name\u003e"},{"address":63084,"text":"set header for a non relocatable program file"},{"address":63086,"text":"get the secondary address"},{"address":63088,"text":"mask non relocatable bit"},{"address":63090,"text":"if non relocatable program go ??"},{"address":63092,"text":"else set header for a relocatable program file"},{"address":63094,"text":"copy header type to A"},{"address":63095,"text":"write tape header"},{"address":63098,"text":"exit if error"},{"address":63100,"text":"do tape write, 20 cycle count"},{"address":63103,"text":"exit if error"},{"address":63105,"text":"get the secondary address"},{"address":63107,"text":"mask end of tape flag"},{"address":63109,"text":"if not end of tape go ??"},{"address":63111,"text":"else set logical end of the tape"},{"address":63113,"text":"write tape header"},{"address":63117,"text":"flag ok"},{"address":63119,"text":"get message mode flag"},{"address":63121,"text":"exit if control messages off"},{"address":63125,"text":"display kernel I/O message"},{"address":63128,"text":"print file name and return"},{"address":63131,"text":"clear X"},{"address":63133,"text":"increment the jiffy clock low byte"},{"address":63135,"text":"if no rollover ??"},{"address":63137,"text":"increment the jiffy clock mid byte"},{"address":63139,"text":"branch if no rollover"},{"address":63141,"text":"increment the jiffy clock high byte\nnow subtract a days worth of jiffies from current count\nand remember only the Cb result"},{"address":63143,"text":"set carry for subtract"},{"address":63144,"text":"get the jiffy clock low byte"},{"address":63146,"text":"subtract $4F1A01 low byte"},{"address":63148,"text":"get the jiffy clock mid byte"},{"address":63150,"text":"subtract $4F1A01 mid byte"},{"address":63152,"text":"get the jiffy clock high byte"},{"address":63154,"text":"subtract $4F1A01 high byte"},{"address":63156,"text":"if less than $4F1A01 jiffies skip the clock reset\nelse .."},{"address":63158,"text":"clear the jiffy clock high byte"},{"address":63160,"text":"clear the jiffy clock mid byte"},{"address":63162,"text":"clear the jiffy clock low byte\nthis is wrong, there are $4F1A00 jiffies in a day so\nthe reset to zero should occur when the value reaches\n$4F1A00 and not $4F1A01. this would give an extra jiffy\nevery day and a possible TI value of 24:00:00"},{"address":63164,"text":"read VIA 1 DRB, keyboard row port"},{"address":63167,"text":"compare it with itself"},{"address":63170,"text":"loop if changing"},{"address":63175,"text":"set c6"},{"address":63177,"text":"save VIA 1 DRA, keyboard column drive"},{"address":63180,"text":"read VIA 1 DRB, keyboard row port"},{"address":63183,"text":"compare it with itself"},{"address":63186,"text":"loop if changing"},{"address":63188,"text":"save VIA 1 DRA, keyboard column drive"},{"address":63194,"text":"save the stop key column"},{"address":63197,"text":"disable the interrupts"},{"address":63198,"text":"get the jiffy clock low byte"},{"address":63200,"text":"get the jiffy clock mid byte"},{"address":63202,"text":"get the jiffy clock high byte"},{"address":63204,"text":"disable the interrupts"},{"address":63205,"text":"save the jiffy clock low byte"},{"address":63207,"text":"save the jiffy clock mid byte"},{"address":63209,"text":"save the jiffy clock high byte"},{"address":63211,"text":"enable the interrupts"},{"address":63213,"text":"read the stop key column"},{"address":63215,"text":"compare with [STP] down"},{"address":63217,"text":"if not [STP] or not just [STP] exit\njust [STP] was pressed"},{"address":63219,"text":"save status"},{"address":63220,"text":"close input and output channels"},{"address":63223,"text":"save the keyboard buffer index"},{"address":63225,"text":"restore status"},{"address":63227,"text":"'too many files' error"},{"address":63230,"text":"'file already open' error"},{"address":63233,"text":"'file not open' error"},{"address":63236,"text":"'file not found' error"},{"address":63239,"text":"'device not present' error"},{"address":63242,"text":"'not input file' error"},{"address":63245,"text":"'not output file' error"},{"address":63248,"text":"'missing file name' error"},{"address":63251,"text":"do 'illegal device number'"},{"address":63253,"text":"save the error #"},{"address":63254,"text":"close input and output channels"},{"address":63259,"text":"test message mode flag"},{"address":63261,"text":"exit if kernal messages off"},{"address":63263,"text":"display kernel I/O message"},{"address":63266,"text":"restore error #"},{"address":63267,"text":"copy error #"},{"address":63268,"text":"convert to ASCII"},{"address":63270,"text":"output character to channel"},{"address":63273,"text":"pull error number"},{"address":63274,"text":"flag error"},{"address":63276,"text":"get load/verify flag"},{"address":63278,"text":"save load/verify flag"},{"address":63279,"text":"initiate tape read"},{"address":63282,"text":"restore load/verify flag"},{"address":63283,"text":"save load/verify flag"},{"address":63285,"text":"exit if error"},{"address":63287,"text":"clear the index"},{"address":63289,"text":"read first byte from tape buffer"},{"address":63291,"text":"compare with logical end of the tape"},{"address":63293,"text":"if end of the tape exit"},{"address":63295,"text":"compare with header for a relocatable program file"},{"address":63297,"text":"if program file header go ??"},{"address":63299,"text":"compare with header for a non relocatable program file"},{"address":63301,"text":"if program file header go  ??"},{"address":63303,"text":"compare with data file header"},{"address":63305,"text":"if data file loop to find the tape header\nwas a program file header"},{"address":63307,"text":"copy header type"},{"address":63308,"text":"get message mode flag"},{"address":63310,"text":"exit if control messages off"},{"address":63314,"text":"display kernel I/O message"},{"address":63317,"text":"index to the tape filename"},{"address":63319,"text":"get byte from tape buffer"},{"address":63321,"text":"output character to channel"},{"address":63324,"text":"increment the index"},{"address":63325,"text":"compare it with end+1"},{"address":63327,"text":"loop if more to do"},{"address":63329,"text":"get the jiffy clock mid byte"},{"address":63331,"text":"wait ~8.5 seconds for any key from the STOP key column"},{"address":63334,"text":"waste cycles"},{"address":63335,"text":"flag no error"},{"address":63336,"text":"decrement the index"},{"address":63338,"text":"save header type"},{"address":63340,"text":"get tape buffer start pointer in XY"},{"address":63343,"text":"if \u003c $0200 just exit ??"},{"address":63345,"text":"get I/O start address high byte"},{"address":63347,"text":"save it"},{"address":63348,"text":"get I/O start address low byte"},{"address":63350,"text":"save it"},{"address":63351,"text":"get tape end address high byte"},{"address":63353,"text":"save it"},{"address":63354,"text":"get tape end address low byte"},{"address":63356,"text":"save it"},{"address":63357,"text":"index to header end"},{"address":63359,"text":"clear byte, [SPACE]"},{"address":63361,"text":"clear header byte"},{"address":63363,"text":"decrement index"},{"address":63364,"text":"loop if more to do"},{"address":63366,"text":"get the header type back"},{"address":63368,"text":"write it to header"},{"address":63370,"text":"increment the index"},{"address":63371,"text":"get the I/O start address low byte"},{"address":63373,"text":"write it to header"},{"address":63375,"text":"increment the index"},{"address":63376,"text":"get the I/O start address high byte"},{"address":63378,"text":"write it to header"},{"address":63380,"text":"increment the index"},{"address":63381,"text":"get the tape end address low byte"},{"address":63383,"text":"write it to header"},{"address":63385,"text":"increment the index"},{"address":63386,"text":"get the tape end address high byte"},{"address":63388,"text":"write it to header"},{"address":63390,"text":"increment the index"},{"address":63391,"text":"save the index"},{"address":63393,"text":"clear Y"},{"address":63395,"text":"clear the name index"},{"address":63397,"text":"get name index"},{"address":63399,"text":"compare with file name length"},{"address":63401,"text":"if all done exit the loop"},{"address":63403,"text":"get file name byte"},{"address":63405,"text":"get buffer index"},{"address":63407,"text":"save file name byte to buffer"},{"address":63409,"text":"increment file name index"},{"address":63411,"text":"increment tape buffer index"},{"address":63413,"text":"loop, branch always"},{"address":63415,"text":"set tape buffer start and end pointers"},{"address":63418,"text":"set write lead cycle count"},{"address":63420,"text":"save write lead cycle count"},{"address":63422,"text":"do tape write, no cycle count set"},{"address":63426,"text":"pull tape end address low byte"},{"address":63427,"text":"restore it"},{"address":63429,"text":"pull tape end address high byte"},{"address":63430,"text":"restore it"},{"address":63432,"text":"pull I/O start addresses low byte"},{"address":63433,"text":"restore it"},{"address":63435,"text":"pull I/O start addresses high byte"},{"address":63436,"text":"restore it"},{"address":63440,"text":"get tape buffer start pointer low byte"},{"address":63442,"text":"get tape buffer start pointer high byte"},{"address":63444,"text":"compare high byte with $02xx"},{"address":63447,"text":"get tape buffer start pointer in XY"},{"address":63450,"text":"copy tape buffer start pointer low byte"},{"address":63451,"text":"save as I/O address pointer low byte"},{"address":63453,"text":"clear carry for add"},{"address":63454,"text":"add buffer length low byte"},{"address":63456,"text":"save tape buffer end pointer low byte"},{"address":63458,"text":"copy tape buffer start pointer high byte"},{"address":63459,"text":"save as I/O address pointer high byte"},{"address":63461,"text":"add buffer length high byte"},{"address":63463,"text":"save tape buffer end pointer high byte"},{"address":63466,"text":"find tape header, exit with header in buffer"},{"address":63469,"text":"just exit if error"},{"address":63471,"text":"index to name"},{"address":63473,"text":"save as tape buffer index"},{"address":63475,"text":"clear Y"},{"address":63477,"text":"save as name buffer index"},{"address":63479,"text":"compare with file name length"},{"address":63481,"text":"ok exit if match"},{"address":63483,"text":"get file name byte"},{"address":63485,"text":"get index to tape buffer"},{"address":63487,"text":"compare with tape header name byte"},{"address":63489,"text":"if no match go get next header"},{"address":63491,"text":"else increment name buffer index"},{"address":63493,"text":"increment tape buffer index"},{"address":63495,"text":"get name buffer index"},{"address":63497,"text":"loop, branch always"},{"address":63499,"text":"flag ok"},{"address":63501,"text":"get tape buffer start pointer in XY"},{"address":63504,"text":"increment tape buffer index"},{"address":63506,"text":"get tape buffer index"},{"address":63508,"text":"compare with buffer length"},{"address":63511,"text":"return cassette sense in Zb"},{"address":63514,"text":"if switch closed just exit\ncassette switch was open"},{"address":63518,"text":"display kernel I/O message"},{"address":63521,"text":"scan stop key and flag abort if pressed\nnote if STOP was pressed the return is to the\nroutine that called this one and not here"},{"address":63524,"text":"return cassette sense in Zb"},{"address":63527,"text":"loop if the cassette switch is open"},{"address":63531,"text":"display kernel I/O message and return"},{"address":63534,"text":"set the mask for the cassette switch"},{"address":63536,"text":"test the 6510 I/O port"},{"address":63538,"text":"branch if cassette sense high"},{"address":63540,"text":"test the 6510 I/O port"},{"address":63544,"text":"return the cassette sense in Zb"},{"address":63547,"text":"exit if switch closed\ncassette switch was open"},{"address":63551,"text":"display message and wait for switch, branch always"},{"address":63553,"text":"clear A"},{"address":63555,"text":"clear serial status byte"},{"address":63557,"text":"clear the load/verify flag"},{"address":63559,"text":"set the tape buffer start and end pointers"},{"address":63562,"text":"wait for PLAY"},{"address":63565,"text":"exit if STOP was pressed, uses a further BCS at the\ntarget address to reach final target at $F8DC"},{"address":63567,"text":"disable interrupts"},{"address":63568,"text":"clear A"},{"address":63574,"text":"clear tape timing constant min byte"},{"address":63576,"text":"clear tape pass 1 error log/char buffer"},{"address":63578,"text":"clear tape pass 2 error log corrected"},{"address":63580,"text":"clear byte received flag"},{"address":63582,"text":"enable CA1 interrupt ??"},{"address":63584,"text":"set index for tape read vector"},{"address":63586,"text":"go do tape read/write, branch always"},{"address":63588,"text":"set tape buffer start and end pointers\ndo tape write, 20 cycle count"},{"address":63591,"text":"set write lead cycle count"},{"address":63593,"text":"save write lead cycle count\ndo tape write, no cycle count set"},{"address":63595,"text":"wait for PLAY/RECORD"},{"address":63598,"text":"if STOPped clear save IRQ address and exit"},{"address":63600,"text":"disable interrupts"},{"address":63601,"text":"enable ?? interrupt"},{"address":63603,"text":"set index for tape write tape leader vector"},{"address":63605,"text":"disable all interrupts"},{"address":63607,"text":"save VIA 1 ICR, disable all interrupts"},{"address":63610,"text":"save VIA 1 ICR, enable interrupts according to A\ncheck RS232 bus idle"},{"address":63613,"text":"read VIA 1 CRA"},{"address":63616,"text":"load timer B, timer B single shot, start timer B"},{"address":63618,"text":"save VIA 1 CRB"},{"address":63621,"text":"mask x00x 000x, TOD clock, load timer A, start timer A"},{"address":63623,"text":"save VIA 1 CRB shadow copy"},{"address":63629,"text":"read the vertical fine scroll and control register"},{"address":63632,"text":"mask xxx0 xxxx, blank the screen"},{"address":63634,"text":"save the vertical fine scroll and control register"},{"address":63637,"text":"get IRQ vector low byte"},{"address":63640,"text":"save IRQ vector low byte"},{"address":63643,"text":"get IRQ vector high byte"},{"address":63646,"text":"save IRQ vector high byte"},{"address":63649,"text":"set the tape vector"},{"address":63652,"text":"set copies count. the first copy is the load copy, the\nsecond copy is the verify copy"},{"address":63654,"text":"save copies count"},{"address":63656,"text":"new tape byte setup"},{"address":63659,"text":"read the 6510 I/O port"},{"address":63661,"text":"mask 000x xxxx, cassette motor on ??"},{"address":63663,"text":"save the 6510 I/O port"},{"address":63665,"text":"set the tape motor interlock\n326656 cycle delay, allow tape motor speed to stabilise"},{"address":63667,"text":"outer loop count"},{"address":63669,"text":"inner loop count"},{"address":63671,"text":"decrement inner loop count"},{"address":63672,"text":"loop if more to do"},{"address":63674,"text":"decrement outer loop count"},{"address":63675,"text":"loop if more to do"},{"address":63677,"text":"enable tape interrupts"},{"address":63678,"text":"get saved IRQ high byte"},{"address":63681,"text":"compare with the current IRQ high byte"},{"address":63684,"text":"flag ok"},{"address":63685,"text":"if tape write done go clear saved IRQ address and exit"},{"address":63687,"text":"scan stop key and flag abort if pressed\nnote if STOP was pressed the return is to the\nroutine that called this one and not here"},{"address":63690,"text":"increment real time clock"},{"address":63693,"text":"loop"},{"address":63696,"text":"scan stop key"},{"address":63699,"text":"flag no stop"},{"address":63700,"text":"exit if no stop"},{"address":63702,"text":"restore everything for STOP"},{"address":63705,"text":"flag stopped"},{"address":63706,"text":"dump return address low byte"},{"address":63707,"text":"dump return address high byte"},{"address":63708,"text":"clear A"},{"address":63710,"text":"clear saved IRQ address high byte"},{"address":63714,"text":"save tape timing constant max byte"},{"address":63716,"text":"get tape timing constant min byte"},{"address":63718,"text":"*2"},{"address":63719,"text":"*4"},{"address":63720,"text":"clear carry for add"},{"address":63721,"text":"add tape timing constant min byte *5"},{"address":63723,"text":"clear carry for add"},{"address":63724,"text":"add tape timing constant max byte"},{"address":63726,"text":"save tape timing constant max byte"},{"address":63730,"text":"test tape timing constant min byte"},{"address":63732,"text":"branch if b7 set"},{"address":63734,"text":"else shift carry into ??"},{"address":63735,"text":"shift tape timing constant max byte"},{"address":63738,"text":"shift tape timing constant max byte"},{"address":63742,"text":"get VIA 1 timer B low byte"},{"address":63745,"text":"compare with ??"},{"address":63747,"text":"loop if less"},{"address":63749,"text":"add tape timing constant max byte"},{"address":63751,"text":"save VIA 1 timer A low byte"},{"address":63755,"text":"add VIA 1 timer B high byte"},{"address":63758,"text":"save VIA 1 timer A high byte"},{"address":63761,"text":"read VIA 1 CRB shadow copy"},{"address":63764,"text":"save VIA 1 CRA"},{"address":63767,"text":"save VIA 1 CRA shadow copy"},{"address":63770,"text":"read VIA 1 ICR"},{"address":63773,"text":"mask 000x 0000, FLAG interrupt"},{"address":63775,"text":"if no FLAG interrupt just exit\nelse first call the IRQ routine"},{"address":63777,"text":"set the return address high byte"},{"address":63779,"text":"push the return address high byte"},{"address":63780,"text":"set the return address low byte"},{"address":63782,"text":"push the return address low byte"},{"address":63783,"text":"save the status and do the IRQ routine"},{"address":63786,"text":"enable interrupts"},{"address":63788,"text":"read VIA 1 timer B high byte"},{"address":63791,"text":"set $FF"},{"address":63793,"text":"A = $FF"},{"address":63794,"text":"subtract VIA 1 timer B low byte"},{"address":63797,"text":"compare it with VIA 1 timer B high byte"},{"address":63800,"text":"if timer low byte rolled over loop"},{"address":63802,"text":"save tape timing constant max byte"},{"address":63804,"text":"copy $FF - T2C_l"},{"address":63805,"text":"save VIA 1 timer B low byte"},{"address":63808,"text":"save VIA 1 timer B high byte"},{"address":63811,"text":"load timer B, timer B single shot, start timer B"},{"address":63813,"text":"save VIA 1 CRB"},{"address":63816,"text":"read VIA 1 ICR"},{"address":63819,"text":"save VIA 1 ICR shadow copy"},{"address":63822,"text":"y = $FF"},{"address":63823,"text":"subtract tape timing constant max byte\nA = $FF - T2C_h"},{"address":63825,"text":"save tape timing constant max byte\n$B1 = $FF - T2C_l"},{"address":63827,"text":"A = $FF - T2C_h \u003e\u003e 1"},{"address":63828,"text":"shift tape timing constant max byte\n$B1 = $FF - T2C_l \u003e\u003e 1"},{"address":63830,"text":"A = $FF - T2C_h \u003e\u003e 1"},{"address":63831,"text":"shift tape timing constant max byte\n$B1 = $FF - T2C_l \u003e\u003e 1"},{"address":63833,"text":"get tape timing constant min byte"},{"address":63835,"text":"clear carry for add"},{"address":63838,"text":"compare with tape timing constant max byte\ncompare with ($FFFF - T2C) \u003e\u003e 2"},{"address":63840,"text":"branch if min + $3C \u003e= ($FFFF - T2C) \u003e\u003e 2\nmin + $3C \u003c ($FFFF - T2C) \u003e\u003e 2"},{"address":63842,"text":"get byte received flag"},{"address":63844,"text":"if not byte received ??"},{"address":63846,"text":"store the tape character"},{"address":63849,"text":"get EOI flag byte"},{"address":63857,"text":"add tape timing constant min byte"},{"address":63859,"text":"compare with tape timing constant max byte"},{"address":63866,"text":"add tape timing constant min byte"},{"address":63868,"text":"compare with tape timing constant max byte"},{"address":63874,"text":"add tape timing constant min byte"},{"address":63876,"text":"compare with tape timing constant max byte"},{"address":63883,"text":"get the bit count"},{"address":63885,"text":"if all done go ??"},{"address":63887,"text":"save receiver bit count in"},{"address":63889,"text":"branch always"},{"address":63891,"text":"increment ?? start bit check flag"},{"address":63895,"text":"decrement ?? start bit check flag"},{"address":63900,"text":"subtract tape timing constant max byte"},{"address":63902,"text":"add timing constant for tape"},{"address":63904,"text":"save timing constant for tape"},{"address":63906,"text":"get tape bit cycle phase"},{"address":63910,"text":"save tape bit cycle phase"},{"address":63916,"text":"get the bit count"},{"address":63918,"text":"if all done go ??"},{"address":63920,"text":"read VIA 1 ICR shadow copy"},{"address":63923,"text":"mask 0000 000x, timer A interrupt enabled"},{"address":63925,"text":"if timer A is enabled go ??"},{"address":63927,"text":"read VIA 1 CRA shadow copy"},{"address":63930,"text":"if ?? just exit"},{"address":63932,"text":"clear A"},{"address":63934,"text":"clear the tape bit cycle phase"},{"address":63936,"text":"save VIA 1 CRA shadow copy"},{"address":63939,"text":"get EOI flag byte"},{"address":63945,"text":"set timimg max byte"},{"address":63947,"text":"set timing"},{"address":63954,"text":"restore registers and exit interrupt"},{"address":63957,"text":"get timing constant for tape"},{"address":63963,"text":"decrement tape timing constant min byte"},{"address":63966,"text":"increment tape timing constant min byte"},{"address":63970,"text":"clear timing constant for tape"},{"address":63979,"text":"get start bit check flag"},{"address":63987,"text":"save cassette block synchronization number"},{"address":64000,"text":"decrement EOI flag byte"},{"address":64006,"text":"parity count"},{"address":64008,"text":"set timimg max byte"},{"address":64010,"text":"set timing"},{"address":64013,"text":"restore registers and exit interrupt"},{"address":64016,"text":"get cassette block synchronization number"},{"address":64024,"text":"get EOI flag byte"},{"address":64031,"text":"shift tape timing constant max byte"},{"address":64036,"text":"subtract tape timing constant max byte"},{"address":64038,"text":"add tape timing constant min byte"},{"address":64041,"text":"copy timimg high byte"},{"address":64042,"text":"set timing"},{"address":64051,"text":"get cassette block synchronization number"},{"address":64055,"text":"save receiver bit count in"},{"address":64057,"text":"clear A"},{"address":64059,"text":"clear cassette block synchronization number"},{"address":64061,"text":"enable timer A interrupt"},{"address":64063,"text":"save VIA 1 ICR"},{"address":64068,"text":"get cassette block synchronization number"},{"address":64078,"text":"disable timer A interrupt"},{"address":64080,"text":"save VIA 1 ICR"},{"address":64083,"text":"parity count"},{"address":64085,"text":"save RS232 parity byte"},{"address":64087,"text":"get receiver bit count in"},{"address":64089,"text":"OR with start bit check flag"},{"address":64093,"text":"restore registers and exit interrupt"},{"address":64096,"text":"new tape byte setup"},{"address":64099,"text":"clear byte received flag"},{"address":64101,"text":"set timimg max byte"},{"address":64103,"text":"set timing"},{"address":64106,"text":"get copies count"},{"address":64110,"text":"save receiver input bit temporary storage"},{"address":64122,"text":"get copies count"},{"address":64125,"text":"if ?? restore registers and exit interrupt"},{"address":64127,"text":"set short block"},{"address":64129,"text":"OR into serial status byte"},{"address":64132,"text":"restore registers and exit interrupt, branch always"},{"address":64138,"text":"restore registers and exit interrupt"},{"address":64153,"text":"get receiver input bit temporary storage"},{"address":64156,"text":"get RS232 parity byte"},{"address":64177,"text":"copy I/O start address to buffer address"},{"address":64190,"text":"restore registers and exit interrupt, branch always"},{"address":64198,"text":"OR into serial status byte"},{"address":64206,"text":"check read/write pointer, return Cb = 1 if pointer \u003e= end"},{"address":64214,"text":"get receiver input bit temporary storage"},{"address":64219,"text":"get load/verify flag"},{"address":64221,"text":"if load go ??"},{"address":64223,"text":"clear index"},{"address":64225,"text":"get RS232 parity byte"},{"address":64288,"text":"get load/verify flag"},{"address":64290,"text":"if load ??"},{"address":64292,"text":"get RS232 parity byte"},{"address":64309,"text":"OR into serial status byte"},{"address":64314,"text":"get load/verify flag"},{"address":64316,"text":"if verify go ??"},{"address":64319,"text":"get RS232 parity byte"},{"address":64323,"text":"increment read/write pointer"},{"address":64326,"text":"restore registers and exit interrupt, branch always"},{"address":64333,"text":"disable timer A interrupt"},{"address":64335,"text":"save VIA 1 ICR"},{"address":64338,"text":"read VIA 1 ICR"},{"address":64341,"text":"get copies count"},{"address":64346,"text":"save copies count"},{"address":64348,"text":"decrement receiver input bit temporary storage"},{"address":64354,"text":"if ?? restore registers and exit interrupt"},{"address":64356,"text":"save copies count"},{"address":64358,"text":"restore registers and exit interrupt, branch always"},{"address":64360,"text":"restore everything for STOP"},{"address":64363,"text":"copy I/O start address to buffer address"},{"address":64366,"text":"clear index"},{"address":64368,"text":"clear checksum"},{"address":64370,"text":"get byte from buffer"},{"address":64372,"text":"XOR with checksum"},{"address":64374,"text":"save new checksum"},{"address":64376,"text":"increment read/write pointer"},{"address":64379,"text":"check read/write pointer, return Cb = 1 if pointer \u003e= end"},{"address":64382,"text":"loop if not at end"},{"address":64384,"text":"get computed checksum"},{"address":64386,"text":"compare with stored checksum ??"},{"address":64388,"text":"if checksum ok restore registers and exit interrupt"},{"address":64390,"text":"else set checksum error"},{"address":64392,"text":"OR into the serial status byte"},{"address":64395,"text":"restore registers and exit interrupt"},{"address":64398,"text":"get I/O start address high byte"},{"address":64400,"text":"set buffer address high byte"},{"address":64402,"text":"get I/O start address low byte"},{"address":64404,"text":"set buffer address low byte"},{"address":64407,"text":"eight bits to do"},{"address":64409,"text":"set bit count"},{"address":64411,"text":"clear A"},{"address":64413,"text":"clear tape bit cycle phase"},{"address":64415,"text":"clear start bit first cycle done flag"},{"address":64417,"text":"clear byte parity"},{"address":64419,"text":"clear start bit check flag, set no start bit yet"},{"address":64422,"text":"get tape write byte"},{"address":64424,"text":"shift lsb into Cb"},{"address":64425,"text":"set time constant low byte for bit = 0"},{"address":64427,"text":"branch if bit was 0\nset time constant for bit = 1 and toggle tape"},{"address":64429,"text":"set time constant low byte for bit = 1\nwrite time constant and toggle tape"},{"address":64431,"text":"set time constant high byte\nwrite time constant and toggle tape"},{"address":64433,"text":"save VIA 1 timer B low byte"},{"address":64436,"text":"save VIA 1 timer B high byte"},{"address":64439,"text":"read VIA 1 ICR"},{"address":64442,"text":"load timer B, timer B single shot, start timer B"},{"address":64444,"text":"save VIA 1 CRB"},{"address":64447,"text":"read the 6510 I/O port"},{"address":64449,"text":"toggle tape out bit"},{"address":64451,"text":"save the 6510 I/O port"},{"address":64453,"text":"mask tape out bit"},{"address":64456,"text":"set carry flag"},{"address":64457,"text":"set buffer address high byte negative, flag all sync,\ndata and checksum bytes written"},{"address":64459,"text":"restore registers and exit interrupt, branch always"},{"address":64461,"text":"get start bit first cycle done flag"},{"address":64463,"text":"if first cycle done go do rest of byte\neach byte sent starts with two half cycles of $0110 ststem clocks and the whole block\nends with two more such half cycles"},{"address":64465,"text":"set first start cycle time constant low byte"},{"address":64467,"text":"set first start cycle time constant high byte"},{"address":64469,"text":"write time constant and toggle tape"},{"address":64472,"text":"if first half cycle go restore registers and exit\ninterrupt"},{"address":64474,"text":"set start bit first start cycle done flag"},{"address":64476,"text":"get buffer address high byte"},{"address":64478,"text":"if block not complete go restore registers and exit\ninterrupt. the end of a block is indicated by the tape\nbuffer high byte b7 being set to 1"},{"address":64480,"text":"else do tape routine, block complete exit\ncontinue tape byte write. the first start cycle, both half cycles of it, is complete\nso the routine drops straight through to here"},{"address":64483,"text":"get start bit check flag"},{"address":64485,"text":"if the start bit is complete go send the byte bits\nafter the two half cycles of $0110 ststem clocks the start bit is completed with two\nhalf cycles of $00B0 system clocks. this is the same as the first part of a 1 bit"},{"address":64487,"text":"set time constant for bit = 1 and toggle tape"},{"address":64490,"text":"if first half cycle go restore registers and exit\ninterrupt"},{"address":64492,"text":"set start bit check flag"},{"address":64494,"text":"restore registers and exit interrupt, branch always\ncontinue tape byte write. the start bit, both cycles of it, is complete so the routine\ndrops straight through to here. now the cycle pairs for each bit, and the parity bit,\nare sent"},{"address":64496,"text":"send lsb from tape write byte to tape"},{"address":64499,"text":"if first half cycle go restore registers and exit\ninterrupt\nelse two half cycles have been done"},{"address":64501,"text":"get tape bit cycle phase"},{"address":64503,"text":"toggle b0"},{"address":64505,"text":"save tape bit cycle phase"},{"address":64507,"text":"if bit cycle phase complete go setup for next bit\neach bit is written as two full cycles. a 1 is sent as a full cycle of $0160 system\nclocks then a full cycle of $00C0 system clocks. a 0 is sent as a full cycle of $00C0\nsystem clocks then a full cycle of $0160 system clocks. to do this each bit from the\nwrite byte is inverted during the second bit cycle phase. as the bit is inverted it\nis also added to the, one bit, parity count for this byte"},{"address":64509,"text":"get tape write byte"},{"address":64511,"text":"invert bit being sent"},{"address":64513,"text":"save tape write byte"},{"address":64515,"text":"mask b0"},{"address":64517,"text":"EOR with tape write byte parity bit"},{"address":64519,"text":"save tape write byte parity bit"},{"address":64521,"text":"restore registers and exit interrupt\nthe bit cycle phase is complete so shift out the just written bit and test for byte\nend"},{"address":64524,"text":"shift bit out of tape write byte"},{"address":64526,"text":"decrement tape write bit count"},{"address":64528,"text":"get tape write bit count"},{"address":64530,"text":"if all the data bits have been written go setup for\nsending the parity bit next and exit the interrupt"},{"address":64532,"text":"if all the data bits are not yet sent just restore the\nregisters and exit the interrupt\ndo next tape byte\nthe byte is complete. the start bit, data bits and parity bit have been written to\nthe tape so setup for the next byte"},{"address":64534,"text":"new tape byte setup"},{"address":64537,"text":"enable the interrupts"},{"address":64538,"text":"get cassette synchronization character count"},{"address":64540,"text":"if synchronisation characters done go do block data\nat the start of each block sent to tape there are a number of synchronisation bytes\nthat count down to the actual data. the commodore tape system saves two copies of all\nthe tape data, the first is loaded and is indicated by the synchronisation bytes\nhaving b7 set, and the second copy is indicated by the synchronisation bytes having b7\nclear. the sequence goes $09, $08, ..... $02, $01, data bytes"},{"address":64542,"text":"clear X"},{"address":64544,"text":"clear checksum byte"},{"address":64546,"text":"decrement cassette synchronization byte count"},{"address":64548,"text":"get cassette copies count"},{"address":64550,"text":"compare with load block indicator"},{"address":64552,"text":"branch if not the load block"},{"address":64554,"text":"this is the load block so make the synchronisation count\ngo $89, $88, ..... $82, $81"},{"address":64556,"text":"save the synchronisation byte as the tape write byte"},{"address":64558,"text":"restore registers and exit interrupt, branch always\nthe synchronization bytes have been done so now check and do the actual block data"},{"address":64560,"text":"check read/write pointer, return Cb = 1 if pointer \u003e= end"},{"address":64563,"text":"if not all done yet go get the byte to send"},{"address":64565,"text":"if pointer \u003e end go flag block done and exit interrupt\nelse the block is complete, it only remains to write the\nchecksum byte to the tape so setup for that"},{"address":64567,"text":"increment buffer pointer high byte, this means the block\ndone branch will always be taken next time without having\nto worry about the low byte wrapping to zero"},{"address":64569,"text":"get checksum byte"},{"address":64571,"text":"save checksum as tape write byte"},{"address":64573,"text":"restore registers and exit interrupt, branch always\nthe block isn't finished so get the next byte to write to tape"},{"address":64575,"text":"clear index"},{"address":64577,"text":"get byte from buffer"},{"address":64579,"text":"save as tape write byte"},{"address":64581,"text":"XOR with checksum byte"},{"address":64583,"text":"save new checksum byte"},{"address":64585,"text":"increment read/write pointer"},{"address":64588,"text":"restore registers and exit interrupt, branch always\nset parity as next bit and exit interrupt"},{"address":64590,"text":"get parity bit"},{"address":64592,"text":"toggle it"},{"address":64594,"text":"save as tape write byte"},{"address":64596,"text":"restore registers and exit interrupt\ntape routine, block complete exit"},{"address":64599,"text":"decrement copies remaining to read/write"},{"address":64601,"text":"branch if more to do"},{"address":64603,"text":"stop the cassette motor"},{"address":64606,"text":"set tape write leader count"},{"address":64608,"text":"save tape write leader count"},{"address":64610,"text":"set index for write tape leader vector"},{"address":64612,"text":"disable the interrupts"},{"address":64613,"text":"set the tape vector"},{"address":64616,"text":"restore registers and exit interrupt, branch always"},{"address":64618,"text":"set time constant low byte for bit = leader"},{"address":64620,"text":"write time constant and toggle tape"},{"address":64623,"text":"if tape bit high restore registers and exit interrupt"},{"address":64625,"text":"decrement cycle count"},{"address":64627,"text":"if not all done restore registers and exit interrupt"},{"address":64629,"text":"new tape byte setup"},{"address":64632,"text":"decrement cassette leader count"},{"address":64634,"text":"if not all done restore registers and exit interrupt"},{"address":64636,"text":"set index for tape write vector"},{"address":64638,"text":"set the tape vector"},{"address":64641,"text":"enable the interrupts"},{"address":64642,"text":"clear cassette leader counter, was $FF"},{"address":64644,"text":"get cassette block count"},{"address":64646,"text":"if all done restore everything for STOP and exit the\ninterrupt"},{"address":64648,"text":"copy I/O start address to buffer address"},{"address":64651,"text":"set nine synchronisation bytes"},{"address":64653,"text":"save cassette synchronization byte count"},{"address":64657,"text":"go do the next tape byte, branch always"},{"address":64659,"text":"save status"},{"address":64660,"text":"disable the interrupts"},{"address":64661,"text":"read the vertical fine scroll and control register"},{"address":64664,"text":"mask xxx1 xxxx, unblank the screen"},{"address":64666,"text":"save the vertical fine scroll and control register"},{"address":64669,"text":"stop the cassette motor"},{"address":64672,"text":"disable all interrupts"},{"address":64674,"text":"save VIA 1 ICR"},{"address":64680,"text":"get saved IRQ vector high byte"},{"address":64683,"text":"branch if null"},{"address":64685,"text":"restore IRQ vector high byte"},{"address":64688,"text":"get saved IRQ vector low byte"},{"address":64691,"text":"restore IRQ vector low byte"},{"address":64694,"text":"restore status"},{"address":64696,"text":"restore everything for STOP"},{"address":64699,"text":"restore registers and exit interrupt, branch always"},{"address":64701,"text":"get tape IRQ vector low byte"},{"address":64704,"text":"set IRQ vector low byte"},{"address":64707,"text":"get tape IRQ vector high byte"},{"address":64710,"text":"set IRQ vector high byte"},{"address":64714,"text":"read the 6510 I/O port"},{"address":64716,"text":"mask xxxx xx1x, turn the cassette motor off"},{"address":64718,"text":"save the 6510 I/O port"},{"address":64721,"text":"set carry for subtract"},{"address":64722,"text":"get buffer address low byte"},{"address":64724,"text":"subtract buffer end low byte"},{"address":64726,"text":"get buffer address high byte"},{"address":64728,"text":"subtract buffer end high byte"},{"address":64731,"text":"increment buffer address low byte"},{"address":64733,"text":"branch if no overflow"},{"address":64735,"text":"increment buffer address low byte"},{"address":64738,"text":"set X for stack"},{"address":64740,"text":"disable the interrupts"},{"address":64741,"text":"clear stack"},{"address":64742,"text":"clear decimal mode"},{"address":64743,"text":"scan for autostart ROM at $8000"},{"address":64746,"text":"if not there continue startup"},{"address":64748,"text":"else call ROM start code"},{"address":64751,"text":"read the horizontal fine scroll and control register"},{"address":64754,"text":"initialise SID, CIA and IRQ"},{"address":64757,"text":"RAM test and find RAM end"},{"address":64760,"text":"restore default I/O vectors"},{"address":64763,"text":"initialise VIC and screen editor"},{"address":64766,"text":"enable the interrupts"},{"address":64767,"text":"execute BASIC"},{"address":64770,"text":"five characters to test"},{"address":64772,"text":"get test character"},{"address":64775,"text":"compare wiith byte in ROM space"},{"address":64778,"text":"exit if no match"},{"address":64780,"text":"decrement index"},{"address":64781,"text":"loop if not all done"},{"address":64789,"text":"pointer to vector table low byte"},{"address":64791,"text":"pointer to vector table high byte"},{"address":64793,"text":"flag set vectors"},{"address":64794,"text":"save pointer low byte"},{"address":64796,"text":"save pointer high byte"},{"address":64798,"text":"set byte count"},{"address":64800,"text":"read vector byte from vectors"},{"address":64803,"text":"branch if read vectors"},{"address":64805,"text":"read vector byte from (XY)"},{"address":64807,"text":"save byte to (XY)"},{"address":64809,"text":"save byte to vector"},{"address":64812,"text":"decrement index"},{"address":64813,"text":"loop if more to do"},{"address":64848,"text":"clear A"},{"address":64850,"text":"clear index"},{"address":64851,"text":"clear page 0, don't do $0000 or $0001"},{"address":64854,"text":"clear page 2"},{"address":64857,"text":"clear page 3"},{"address":64860,"text":"increment index"},{"address":64861,"text":"loop if more to do"},{"address":64863,"text":"set cassette buffer pointer low byte"},{"address":64865,"text":"set cassette buffer pointer high byte"},{"address":64867,"text":"save tape buffer start pointer low byte"},{"address":64869,"text":"save tape buffer start pointer high byte"},{"address":64871,"text":"clear Y"},{"address":64872,"text":"set RAM test pointer high byte"},{"address":64874,"text":"save RAM test pointer high byte"},{"address":64876,"text":"increment RAM test pointer high byte"},{"address":64909,"text":"set the top of memory"},{"address":64914,"text":"save the OS start of memory high byte"},{"address":64919,"text":"save the screen memory page"},{"address":64931,"text":"disable all interrupts"},{"address":64933,"text":"save VIA 1 ICR"},{"address":64936,"text":"save VIA 2 ICR"},{"address":64939,"text":"save VIA 1 DRA, keyboard column drive"},{"address":64942,"text":"set timer single shot"},{"address":64944,"text":"save VIA 1 CRA"},{"address":64947,"text":"save VIA 2 CRA"},{"address":64950,"text":"save VIA 1 CRB"},{"address":64953,"text":"save VIA 2 CRB"},{"address":64956,"text":"set all inputs"},{"address":64958,"text":"save VIA 1 DDRB, keyboard row"},{"address":64961,"text":"save VIA 2 DDRB, RS232 port"},{"address":64964,"text":"clear the volume and filter select register"},{"address":64967,"text":"set X = $FF"},{"address":64968,"text":"save VIA 1 DDRA, keyboard column"},{"address":64971,"text":"DATA out high, CLK out high, ATN out high, RE232 Tx DATA\nhigh, video address 15 = 1, video address 14 = 1"},{"address":64973,"text":"save VIA 2 DRA, serial port and video address"},{"address":64976,"text":"set serial DATA input, serial CLK input"},{"address":64978,"text":"save VIA 2 DDRA, serial port and video address"},{"address":64981,"text":"set 1110 0111, motor off, enable I/O, enable KERNAL,\nenable BASIC"},{"address":64983,"text":"save the 6510 I/O port"},{"address":64985,"text":"set 0010 1111, 0 = input, 1 = output"},{"address":64987,"text":"save the 6510 I/O port direction register"},{"address":64989,"text":"get the PAL/NTSC flag"},{"address":64992,"text":"if NTSC go set NTSC timing\nelse set PAL timing"},{"address":64996,"text":"save VIA 1 timer A low byte"},{"address":65006,"text":"save VIA 1 timer A low byte"},{"address":65011,"text":"save VIA 1 timer A high byte"},{"address":65017,"text":"set file name length"},{"address":65019,"text":"set file name pointer low byte"},{"address":65021,"text":"set file name pointer high byte"},{"address":65024,"text":"save the logical file"},{"address":65026,"text":"save the device number"},{"address":65028,"text":"save the secondary address"},{"address":65031,"text":"get the device number"},{"address":65033,"text":"compare device with RS232 device"},{"address":65035,"text":"if not RS232 device go ??\nget RS232 device status"},{"address":65037,"text":"get the RS232 status register"},{"address":65040,"text":"save the RS232 status value"},{"address":65041,"text":"clear A"},{"address":65043,"text":"clear the RS232 status register"},{"address":65046,"text":"restore the RS232 status value"},{"address":65048,"text":"set message mode flag"},{"address":65050,"text":"read the serial status byte"},{"address":65052,"text":"OR with the serial status byte"},{"address":65054,"text":"save the serial status byte"},{"address":65057,"text":"save serial bus timeout flag"},{"address":65061,"text":"if Cb clear go set the top of memory"},{"address":65063,"text":"get memory top low byte"},{"address":65066,"text":"get memory top high byte"},{"address":65069,"text":"set memory top low byte"},{"address":65072,"text":"set memory top high byte"},{"address":65076,"text":"if Cb clear go set the bottom of memory"},{"address":65078,"text":"get the OS start of memory low byte"},{"address":65081,"text":"get the OS start of memory high byte"},{"address":65084,"text":"save the OS start of memory low byte"},{"address":65087,"text":"save the OS start of memory high byte"},{"address":65091,"text":"disable the interrupts"},{"address":65092,"text":"do NMI vector"},{"address":65095,"text":"save A"},{"address":65096,"text":"copy X"},{"address":65097,"text":"save X"},{"address":65098,"text":"copy Y"},{"address":65099,"text":"save Y"},{"address":65100,"text":"disable all interrupts"},{"address":65102,"text":"save VIA 2 ICR"},{"address":65105,"text":"save VIA 2 ICR"},{"address":65110,"text":"scan for autostart ROM at $8000"},{"address":65113,"text":"branch if no autostart ROM"},{"address":65115,"text":"else do autostart ROM break entry"},{"address":65118,"text":"increment real time clock"},{"address":65121,"text":"scan stop key"},{"address":65124,"text":"if not [STOP] restore registers and exit interrupt"},{"address":65126,"text":"restore default I/O vectors"},{"address":65129,"text":"initialise SID, CIA and IRQ"},{"address":65132,"text":"initialise the screen and keyboard"},{"address":65135,"text":"do BASIC break entry"},{"address":65139,"text":"AND with the RS-232 interrupt enable byte"},{"address":65147,"text":"read VIA 2 DRA, serial port and video address"},{"address":65150,"text":"mask xxxx x0xx, clear RS232 Tx DATA"},{"address":65152,"text":"OR in the RS232 transmit data bit"},{"address":65154,"text":"save VIA 2 DRA, serial port and video address"},{"address":65157,"text":"get the RS-232 interrupt enable byte"},{"address":65160,"text":"save VIA 2 ICR"},{"address":65187,"text":"get active interrupts back"},{"address":65188,"text":"mask ?? interrupt"},{"address":65190,"text":"branch if not ?? interrupt\nwas ?? interrupt"},{"address":65198,"text":"get active interrupts back"},{"address":65199,"text":"mask CB1 interrupt, Rx data bit transition"},{"address":65201,"text":"if no bit restore registers and exit interrupt"},{"address":65206,"text":"get the RS-232 interrupt enable byte"},{"address":65209,"text":"save VIA 2 ICR"},{"address":65212,"text":"pull Y"},{"address":65213,"text":"restore Y"},{"address":65214,"text":"pull X"},{"address":65215,"text":"restore X"},{"address":65216,"text":"restore A"},{"address":65238,"text":"read VIA 2 DRB, RS232 port"},{"address":65241,"text":"mask 0000 000x, RS232 Rx DATA"},{"address":65243,"text":"save the RS232 received data bit"},{"address":65245,"text":"get VIA 2 timer B low byte"},{"address":65253,"text":"save VIA 2 timer B low byte"},{"address":65256,"text":"get VIA 2 timer B high byte"},{"address":65262,"text":"save VIA 2 timer B high byte"},{"address":65265,"text":"set timer B single shot, start timer B"},{"address":65267,"text":"save VIA 2 CRB"},{"address":65270,"text":"get the RS-232 interrupt enable byte"},{"address":65273,"text":"save VIA 2 ICR"},{"address":65278,"text":"save VIA 2 timer B low byte"},{"address":65281,"text":"save VIA 2 timer B high byte"},{"address":65287,"text":"nonstandard bit timing low byte"},{"address":65290,"text":"save VIA 2 timer B low byte"},{"address":65293,"text":"nonstandard bit timing high byte"},{"address":65296,"text":"save VIA 2 timer B high byte"},{"address":65299,"text":"set timer B single shot, start timer B"},{"address":65301,"text":"save VIA 2 CRB"},{"address":65306,"text":"EOR with the RS-232 interrupt enable byte"},{"address":65309,"text":"save the RS-232 interrupt enable byte"},{"address":65314,"text":"save VIA 2 timer B low byte"},{"address":65317,"text":"save VIA 2 timer B high byte"},{"address":65327,"text":"nonstandard bit timing high byte"},{"address":65339,"text":"add any carry"},{"address":65345,"text":"waste cycles"},{"address":65346,"text":"waste cycles"},{"address":65347,"text":"save the processor status"},{"address":65348,"text":"pull the processor status"},{"address":65349,"text":"mask xxx0 xxxx, clear the break bit"},{"address":65351,"text":"save the modified processor status"},{"address":65352,"text":"save A"},{"address":65353,"text":"copy X"},{"address":65354,"text":"save X"},{"address":65355,"text":"copy Y"},{"address":65356,"text":"save Y"},{"address":65357,"text":"copy stack pointer"},{"address":65358,"text":"get stacked status register"},{"address":65361,"text":"mask BRK flag"},{"address":65363,"text":"branch if not BRK"},{"address":65365,"text":"else do BRK vector (iBRK)"},{"address":65368,"text":"do IRQ vector (iIRQ)"},{"address":65371,"text":"initialise the screen and keyboard"},{"address":65374,"text":"read the raster compare register"},{"address":65377,"text":"loop if not raster line $00"},{"address":65379,"text":"read the vic interrupt flag register"},{"address":65382,"text":"mask the raster compare flag"},{"address":65384,"text":"save the PAL/NTSC flag"},{"address":65390,"text":"enable timer A interrupt"},{"address":65392,"text":"save VIA 1 ICR"},{"address":65395,"text":"read VIA 1 CRA"},{"address":65398,"text":"mask x000 0000, TOD clock"},{"address":65400,"text":"mask xxx1 xxx1, load timer A, start timer A"},{"address":65402,"text":"save VIA 1 CRA"},{"address":65405,"text":"set the serial clock out low and return"},{"address":65409,"text":"initialise VIC and screen editor"},{"address":65412,"text":"initialise SID, CIA and IRQ"},{"address":65415,"text":"RAM test and find RAM end"},{"address":65418,"text":"restore default I/O vectors"},{"address":65421,"text":"read/set vectored I/O"},{"address":65424,"text":"control kernal messages"},{"address":65427,"text":"send secondary address after LISTEN"},{"address":65430,"text":"send secondary address after TALK"},{"address":65433,"text":"read/set the top of memory"},{"address":65436,"text":"read/set the bottom of memory"},{"address":65439,"text":"scan keyboard"},{"address":65442,"text":"set timeout on serial bus"},{"address":65445,"text":"input byte from serial bus"},{"address":65448,"text":"output byte to serial bus"},{"address":65451,"text":"command serial bus to UNTALK"},{"address":65454,"text":"command serial bus to UNLISTEN"},{"address":65457,"text":"command devices on the serial bus to LISTEN"},{"address":65460,"text":"command serial bus device to TALK"},{"address":65463,"text":"read I/O status word"},{"address":65466,"text":"set logical, first and second addresses"},{"address":65469,"text":"set the filename"},{"address":65472,"text":"do open a logical file"},{"address":65475,"text":"do close a specified logical file"},{"address":65478,"text":"do open channel for input"},{"address":65481,"text":"do open channel for output"},{"address":65484,"text":"do close input and output channels"},{"address":65487,"text":"do input character from channel"},{"address":65490,"text":"do output character to channel"},{"address":65493,"text":"load RAM from a device"},{"address":65496,"text":"save RAM to device"},{"address":65499,"text":"set real time clock"},{"address":65502,"text":"read real time clock"},{"address":65505,"text":"do scan stop key"},{"address":65508,"text":"do get character from input device"},{"address":65511,"text":"do close all channels and files"},{"address":65514,"text":"increment real time clock"},{"address":65517,"text":"return X,Y organization of screen"},{"address":65520,"text":"read/set X,Y cursor position"},{"address":65523,"text":"return the base address of the I/O devices"}]
